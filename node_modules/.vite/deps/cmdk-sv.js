import {
  arrow,
  autoUpdate,
  computePosition,
  createFocusTrap,
  dequal,
  flip,
  nanoid,
  offset,
  shift,
  size
} from "./chunk-D3HBI64D.js";
import "./chunk-3I4KI5X3.js";
import "./chunk-WLMUD2BW.js";
import {
  derived,
  readable,
  readonly,
  writable
} from "./chunk-6G5ZMJWZ.js";
import "./chunk-5WDIGX27.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  add_render_callback,
  append_hydration_dev,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  compute_rest_props,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  set_data_maybe_contenteditable_dev,
  set_dynamic_element_data,
  set_input_value,
  set_store_value,
  set_style,
  space,
  subscribe,
  text,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_slots,
  validate_store,
  validate_void_dynamic_element
} from "./chunk-UBKWXMOM.js";
import "./chunk-MET4JNUZ.js";
import {
  __export
} from "./chunk-UVKRO5ER.js";

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/internal/command-score.js
var SCORE_CONTINUE_MATCH = 1;
var SCORE_SPACE_WORD_JUMP = 0.9;
var SCORE_NON_SPACE_WORD_JUMP = 0.8;
var SCORE_CHARACTER_JUMP = 0.17;
var SCORE_TRANSPOSITION = 0.1;
var PENALTY_SKIPPED = 0.999;
var PENALTY_CASE_MISMATCH = 0.9999;
var PENALTY_NOT_COMPLETE = 0.99;
var IS_GAP_REGEXP = /[\\/_+.#"@[({&]/;
var COUNT_GAPS_REGEXP = /[\\/_+.#"@[({&]/g;
var IS_SPACE_REGEXP = /[\s-]/;
var COUNT_SPACE_REGEXP = /[\s-]/g;
function commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, stringIndex, abbreviationIndex, memoizedResults) {
  if (abbreviationIndex === abbreviation.length) {
    if (stringIndex === string.length) {
      return SCORE_CONTINUE_MATCH;
    }
    return PENALTY_NOT_COMPLETE;
  }
  const memoizeKey = `${stringIndex},${abbreviationIndex}`;
  if (memoizedResults[memoizeKey] !== void 0) {
    return memoizedResults[memoizeKey];
  }
  const abbreviationChar = lowerAbbreviation.charAt(abbreviationIndex);
  let index = lowerString.indexOf(abbreviationChar, stringIndex);
  let highScore = 0;
  let score, transposedScore, wordBreaks, spaceBreaks;
  while (index >= 0) {
    score = commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 1, memoizedResults);
    if (score > highScore) {
      if (index === stringIndex) {
        score *= SCORE_CONTINUE_MATCH;
      } else if (IS_GAP_REGEXP.test(string.charAt(index - 1))) {
        score *= SCORE_NON_SPACE_WORD_JUMP;
        wordBreaks = string.slice(stringIndex, index - 1).match(COUNT_GAPS_REGEXP);
        if (wordBreaks && stringIndex > 0) {
          score *= Math.pow(PENALTY_SKIPPED, wordBreaks.length);
        }
      } else if (IS_SPACE_REGEXP.test(string.charAt(index - 1))) {
        score *= SCORE_SPACE_WORD_JUMP;
        spaceBreaks = string.slice(stringIndex, index - 1).match(COUNT_SPACE_REGEXP);
        if (spaceBreaks && stringIndex > 0) {
          score *= Math.pow(PENALTY_SKIPPED, spaceBreaks.length);
        }
      } else {
        score *= SCORE_CHARACTER_JUMP;
        if (stringIndex > 0) {
          score *= Math.pow(PENALTY_SKIPPED, index - stringIndex);
        }
      }
      if (string.charAt(index) !== abbreviation.charAt(abbreviationIndex)) {
        score *= PENALTY_CASE_MISMATCH;
      }
    }
    if (score < SCORE_TRANSPOSITION && lowerString.charAt(index - 1) === lowerAbbreviation.charAt(abbreviationIndex + 1) || lowerAbbreviation.charAt(abbreviationIndex + 1) === lowerAbbreviation.charAt(abbreviationIndex) && // allow duplicate letters. Ref #7428
    lowerString.charAt(index - 1) !== lowerAbbreviation.charAt(abbreviationIndex)) {
      transposedScore = commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 2, memoizedResults);
      if (transposedScore * SCORE_TRANSPOSITION > score) {
        score = transposedScore * SCORE_TRANSPOSITION;
      }
    }
    if (score > highScore) {
      highScore = score;
    }
    index = lowerString.indexOf(abbreviationChar, index + 1);
  }
  memoizedResults[memoizeKey] = highScore;
  return highScore;
}
function formatInput(string) {
  return string.toLowerCase().replace(COUNT_SPACE_REGEXP, " ");
}
function commandScore(string, abbreviation) {
  return commandScoreInner(string, abbreviation, formatInput(string), formatInput(abbreviation), 0, 0, {});
}

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/internal/helpers/is.js
var isBrowser = typeof document !== "undefined";
function isHTMLElement(element2) {
  return element2 instanceof HTMLElement;
}
function isHTMLInputElement(element2) {
  return element2 instanceof HTMLInputElement;
}
function isUndefined(value) {
  return value === void 0;
}

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/internal/helpers/id.js
function generateId() {
  return nanoid(10);
}

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/internal/helpers/kbd.js
var kbd = {
  ALT: "Alt",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  BACKSPACE: "Backspace",
  CAPS_LOCK: "CapsLock",
  CONTROL: "Control",
  DELETE: "Delete",
  END: "End",
  ENTER: "Enter",
  ESCAPE: "Escape",
  F1: "F1",
  F10: "F10",
  F11: "F11",
  F12: "F12",
  F2: "F2",
  F3: "F3",
  F4: "F4",
  F5: "F5",
  F6: "F6",
  F7: "F7",
  F8: "F8",
  F9: "F9",
  HOME: "Home",
  META: "Meta",
  PAGE_DOWN: "PageDown",
  PAGE_UP: "PageUp",
  SHIFT: "Shift",
  SPACE: " ",
  TAB: "Tab",
  CTRL: "Control",
  ASTERISK: "*"
};

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/internal/helpers/object.js
function omit(obj, ...keys) {
  const result = {};
  for (const key of Object.keys(obj)) {
    if (!keys.includes(key)) {
      result[key] = obj[key];
    }
  }
  return result;
}
function removeUndefined(obj) {
  const result = {};
  for (const key in obj) {
    const value = obj[key];
    if (value !== void 0) {
      result[key] = value;
    }
  }
  return result;
}

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/internal/helpers/store.js
function toWritableStores(properties) {
  const result = {};
  Object.keys(properties).forEach((key) => {
    const propertyKey = key;
    const value = properties[propertyKey];
    result[propertyKey] = writable(value);
  });
  return result;
}

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/internal/helpers/style.js
function styleToString(style) {
  return Object.keys(style).reduce((str, key) => {
    if (style[key] === void 0)
      return str;
    return str + `${key}:${style[key]};`;
  }, "");
}
var srOnlyStyles = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0"
};

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/internal/helpers/event.js
function addEventListener(target, event, handler, options) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options));
  };
}

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/internal/helpers/callbacks.js
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/command.js
var NAME = "Command";
var STATE_NAME = "CommandState";
var GROUP_NAME = "CommandGroup";
var LIST_SELECTOR = `[data-cmdk-list-sizer]`;
var GROUP_SELECTOR = `[data-cmdk-group]`;
var GROUP_ITEMS_SELECTOR = `[data-cmdk-group-items]`;
var GROUP_HEADING_SELECTOR = `[data-cmdk-group-heading]`;
var ITEM_SELECTOR = `[data-cmdk-item]`;
var VALID_ITEM_SELECTOR = `${ITEM_SELECTOR}:not([aria-disabled="true"])`;
var VALUE_ATTR = `data-value`;
var defaultFilter = (value, search) => commandScore(value, search);
function getCtx() {
  return getContext(NAME);
}
function getState() {
  return getContext(STATE_NAME);
}
function createGroup(alwaysRender) {
  const id = generateId();
  setContext(GROUP_NAME, {
    id,
    alwaysRender: isUndefined(alwaysRender) ? false : alwaysRender
  });
  return { id };
}
function getGroup() {
  const context = getContext(GROUP_NAME);
  if (!context)
    return void 0;
  return context;
}
function createState(initialValues) {
  const defaultState = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: /* @__PURE__ */ new Map(),
      groups: /* @__PURE__ */ new Set()
    }
  };
  const state = writable(initialValues ? { ...defaultState, ...removeUndefined(initialValues) } : defaultState);
  return state;
}
var defaults = {
  label: "Command menu",
  shouldFilter: true,
  loop: false,
  onValueChange: void 0,
  value: void 0,
  filter: defaultFilter,
  ids: {
    root: generateId(),
    list: generateId(),
    label: generateId(),
    input: generateId()
  }
};
function createCommand(props) {
  const ids = {
    root: generateId(),
    list: generateId(),
    label: generateId(),
    input: generateId(),
    ...props.ids
  };
  const withDefaults = {
    ...defaults,
    ...removeUndefined(props)
  };
  const state = props.state ?? createState({
    value: withDefaults.value
  });
  const allItems = writable(/* @__PURE__ */ new Set());
  const allGroups = writable(/* @__PURE__ */ new Map());
  const allIds = writable(/* @__PURE__ */ new Map());
  const commandEl = writable(null);
  const options = toWritableStores(omit(withDefaults, "value", "ids"));
  const { shouldFilter, loop, filter, label } = options;
  const context = {
    value: (id, value) => {
      if (value !== get_store_value(allIds).get(id)) {
        allIds.update(($allIds) => {
          $allIds.set(id, value);
          return $allIds;
        });
        state.update(($state) => {
          $state.filtered.items.set(id, score(value, $state.search));
          const sortedState = sort($state, get_store_value(shouldFilter));
          return sortedState;
        });
      }
    },
    // Track item lifecycle (add/remove)
    item: (id, groupId) => {
      allItems.update(($allItems) => $allItems.add(id));
      if (groupId) {
        allGroups.update(($allGroups) => {
          var _a;
          if (!$allGroups.has(groupId)) {
            $allGroups.set(groupId, /* @__PURE__ */ new Set([id]));
          } else {
            (_a = $allGroups.get(groupId)) == null ? void 0 : _a.add(id);
          }
          return $allGroups;
        });
      }
      state.update(($state) => {
        const $shouldFilter = get_store_value(shouldFilter);
        const filteredState = filterItems($state, $shouldFilter);
        const sortedState = sort(filteredState, $shouldFilter);
        if (!sortedState.value) {
          const value = selectFirstItem();
          sortedState.value = value ?? "";
        }
        return sortedState;
      });
      return () => {
        allIds.update(($allIds) => {
          $allIds.delete(id);
          return $allIds;
        });
        allItems.update(($allItems) => {
          $allItems.delete(id);
          return $allItems;
        });
        state.update(($state) => {
          $state.filtered.items.delete(id);
          const selectedItem = getSelectedItem();
          const filteredState = filterItems($state);
          if ((selectedItem == null ? void 0 : selectedItem.getAttribute("id")) === id) {
            filteredState.value = selectFirstItem() ?? "";
          }
          return $state;
        });
      };
    },
    group: (id) => {
      allGroups.update(($allGroups) => {
        if (!$allGroups.has(id)) {
          $allGroups.set(id, /* @__PURE__ */ new Set());
        }
        return $allGroups;
      });
      return () => {
        allIds.update(($allIds) => {
          $allIds.delete(id);
          return $allIds;
        });
        allGroups.update(($allGroups) => {
          $allGroups.delete(id);
          return $allGroups;
        });
      };
    },
    filter: () => {
      return get_store_value(shouldFilter);
    },
    label: get_store_value(label) || props["aria-label"] || "",
    commandEl,
    ids,
    updateState
  };
  function updateState(key, value, preventScroll) {
    const $shouldFilter = get_store_value(shouldFilter);
    state.update((curr) => {
      var _a;
      if (Object.is(curr[key], value))
        return curr;
      curr[key] = value;
      if (key === "search") {
        const filteredState = filterItems(curr, $shouldFilter);
        curr = filteredState;
        const sortedState = sort(curr, $shouldFilter);
        curr = sortedState;
        tick().then(() => state.update((curr2) => {
          curr2.value = selectFirstItem() ?? "";
          return curr2;
        }));
      } else if (key === "value") {
        (_a = props.onValueChange) == null ? void 0 : _a.call(props, curr.value);
        if (!preventScroll) {
          tick().then(() => scrollSelectedIntoView());
        }
      }
      return curr;
    });
  }
  function filterItems(state2, shouldFilterVal) {
    const $shouldFilter = shouldFilterVal ?? get_store_value(shouldFilter);
    const $allItems = get_store_value(allItems);
    const $allIds = get_store_value(allIds);
    if (!state2.search || !$shouldFilter) {
      state2.filtered.count = $allItems.size;
      return state2;
    }
    state2.filtered.groups = /* @__PURE__ */ new Set();
    let itemCount = 0;
    for (const id of $allItems) {
      const value = $allIds.get(id);
      const rank = score(value, state2.search);
      state2.filtered.items.set(id, rank);
      if (rank > 0) {
        itemCount++;
      }
    }
    for (const [groupId, group] of get_store_value(allGroups)) {
      for (const itemId of group) {
        const rank = state2.filtered.items.get(itemId);
        if (rank && rank > 0) {
          state2.filtered.groups.add(groupId);
        }
      }
    }
    state2.filtered.count = itemCount;
    return state2;
  }
  function sort(state2, shouldFilterVal) {
    const $shouldFilter = shouldFilterVal ?? get_store_value(shouldFilter);
    if (!state2.search || !$shouldFilter) {
      return state2;
    }
    const scores = state2.filtered.items;
    const groups = [];
    const $allGroups = get_store_value(allGroups);
    state2.filtered.groups.forEach((value) => {
      const items = $allGroups.get(value);
      if (!items)
        return;
      let max = 0;
      items.forEach((item) => {
        const score2 = scores.get(item);
        if (isUndefined(score2))
          return;
        max = Math.max(score2, max);
      });
      groups.push([value, max]);
    });
    const rootEl = document.getElementById(ids.root);
    if (!rootEl)
      return state2;
    const list = rootEl.querySelector(LIST_SELECTOR);
    getValidItems(rootEl).sort((a, b) => {
      const valueA = a.getAttribute(VALUE_ATTR) ?? "";
      const valueB = b.getAttribute(VALUE_ATTR) ?? "";
      return (scores.get(valueA) ?? 0) - (scores.get(valueB) ?? 0);
    }).forEach((item) => {
      const group = item.closest(GROUP_ITEMS_SELECTOR);
      const closest = item.closest(`${GROUP_ITEMS_SELECTOR} > *`);
      if (isHTMLElement(group)) {
        if (item.parentElement === group) {
          group.appendChild(item);
        } else {
          if (!isHTMLElement(closest))
            return;
          group.appendChild(closest);
        }
      } else {
        if (!isHTMLElement(list))
          return;
        if (item.parentElement === list) {
          list.appendChild(item);
        } else {
          if (!isHTMLElement(closest))
            return;
          list.appendChild(closest);
        }
      }
    });
    groups.sort((a, b) => b[1] - a[1]).forEach((group) => {
      var _a;
      const el = rootEl.querySelector(`${GROUP_SELECTOR}[${VALUE_ATTR}="${group[0]}"]`);
      if (!isHTMLElement(el))
        return;
      (_a = el.parentElement) == null ? void 0 : _a.appendChild(el);
    });
    return state2;
  }
  function selectFirstItem() {
    const item = getValidItems().find((item2) => !item2.ariaDisabled);
    if (!item)
      return;
    const value = item.getAttribute(VALUE_ATTR);
    if (!value)
      return;
    return value;
  }
  function score(value, search) {
    const lowerCaseAndTrimmedValue = value == null ? void 0 : value.toLowerCase().trim();
    const filterFn = get_store_value(filter);
    if (!filterFn) {
      return lowerCaseAndTrimmedValue ? defaultFilter(lowerCaseAndTrimmedValue, search) : 0;
    }
    return lowerCaseAndTrimmedValue ? filterFn(lowerCaseAndTrimmedValue, search) : 0;
  }
  function scrollSelectedIntoView() {
    var _a;
    const item = getSelectedItem();
    if (!item) {
      return;
    }
    if (((_a = item.parentElement) == null ? void 0 : _a.firstChild) === item) {
      tick().then(() => {
        var _a2, _b;
        return (_b = (_a2 = item.closest(GROUP_SELECTOR)) == null ? void 0 : _a2.querySelector(GROUP_HEADING_SELECTOR)) == null ? void 0 : _b.scrollIntoView({
          block: "nearest"
        });
      });
    }
    tick().then(() => item.scrollIntoView({ block: "nearest" }));
  }
  function getValidItems(rootElement) {
    const rootEl = rootElement ?? document.getElementById(ids.root);
    if (!rootEl)
      return [];
    return Array.from(rootEl.querySelectorAll(VALID_ITEM_SELECTOR)).filter((el) => isHTMLElement(el));
  }
  function getSelectedItem(rootElement) {
    const rootEl = rootElement ?? document.getElementById(ids.root);
    if (!rootEl)
      return;
    const selectedEl = rootEl.querySelector(`${VALID_ITEM_SELECTOR}[aria-selected="true"]`);
    if (!isHTMLElement(selectedEl))
      return null;
    return selectedEl;
  }
  function updateSelectedToIndex(index) {
    const rootEl = document.getElementById(ids.root);
    if (!rootEl)
      return;
    const items = getValidItems(rootEl);
    const item = items[index];
    if (!item)
      return;
  }
  function updateSelectedByChange(change) {
    const selected = getSelectedItem();
    const items = getValidItems();
    const index = items.findIndex((item) => item === selected);
    let newSelected = items[index + change];
    if (get_store_value(loop)) {
      if (index + change < 0) {
        newSelected = items[items.length - 1];
      } else if (index + change === items.length) {
        newSelected = items[0];
      } else {
        newSelected = items[index + change];
      }
    }
    if (newSelected) {
      updateState("value", newSelected.getAttribute(VALUE_ATTR) ?? "");
    }
  }
  function updateSelectedToGroup(change) {
    const selected = getSelectedItem();
    let group = selected == null ? void 0 : selected.closest(GROUP_SELECTOR);
    let item = void 0;
    while (group && !item) {
      group = change > 0 ? findNextSibling(group, GROUP_SELECTOR) : findPreviousSibling(group, GROUP_SELECTOR);
      item = group == null ? void 0 : group.querySelector(VALID_ITEM_SELECTOR);
    }
    if (item) {
      updateState("value", item.getAttribute(VALUE_ATTR) ?? "");
    } else {
      updateSelectedByChange(change);
    }
  }
  function last2() {
    return updateSelectedToIndex(getValidItems().length - 1);
  }
  function next2(e) {
    e.preventDefault();
    if (e.metaKey) {
      last2();
    } else if (e.altKey) {
      updateSelectedToGroup(1);
    } else {
      updateSelectedByChange(1);
    }
  }
  function prev2(e) {
    e.preventDefault();
    if (e.metaKey) {
      updateSelectedToIndex(0);
    } else if (e.altKey) {
      updateSelectedToGroup(-1);
    } else {
      updateSelectedByChange(-1);
    }
  }
  function handleRootKeydown(e) {
    switch (e.key) {
      case kbd.ARROW_DOWN:
        next2(e);
        break;
      case kbd.ARROW_UP:
        prev2(e);
        break;
      case kbd.HOME:
        e.preventDefault();
        updateSelectedToIndex(0);
        break;
      case kbd.END:
        e.preventDefault();
        last2();
        break;
      case kbd.ENTER: {
        e.preventDefault();
        const item = getSelectedItem();
        if (item) {
          item.click();
        }
      }
    }
  }
  setContext(NAME, context);
  const stateStore = {
    subscribe: state.subscribe,
    update: state.update,
    set: state.set,
    updateState
  };
  setContext(STATE_NAME, stateStore);
  return {
    state: stateStore,
    handleRootKeydown,
    commandEl,
    ids
  };
}
function findNextSibling(el, selector10) {
  let sibling = el.nextElementSibling;
  while (sibling) {
    if (sibling.matches(selector10))
      return sibling;
    sibling = sibling.nextElementSibling;
  }
}
function findPreviousSibling(el, selector10) {
  let sibling = el.previousElementSibling;
  while (sibling) {
    if (sibling.matches(selector10))
      return sibling;
    sibling = sibling.previousElementSibling;
  }
}

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/index.js
var cmdk_exports = {};
__export(cmdk_exports, {
  CommandDialog: () => CommandDialog_default,
  CommandEmpty: () => CommandEmpty_default,
  CommandGroup: () => CommandGroup_default,
  CommandInput: () => CommandInput_default,
  CommandItem: () => CommandItem_default,
  CommandList: () => CommandList_default,
  CommandLoading: () => CommandLoading_default,
  CommandRoot: () => Command_default,
  CommandSeparator: () => CommandSeparator_default,
  Dialog: () => CommandDialog_default,
  Empty: () => CommandEmpty_default,
  Group: () => CommandGroup_default,
  Input: () => CommandInput_default,
  Item: () => CommandItem_default,
  List: () => CommandList_default,
  Loading: () => CommandLoading_default,
  Root: () => Command_default,
  Separator: () => CommandSeparator_default
});

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/Command.svelte
var file = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/Command.svelte";
var get_default_slot_spread_changes_1 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes_1 = (dirty) => ({});
var get_default_slot_context_1 = (ctx) => ({ .../*slotProps*/
ctx[2] });
var get_default_slot_spread_changes = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes = (dirty) => ({});
var get_default_slot_context = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_else_block(ctx) {
  let div;
  let label_1;
  let t0_value = (
    /*label*/
    (ctx[0] ?? "") + ""
  );
  let t0;
  let t1;
  let rootAction_action;
  let current;
  let mounted;
  let dispose;
  let label_1_levels = [
    /*labelAttrs*/
    ctx[6]
  ];
  let label_data = {};
  for (let i = 0; i < label_1_levels.length; i += 1) {
    label_data = assign(label_data, label_1_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_1
  );
  let div_levels = [
    /*rootAttrs*/
    ctx[5],
    /*$$restProps*/
    ctx[7]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      label_1 = element("label");
      t0 = text(t0_value);
      t1 = space();
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      label_1 = claim_element(div_nodes, "LABEL", {});
      var label_1_nodes = children(label_1);
      t0 = claim_text(label_1_nodes, t0_value);
      label_1_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label_1, label_data);
      add_location(label_1, file, 86, 2, 1774);
      set_attributes(div, div_data);
      add_location(div, file, 84, 1, 1643);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, label_1);
      append_hydration_dev(label_1, t0);
      append_hydration_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(rootAction_action = /*rootAction*/
        ctx[4].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*label*/
      1) && t0_value !== (t0_value = /*label*/
      (ctx2[0] ?? "") + "")) set_data_maybe_contenteditable_dev(t0, t0_value, label_data["contenteditable"]);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        131076)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            get_default_slot_spread_changes_1(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes_1
            ),
            get_default_slot_context_1
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        /*rootAttrs*/
        ctx2[5],
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(84:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        131076)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            get_default_slot_spread_changes(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(82:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let slotProps;
  const omit_props_names = [
    "label",
    "shouldFilter",
    "filter",
    "value",
    "onValueChange",
    "loop",
    "onKeydown",
    "state",
    "ids",
    "asChild"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $stateStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Command", slots, ["default"]);
  let { label = void 0 } = $$props;
  let { shouldFilter = true } = $$props;
  let { filter = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { onValueChange = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { onKeydown = void 0 } = $$props;
  let { state = void 0 } = $$props;
  let { ids = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { commandEl, handleRootKeydown, ids: commandIds, state: stateStore } = createCommand({
    label,
    shouldFilter,
    filter,
    value,
    onValueChange: (next2) => {
      if (next2 !== value) {
        $$invalidate(8, value = next2);
        onValueChange == null ? void 0 : onValueChange(next2);
      }
    },
    loop,
    state,
    ids
  });
  validate_store(stateStore, "stateStore");
  component_subscribe($$self, stateStore, (value2) => $$invalidate(16, $stateStore = value2));
  function syncValueAndState(value2) {
    if (value2 && value2 !== $stateStore.value) {
      set_store_value(stateStore, $stateStore.value = value2, $stateStore);
    }
  }
  function rootAction(node) {
    commandEl.set(node);
    const unsubEvents = executeCallbacks(addEventListener(node, "keydown", handleKeydown));
    return { destroy: unsubEvents };
  }
  const rootAttrs = {
    role: "application",
    id: commandIds.root,
    "data-cmdk-root": ""
  };
  const labelAttrs = {
    "data-cmdk-label": "",
    for: commandIds.input,
    id: commandIds.label,
    style: styleToString(srOnlyStyles)
  };
  function handleKeydown(e) {
    onKeydown == null ? void 0 : onKeydown(e);
    if (e.defaultPrevented) return;
    handleRootKeydown(e);
  }
  const root = { action: rootAction, attrs: rootAttrs };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
    if ("shouldFilter" in $$new_props) $$invalidate(9, shouldFilter = $$new_props.shouldFilter);
    if ("filter" in $$new_props) $$invalidate(10, filter = $$new_props.filter);
    if ("value" in $$new_props) $$invalidate(8, value = $$new_props.value);
    if ("onValueChange" in $$new_props) $$invalidate(11, onValueChange = $$new_props.onValueChange);
    if ("loop" in $$new_props) $$invalidate(12, loop = $$new_props.loop);
    if ("onKeydown" in $$new_props) $$invalidate(13, onKeydown = $$new_props.onKeydown);
    if ("state" in $$new_props) $$invalidate(14, state = $$new_props.state);
    if ("ids" in $$new_props) $$invalidate(15, ids = $$new_props.ids);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    addEventListener,
    executeCallbacks,
    srOnlyStyles,
    styleToString,
    createCommand,
    label,
    shouldFilter,
    filter,
    value,
    onValueChange,
    loop,
    onKeydown,
    state,
    ids,
    asChild,
    commandEl,
    handleRootKeydown,
    commandIds,
    stateStore,
    syncValueAndState,
    rootAction,
    rootAttrs,
    labelAttrs,
    handleKeydown,
    root,
    slotProps,
    $stateStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
    if ("shouldFilter" in $$props) $$invalidate(9, shouldFilter = $$new_props.shouldFilter);
    if ("filter" in $$props) $$invalidate(10, filter = $$new_props.filter);
    if ("value" in $$props) $$invalidate(8, value = $$new_props.value);
    if ("onValueChange" in $$props) $$invalidate(11, onValueChange = $$new_props.onValueChange);
    if ("loop" in $$props) $$invalidate(12, loop = $$new_props.loop);
    if ("onKeydown" in $$props) $$invalidate(13, onKeydown = $$new_props.onKeydown);
    if ("state" in $$props) $$invalidate(14, state = $$new_props.state);
    if ("ids" in $$props) $$invalidate(15, ids = $$new_props.ids);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("slotProps" in $$props) $$invalidate(2, slotProps = $$new_props.slotProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    256) {
      $: syncValueAndState(value);
    }
    if ($$self.$$.dirty & /*$stateStore*/
    65536) {
      $: $$invalidate(2, slotProps = {
        root,
        label: { attrs: labelAttrs },
        stateStore,
        state: $stateStore
      });
    }
  };
  return [
    label,
    asChild,
    slotProps,
    stateStore,
    rootAction,
    rootAttrs,
    labelAttrs,
    $$restProps,
    value,
    shouldFilter,
    filter,
    onValueChange,
    loop,
    onKeydown,
    state,
    ids,
    $stateStore,
    $$scope,
    slots
  ];
}
var Command = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      label: 0,
      shouldFilter: 9,
      filter: 10,
      value: 8,
      onValueChange: 11,
      loop: 12,
      onKeydown: 13,
      state: 14,
      ids: 15,
      asChild: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Command",
      options,
      id: create_fragment.name
    });
  }
  get label() {
    throw new Error("<Command>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Command>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldFilter() {
    throw new Error("<Command>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldFilter(value) {
    throw new Error("<Command>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filter() {
    throw new Error("<Command>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filter(value) {
    throw new Error("<Command>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Command>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Command>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValueChange() {
    throw new Error("<Command>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValueChange(value) {
    throw new Error("<Command>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<Command>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<Command>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onKeydown() {
    throw new Error("<Command>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onKeydown(value) {
    throw new Error("<Command>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get state() {
    throw new Error("<Command>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set state(value) {
    throw new Error("<Command>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ids() {
    throw new Error("<Command>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ids(value) {
    throw new Error("<Command>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Command>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Command>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Command_default = Command;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/accordion/index.js
var accordion_exports = {};
__export(accordion_exports, {
  Accordion: () => Accordion_default,
  AccordionContent: () => AccordionContent_default,
  AccordionHeader: () => AccordionHeader_default,
  AccordionItem: () => AccordionItem_default,
  AccordionTrigger: () => AccordionTrigger_default,
  Content: () => AccordionContent_default,
  Header: () => AccordionHeader_default,
  Item: () => AccordionItem_default,
  Root: () => Accordion_default,
  Trigger: () => AccordionTrigger_default
});

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/array.js
function back(array, index, increment, loop = true) {
  const previousIndex = index - increment;
  if (previousIndex <= 0) {
    return loop ? array[array.length - 1] : array[0];
  }
  return array[previousIndex];
}
function forward(array, index, increment, loop = true) {
  const nextIndex = index + increment;
  if (nextIndex > array.length - 1) {
    return loop ? array[0] : array[array.length - 1];
  }
  return array[nextIndex];
}
function next(array, index, loop = true) {
  if (index === array.length - 1) {
    return loop ? array[0] : array[index];
  }
  return array[index + 1];
}
function prev(array, currentIndex, loop = true) {
  if (currentIndex <= 0) {
    return loop ? array[array.length - 1] : array[0];
  }
  return array[currentIndex - 1];
}
function last(array) {
  return array[array.length - 1];
}
function wrapArray(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}
function toggle(item, array, compare = dequal) {
  const itemIdx = array.findIndex((innerItem) => compare(innerItem, item));
  if (itemIdx !== -1) {
    array.splice(itemIdx, 1);
  } else {
    array.push(item);
  }
  return array;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/style.js
function styleToString2(style) {
  return Object.keys(style).reduce((str, key) => {
    if (style[key] === void 0)
      return str;
    return str + `${key}:${style[key]};`;
  }, "");
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/attr.js
function disabledAttr(disabled) {
  return disabled ? true : void 0;
}
function ariaDisabledAttr(disabled) {
  return disabled ? "true" : void 0;
}
var hiddenInputAttrs = {
  type: "hidden",
  "aria-hidden": true,
  hidden: true,
  tabIndex: -1,
  style: styleToString2({
    position: "absolute",
    opacity: 0,
    "pointer-events": "none",
    margin: 0,
    transform: "translateX(-100%)"
  })
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/store/lightable.js
function lightable(value) {
  function subscribe2(run) {
    run(value);
    return () => {
    };
  }
  return { subscribe: subscribe2 };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/builder.js
function getElementByMeltId(id) {
  if (!isBrowser2)
    return null;
  const el = document.querySelector(`[data-melt-id="${id}"]`);
  return isHTMLElement2(el) ? el : null;
}
var hiddenAction = (obj) => {
  return new Proxy(obj, {
    get(target, prop, receiver) {
      return Reflect.get(target, prop, receiver);
    },
    ownKeys(target) {
      return Reflect.ownKeys(target).filter((key) => key !== "action");
    }
  });
};
var isFunctionWithParams = (fn) => {
  return typeof fn === "function";
};
function builder(name27, args) {
  const { stores, action, returned } = args ?? {};
  const derivedStore = (() => {
    if (stores && returned) {
      return derived(stores, (values) => {
        const result = returned(values);
        if (isFunctionWithParams(result)) {
          const fn = (...args2) => {
            return hiddenAction({
              ...result(...args2),
              [`data-melt-${name27}`]: "",
              action: action ?? noop2
            });
          };
          fn.action = action ?? noop2;
          return fn;
        }
        return hiddenAction({
          ...result,
          [`data-melt-${name27}`]: "",
          action: action ?? noop2
        });
      });
    } else {
      const returnedFn = returned;
      const result = returnedFn == null ? void 0 : returnedFn();
      if (isFunctionWithParams(result)) {
        const resultFn = (...args2) => {
          return hiddenAction({
            ...result(...args2),
            [`data-melt-${name27}`]: "",
            action: action ?? noop2
          });
        };
        resultFn.action = action ?? noop2;
        return lightable(resultFn);
      }
      return lightable(hiddenAction({
        ...result,
        [`data-melt-${name27}`]: "",
        action: action ?? noop2
      }));
    }
  })();
  const actionFn = action ?? (() => {
  });
  actionFn.subscribe = derivedStore.subscribe;
  return actionFn;
}
function createElHelpers(prefix) {
  const name27 = (part) => part ? `${prefix}-${part}` : prefix;
  const attribute2 = (part) => `data-melt-${prefix}${part ? `-${part}` : ""}`;
  const selector10 = (part) => `[data-melt-${prefix}${part ? `-${part}` : ""}]`;
  const getEl = (part) => document.querySelector(selector10(part));
  return {
    name: name27,
    attribute: attribute2,
    selector: selector10,
    getEl
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/is.js
var isBrowser2 = typeof document !== "undefined";
var isFunction = (v) => typeof v === "function";
function isElement(element2) {
  return element2 instanceof Element;
}
function isHTMLElement2(element2) {
  return element2 instanceof HTMLElement;
}
function isHTMLInputElement2(element2) {
  return element2 instanceof HTMLInputElement;
}
function isHTMLLabelElement(element2) {
  return element2 instanceof HTMLLabelElement;
}
function isHTMLButtonElement(element2) {
  return element2 instanceof HTMLButtonElement;
}
function isElementDisabled(element2) {
  const ariaDisabled = element2.getAttribute("aria-disabled");
  const disabled = element2.getAttribute("disabled");
  const dataDisabled = element2.hasAttribute("data-disabled");
  if (ariaDisabled === "true" || disabled !== null || dataDisabled) {
    return true;
  }
  return false;
}
function isTouch(event) {
  return event.pointerType === "touch";
}
function isLeftClick(event) {
  return event.button === 0 && event.ctrlKey === false && event.metaKey === false;
}
function isFocusVisible(element2) {
  return element2.matches(":focus-visible");
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/dom.js
function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) {
    nodes.push(walker.currentNode);
  }
  return nodes;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/callbacks.js
function executeCallbacks2(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}
function noop2() {
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/event.js
function addEventListener2(target, event, handler, options) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options));
  };
}
function addMeltEventListener(target, event, handler, options) {
  const events = Array.isArray(event) ? event : [event];
  if (typeof handler === "function") {
    const handlerWithMelt = withMelt((_event) => handler(_event));
    events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options));
    return () => {
      events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options));
    };
  }
  return () => noop2();
}
function dispatchMeltEvent(originalEvent) {
  const node = originalEvent.currentTarget;
  if (!isHTMLElement2(node))
    return null;
  const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {
    detail: {
      originalEvent
    },
    cancelable: true
  });
  node.dispatchEvent(customMeltEvent);
  return customMeltEvent;
}
function withMelt(handler) {
  return (event) => {
    const customEvent = dispatchMeltEvent(event);
    if (customEvent == null ? void 0 : customEvent.defaultPrevented)
      return;
    return handler(event);
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/highlight.js
function addHighlight(element2) {
  element2.setAttribute("data-highlighted", "");
}
function removeHighlight(element2) {
  element2.removeAttribute("data-highlighted");
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/list.js
function getOptions(el) {
  return Array.from(el.querySelectorAll('[role="option"]:not([data-disabled])')).filter((el2) => isHTMLElement2(el2));
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/locale.js
function getElemDirection(elem) {
  const style = window.getComputedStyle(elem);
  const direction = style.getPropertyValue("direction");
  return direction;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/object.js
function omit2(obj, ...keys) {
  const result = {};
  for (const key of Object.keys(obj)) {
    if (!keys.includes(key)) {
      result[key] = obj[key];
    }
  }
  return result;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/overridable.js
var overridable = (store, onChange) => {
  const update = (updater, sideEffect) => {
    store.update((curr) => {
      const next2 = updater(curr);
      let res = next2;
      if (onChange) {
        res = onChange({ curr, next: next2 });
      }
      sideEffect == null ? void 0 : sideEffect(res);
      return res;
    });
  };
  const set = (curr) => {
    update(() => curr);
  };
  return {
    ...store,
    update,
    set
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/sleep.js
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// ../../node_modules/.pnpm/nanoid@4.0.2/node_modules/nanoid/non-secure/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var nanoid2 = (size2 = 21) => {
  let id = "";
  let i = size2;
  while (i--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/id.js
function generateId2() {
  return nanoid2(10);
}
function generateIds(args) {
  return args.reduce((acc, curr) => {
    acc[curr] = generateId2();
    return acc;
  }, {});
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/keyboard.js
var kbd2 = {
  ALT: "Alt",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  BACKSPACE: "Backspace",
  CAPS_LOCK: "CapsLock",
  CONTROL: "Control",
  DELETE: "Delete",
  END: "End",
  ENTER: "Enter",
  ESCAPE: "Escape",
  F1: "F1",
  F10: "F10",
  F11: "F11",
  F12: "F12",
  F2: "F2",
  F3: "F3",
  F4: "F4",
  F5: "F5",
  F6: "F6",
  F7: "F7",
  F8: "F8",
  F9: "F9",
  HOME: "Home",
  META: "Meta",
  PAGE_DOWN: "PageDown",
  PAGE_UP: "PageUp",
  SHIFT: "Shift",
  SPACE: " ",
  TAB: "Tab",
  CTRL: "Control",
  ASTERISK: "*",
  A: "a",
  P: "p"
};
var FIRST_KEYS = [kbd2.ARROW_DOWN, kbd2.PAGE_UP, kbd2.HOME];
var LAST_KEYS = [kbd2.ARROW_UP, kbd2.PAGE_DOWN, kbd2.END];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SELECTION_KEYS = [kbd2.ENTER, kbd2.SPACE];
var getNextKey = (dir = "ltr", orientation = "horizontal") => {
  return {
    horizontal: dir === "rtl" ? kbd2.ARROW_LEFT : kbd2.ARROW_RIGHT,
    vertical: kbd2.ARROW_DOWN
  }[orientation];
};
var getPrevKey = (dir = "ltr", orientation = "horizontal") => {
  return {
    horizontal: dir === "rtl" ? kbd2.ARROW_RIGHT : kbd2.ARROW_LEFT,
    vertical: kbd2.ARROW_UP
  }[orientation];
};
var getDirectionalKeys = (dir = "ltr", orientation = "horizontal") => {
  return {
    nextKey: getNextKey(dir, orientation),
    prevKey: getPrevKey(dir, orientation)
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/debounce.js
function debounce(fn, wait = 500) {
  let timeout = null;
  return function(...args) {
    const later = () => {
      timeout = null;
      fn(...args);
    };
    timeout && clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/platform.js
var isDom = () => typeof window !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
var pt = (v) => isDom() && v.test(getPlatform().toLowerCase());
var isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
var isMac = () => pt(/^mac/) && !isTouchDevice();
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => isApple() && !isMac();

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/polygon/hull.js
function makeHull(points) {
  const newPoints = points.slice();
  newPoints.sort(POINT_COMPARATOR);
  return makeHullPresorted(newPoints);
}
function makeHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length == 1 && lowerHull.length == 1 && upperHull[0].x == lowerHull[0].x && upperHull[0].y == lowerHull[0].y)
    return upperHull;
  else
    return upperHull.concat(lowerHull);
}
function POINT_COMPARATOR(a, b) {
  if (a.x < b.x)
    return -1;
  else if (a.x > b.x)
    return 1;
  else if (a.y < b.y)
    return -1;
  else if (a.y > b.y)
    return 1;
  else
    return 0;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/polygon/index.js
function getPointsFromEl(el) {
  const rect = el.getBoundingClientRect();
  return [
    { x: rect.left, y: rect.top },
    { x: rect.right, y: rect.top },
    { x: rect.right, y: rect.bottom },
    { x: rect.left, y: rect.bottom }
  ];
}
function makeHullFromElements(els) {
  const points = els.flatMap((el) => getPointsFromEl(el));
  return makeHull(points);
}
function pointInPolygon(point, polygon) {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/scroll.js
var LOCK_CLASSNAME = "data-melt-scroll-lock";
function assignStyle(el, style) {
  if (!el)
    return;
  const previousStyle = el.style.cssText;
  Object.assign(el.style, style);
  return () => {
    el.style.cssText = previousStyle;
  };
}
function setCSSProperty(el, property, value) {
  if (!el)
    return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function removeScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked)
    return noop2;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const scrollbarSidePadding = win.getComputedStyle(body)[paddingProperty];
  const setStyle = () => assignStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = (visualViewport == null ? void 0 : visualViewport.offsetLeft) ?? 0;
    const offsetTop = (visualViewport == null ? void 0 : visualViewport.offsetTop) ?? 0;
    const restoreStyle = assignStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
    });
    return () => {
      restoreStyle == null ? void 0 : restoreStyle();
      win.scrollTo(scrollX, scrollY);
    };
  };
  const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()];
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/store/derivedVisible.js
function derivedVisible(obj) {
  const { open, forceVisible, activeTrigger } = obj;
  return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/store/derivedWithUnsubscribe.js
function derivedWithUnsubscribe(stores, fn) {
  let unsubscribers = [];
  const onUnsubscribe = (cb) => {
    unsubscribers.push(cb);
  };
  const unsubscribe = () => {
    unsubscribers.forEach((fn2) => fn2());
    unsubscribers = [];
  };
  const derivedStore = derived(stores, ($storeValues) => {
    unsubscribe();
    return fn($storeValues, onUnsubscribe);
  });
  onDestroy(unsubscribe);
  const subscribe2 = (...args) => {
    const unsub = derivedStore.subscribe(...args);
    return () => {
      unsub();
      unsubscribe();
    };
  };
  return {
    ...derivedStore,
    subscribe: subscribe2
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/store/effect.js
function effect(stores, fn) {
  const unsub = derivedWithUnsubscribe(stores, (stores2, onUnsubscribe) => {
    return {
      stores: stores2,
      onUnsubscribe
    };
  }).subscribe(({ stores: stores2, onUnsubscribe }) => {
    const returned = fn(stores2);
    if (returned) {
      onUnsubscribe(returned);
    }
  });
  onDestroy(unsub);
  return unsub;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/store/toWritableStores.js
function toWritableStores2(properties) {
  const result = {};
  Object.keys(properties).forEach((key) => {
    const propertyKey = key;
    const value = properties[propertyKey];
    result[propertyKey] = writable(value);
  });
  return result;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/rovingFocus.js
function handleRovingFocus(nextElement) {
  if (!isBrowser2)
    return;
  sleep(1).then(() => {
    const currentFocusedElement = document.activeElement;
    if (!isHTMLElement2(currentFocusedElement) || currentFocusedElement === nextElement)
      return;
    currentFocusedElement.tabIndex = -1;
    if (nextElement) {
      nextElement.tabIndex = 0;
      nextElement.focus();
    }
  });
}
function getFocusableElements() {
  return Array.from(document.querySelectorAll('a[href]:not([tabindex="-1"]), button:not([disabled]):not([tabindex="-1"]), input:not([disabled]):not([tabindex="-1"]), select:not([disabled]):not([tabindex="-1"]), textarea:not([disabled]):not([tabindex="-1"]), [tabindex]:not([tabindex="-1"])'));
}
function getNextFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const nextIndex = currentIndex + 1;
  const nextElement = focusableElements[nextIndex];
  if (nextIndex < focusableElements.length && isHTMLElement2(nextElement)) {
    return nextElement;
  }
  return null;
}
function getPreviousFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const previousIndex = currentIndex - 1;
  const prevElement = focusableElements[previousIndex];
  if (previousIndex >= 0 && isHTMLElement2(prevElement)) {
    return prevElement;
  }
  return null;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/typeahead.js
var defaults2 = {
  onMatch: handleRovingFocus,
  getCurrentItem: () => document.activeElement
};
function createTypeaheadSearch(args = {}) {
  const withDefaults = { ...defaults2, ...args };
  const typed = writable([]);
  const resetTyped = debounce(() => {
    typed.update(() => []);
  });
  const handleTypeaheadSearch = (key, items) => {
    const currentItem = withDefaults.getCurrentItem();
    const $typed = get_store_value(typed);
    if (!Array.isArray($typed)) {
      return;
    }
    $typed.push(key.toLowerCase());
    typed.set($typed);
    const candidateItems = items.filter((item) => {
      if (item.getAttribute("disabled") === "true" || item.getAttribute("aria-disabled") === "true" || item.hasAttribute("data-disabled")) {
        return false;
      }
      return true;
    });
    const isRepeated = $typed.length > 1 && $typed.every((char) => char === $typed[0]);
    const normalizeSearch = isRepeated ? $typed[0] : $typed.join("");
    const currentItemIndex = isHTMLElement2(currentItem) ? candidateItems.indexOf(currentItem) : -1;
    let wrappedItems = wrapArray(candidateItems, Math.max(currentItemIndex, 0));
    const excludeCurrentItem = normalizeSearch.length === 1;
    if (excludeCurrentItem) {
      wrappedItems = wrappedItems.filter((v) => v !== currentItem);
    }
    const nextItem = wrappedItems.find((item) => (item == null ? void 0 : item.innerText) && item.innerText.toLowerCase().startsWith(normalizeSearch.toLowerCase()));
    if (isHTMLElement2(nextItem) && nextItem !== currentItem) {
      withDefaults.onMatch(nextItem);
    }
    resetTyped();
  };
  return {
    typed,
    resetTyped,
    handleTypeaheadSearch
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/elements.js
function getPortalParent(node) {
  let parent = node.parentElement;
  while (isHTMLElement2(parent) && !parent.hasAttribute("data-portal")) {
    parent = parent.parentElement;
  }
  return parent || "body";
}
function getPortalDestination(node, portalProp) {
  const portalParent = getPortalParent(node);
  if (portalProp !== void 0)
    return portalProp;
  if (portalParent === "body")
    return document.body;
  return null;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/ignore.js
function createClickOutsideIgnore(meltId) {
  return (e) => {
    const target = e.target;
    const triggerEl = getElementByMeltId(meltId);
    if (!triggerEl || !isElement(target))
      return false;
    const id = triggerEl.id;
    if (isHTMLLabelElement(target) && id === target.htmlFor) {
      return true;
    }
    if (target.closest(`label[for="${id}"]`)) {
      return true;
    }
    return false;
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/focus.js
function handleFocus(args) {
  const { prop, defaultEl } = args;
  sleep(1).then(() => {
    if (prop === void 0) {
      defaultEl == null ? void 0 : defaultEl.focus();
      return;
    }
    const returned = isFunction(prop) ? prop(defaultEl) : prop;
    if (typeof returned === "string") {
      const el = document.querySelector(returned);
      if (!isHTMLElement2(el))
        return;
      el.focus();
    } else if (isHTMLElement2(returned)) {
      returned.focus();
    }
  });
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/helpers/math.js
function snapValueToStep(value, min, max, step) {
  const remainder = (value - (isNaN(min) ? 0 : min)) % step;
  let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;
  if (!isNaN(min)) {
    if (snappedValue < min) {
      snappedValue = min;
    } else if (!isNaN(max) && snappedValue > max) {
      snappedValue = min + Math.floor((max - min) / step) * step;
    }
  } else if (!isNaN(max) && snappedValue > max) {
    snappedValue = Math.floor(max / step) * step;
  }
  const string = step.toString();
  const index = string.indexOf(".");
  const precision = index >= 0 ? string.length - index : 0;
  if (precision > 0) {
    const pow = Math.pow(10, precision);
    snappedValue = Math.round(snappedValue * pow) / pow;
  }
  return snappedValue;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/accordion/create.js
var { name, selector } = createElHelpers("accordion");
var defaults3 = {
  multiple: false,
  disabled: false,
  forceVisible: false
};
var createAccordion = (props) => {
  const withDefaults = { ...defaults3, ...props };
  const options = toWritableStores2(omit2(withDefaults, "value", "onValueChange", "defaultValue"));
  const meltIds = generateIds(["root"]);
  const { disabled, forceVisible } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const isSelected = (key, v) => {
    if (v === void 0)
      return false;
    if (typeof v === "string")
      return v === key;
    return v.includes(key);
  };
  const isSelectedStore = derived(value, ($value) => {
    return (key) => isSelected(key, $value);
  });
  const root = builder(name(), {
    returned: () => ({
      "data-melt-id": meltIds.root
    })
  });
  const parseItemProps = (props2) => {
    if (typeof props2 === "string") {
      return { value: props2 };
    } else {
      return props2;
    }
  };
  const parseHeadingProps = (props2) => {
    if (typeof props2 === "number") {
      return { level: props2 };
    } else {
      return props2;
    }
  };
  const item = builder(name("item"), {
    stores: value,
    returned: ($value) => {
      return (props2) => {
        const { value: itemValue, disabled: disabled2 } = parseItemProps(props2);
        return {
          "data-state": isSelected(itemValue, $value) ? "open" : "closed",
          "data-disabled": disabledAttr(disabled2)
        };
      };
    }
  });
  const trigger = builder(name("trigger"), {
    stores: [value, disabled],
    returned: ([$value, $disabled]) => {
      return (props2) => {
        const { value: itemValue, disabled: disabled2 } = parseItemProps(props2);
        return {
          disabled: disabledAttr($disabled || disabled2),
          "aria-expanded": isSelected(itemValue, $value) ? true : false,
          "aria-disabled": disabled2 ? true : false,
          "data-disabled": disabledAttr(disabled2),
          "data-value": itemValue,
          "data-state": isSelected(itemValue, $value) ? "open" : "closed"
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks2(addMeltEventListener(node, "click", () => {
        const disabled2 = node.dataset.disabled === "true";
        const itemValue = node.dataset.value;
        if (disabled2 || !itemValue)
          return;
        handleValueUpdate(itemValue);
      }), addMeltEventListener(node, "keydown", (e) => {
        if (![kbd2.ARROW_DOWN, kbd2.ARROW_UP, kbd2.HOME, kbd2.END].includes(e.key)) {
          return;
        }
        e.preventDefault();
        if (e.key === kbd2.SPACE || e.key === kbd2.ENTER) {
          const disabled2 = node.dataset.disabled === "true";
          const itemValue = node.dataset.value;
          if (disabled2 || !itemValue)
            return;
          handleValueUpdate(itemValue);
          return;
        }
        const el = e.target;
        const rootEl = getElementByMeltId(meltIds.root);
        if (!rootEl || !isHTMLElement2(el))
          return;
        const items = Array.from(rootEl.querySelectorAll(selector("trigger")));
        const candidateItems = items.filter((item2) => {
          if (!isHTMLElement2(item2))
            return false;
          return item2.dataset.disabled !== "true";
        });
        if (!candidateItems.length)
          return;
        const elIdx = candidateItems.indexOf(el);
        if (e.key === kbd2.ARROW_DOWN) {
          candidateItems[(elIdx + 1) % candidateItems.length].focus();
        }
        if (e.key === kbd2.ARROW_UP) {
          candidateItems[(elIdx - 1 + candidateItems.length) % candidateItems.length].focus();
        }
        if (e.key === kbd2.HOME) {
          candidateItems[0].focus();
        }
        if (e.key === kbd2.END) {
          candidateItems[candidateItems.length - 1].focus();
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const content = builder(name("content"), {
    stores: [value, disabled, forceVisible],
    returned: ([$value, $disabled, $forceVisible]) => {
      return (props2) => {
        const { value: itemValue } = parseItemProps(props2);
        const isVisible = isSelected(itemValue, $value) || $forceVisible;
        return {
          "data-state": isVisible ? "open" : "closed",
          "data-disabled": disabledAttr($disabled),
          "data-value": itemValue,
          hidden: isVisible ? void 0 : true,
          style: styleToString2({
            display: isVisible ? void 0 : "none"
          })
        };
      };
    },
    action: (node) => {
      tick().then(() => {
        const contentId = generateId2();
        const triggerId = generateId2();
        const parentTrigger = document.querySelector(`${selector("trigger")}, [data-value="${node.dataset.value}"]`);
        if (!isHTMLElement2(parentTrigger))
          return;
        node.id = contentId;
        parentTrigger.setAttribute("aria-controls", contentId);
        parentTrigger.id = triggerId;
      });
    }
  });
  const heading = builder(name("heading"), {
    returned: () => {
      return (props2) => {
        const { level } = parseHeadingProps(props2);
        return {
          role: "heading",
          "aria-level": level,
          "data-heading-level": level
        };
      };
    }
  });
  function handleValueUpdate(itemValue) {
    value.update(($value) => {
      if ($value === void 0) {
        return withDefaults.multiple ? [itemValue] : itemValue;
      }
      if (Array.isArray($value)) {
        if ($value.includes(itemValue)) {
          return $value.filter((v) => v !== itemValue);
        }
        $value.push(itemValue);
        return $value;
      }
      return $value === itemValue ? void 0 : itemValue;
    });
  }
  return {
    ids: meltIds,
    elements: {
      root,
      item,
      trigger,
      content,
      heading
    },
    states: {
      value
    },
    helpers: {
      isSelected: isSelectedStore
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/avatar/create.js
var defaults4 = {
  src: "",
  delayMs: 0,
  onLoadingStatusChange: void 0
};
var createAvatar = (props) => {
  const withDefaults = { ...defaults4, ...props };
  const options = toWritableStores2(omit2(withDefaults, "loadingStatus", "onLoadingStatusChange"));
  const { src, delayMs } = options;
  const loadingStatusWritable = withDefaults.loadingStatus ?? writable("loading");
  const loadingStatus = overridable(loadingStatusWritable, withDefaults == null ? void 0 : withDefaults.onLoadingStatusChange);
  effect([src, delayMs], ([$src, $delayMs]) => {
    if (isBrowser2) {
      const image2 = new Image();
      image2.src = $src;
      image2.onload = () => {
        if (delayMs !== void 0) {
          const timerId = window.setTimeout(() => {
            loadingStatus.set("loaded");
          }, $delayMs);
          return () => window.clearTimeout(timerId);
        } else {
          loadingStatus.set("loaded");
        }
      };
      image2.onerror = () => {
        loadingStatus.set("error");
      };
    }
  });
  const image = builder("avatar-image", {
    stores: [src, loadingStatus],
    returned: ([$src, $loadingStatus]) => {
      const imageStyles = styleToString2({
        display: $loadingStatus === "loaded" ? "block" : "none"
      });
      return {
        src: $src,
        style: imageStyles
      };
    }
  });
  const fallback = builder("avatar-fallback", {
    stores: [loadingStatus],
    returned: ([$loadingStatus]) => {
      return {
        style: $loadingStatus === "loaded" ? styleToString2({
          display: "none"
        }) : void 0,
        hidden: $loadingStatus === "loaded" ? true : void 0
      };
    }
  });
  return {
    elements: {
      image,
      fallback
    },
    states: {
      loadingStatus
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/checkbox/create.js
var defaults5 = {
  disabled: false,
  required: false,
  name: void 0,
  value: "on",
  defaultChecked: false
};
function createCheckbox(props) {
  const withDefaults = { ...defaults5, ...props };
  const options = toWritableStores2(omit2(withDefaults, "checked", "defaultChecked"));
  const { disabled, name: name27, required, value } = options;
  const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked);
  const checked = overridable(checkedWritable, withDefaults == null ? void 0 : withDefaults.onCheckedChange);
  const root = builder("checkbox", {
    stores: [checked, disabled, required],
    returned: ([$checked, $disabled, $required]) => {
      return {
        "data-disabled": disabledAttr($disabled),
        "data-state": $checked === "indeterminate" ? "indeterminate" : $checked ? "checked" : "unchecked",
        type: "button",
        role: "checkbox",
        "aria-checked": $checked === "indeterminate" ? "mixed" : $checked,
        "aria-required": $required
      };
    },
    action: (node) => {
      const unsub = executeCallbacks2(addMeltEventListener(node, "keydown", (e) => {
        if (e.key === kbd2.ENTER)
          e.preventDefault();
      }), addMeltEventListener(node, "click", () => {
        if (get_store_value(disabled))
          return;
        checked.update((value2) => {
          if (value2 === "indeterminate")
            return true;
          return !value2;
        });
      }));
      return {
        destroy: unsub
      };
    }
  });
  const input = builder("checkbox-input", {
    stores: [checked, name27, value, required, disabled],
    returned: ([$checked, $name, $value, $required, $disabled]) => {
      return {
        type: "checkbox",
        "aria-hidden": true,
        hidden: true,
        tabindex: -1,
        name: $name,
        value: $value,
        checked: $checked === "indeterminate" ? false : $checked,
        required: $required,
        disabled: disabledAttr($disabled),
        style: styleToString2({
          position: "absolute",
          opacity: 0,
          "pointer-events": "none",
          margin: 0,
          transform: "translateX(-100%)"
        })
      };
    }
  });
  const isIndeterminate = derived(checked, ($checked) => $checked === "indeterminate");
  const isChecked = derived(checked, ($checked) => $checked === true);
  return {
    elements: {
      root,
      input
    },
    states: {
      checked
    },
    helpers: {
      isIndeterminate,
      isChecked
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/collapsible/create.js
var defaults6 = {
  defaultOpen: false,
  disabled: false,
  forceVisible: false
};
var { name: name2 } = createElHelpers("collapsible");
function createCollapsible(props) {
  const withDefaults = { ...defaults6, ...props };
  const options = toWritableStores2(omit2(withDefaults, "open", "defaultOpen", "onOpenChange"));
  const { disabled, forceVisible } = options;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const root = builder(name2(), {
    stores: [open, disabled],
    returned: ([$open, $disabled]) => ({
      "data-state": $open ? "open" : "closed",
      "data-disabled": disabledAttr($disabled)
    })
  });
  const trigger = builder(name2("trigger"), {
    stores: [open, disabled],
    returned: ([$open, $disabled]) => ({
      "data-state": $open ? "open" : "closed",
      "data-disabled": disabledAttr($disabled),
      disabled: disabledAttr($disabled)
    }),
    action: (node) => {
      const unsub = addMeltEventListener(node, "click", () => {
        const disabled2 = node.dataset.disabled !== void 0;
        if (disabled2)
          return;
        open.update(($open) => !$open);
      });
      return {
        destroy: unsub
      };
    }
  });
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => $open || $forceVisible);
  const content = builder(name2("content"), {
    stores: [isVisible, disabled],
    returned: ([$isVisible, $disabled]) => ({
      "data-state": $isVisible ? "open" : "closed",
      "data-disabled": disabledAttr($disabled),
      hidden: $isVisible ? void 0 : true,
      style: styleToString2({
        display: $isVisible ? void 0 : "none"
      })
    })
  });
  return {
    elements: {
      root,
      trigger,
      content
    },
    states: {
      open
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/actions/click-outside/action.js
var documentClickStore = readable(void 0, (set) => {
  function clicked(event) {
    set(event);
    set(void 0);
  }
  const unsubscribe = addEventListener2(document, "pointerup", clicked, {
    passive: false,
    capture: true
  });
  return unsubscribe;
});
var useClickOutside = (node, config = {}) => {
  let options = { enabled: true, ...config };
  function isEnabled() {
    return typeof options.enabled === "boolean" ? options.enabled : get_store_value(options.enabled);
  }
  const unsubscribe = documentClickStore.subscribe((e) => {
    var _a;
    if (!isEnabled() || !e || e.target === node) {
      return;
    }
    const composedPath = e.composedPath();
    if (composedPath.includes(node))
      return;
    if (options.ignore) {
      if (isFunction(options.ignore)) {
        if (options.ignore(e))
          return;
      } else if (Array.isArray(options.ignore)) {
        if (options.ignore.length > 0 && options.ignore.some((ignoreEl) => {
          return ignoreEl && (e.target === ignoreEl || composedPath.includes(ignoreEl));
        }))
          return;
      }
    }
    (_a = options.handler) == null ? void 0 : _a.call(options, e);
  });
  return {
    update(params) {
      options = { ...options, ...params };
    },
    destroy() {
      unsubscribe();
    }
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/actions/escape-keydown/action.js
var documentEscapeKeyStore = readable(void 0, (set) => {
  function keydown(event) {
    if (event && event.key === kbd2.ESCAPE) {
      set(event);
    }
    set(void 0);
  }
  const unsubscribe = addEventListener2(document, "keydown", keydown, {
    passive: false,
    capture: true
  });
  return unsubscribe;
});
var useEscapeKeydown = (node, config = {}) => {
  node.dataset.escapee = "";
  let options = { enabled: true, ...config };
  function isEnabled() {
    return typeof options.enabled === "boolean" ? options.enabled : get_store_value(options.enabled);
  }
  const unsubscribe = documentEscapeKeyStore.subscribe((e) => {
    var _a;
    if (!e || !isEnabled())
      return;
    const target = e.target;
    if (!isHTMLElement2(target) || target.closest("[data-escapee]") !== node) {
      return;
    }
    e.preventDefault();
    if (options.ignore) {
      if (isFunction(options.ignore)) {
        if (options.ignore(e))
          return;
      } else if (Array.isArray(options.ignore)) {
        if (options.ignore.length > 0 && options.ignore.some((ignoreEl) => {
          return ignoreEl && target === ignoreEl;
        }))
          return;
      }
    }
    (_a = options.handler) == null ? void 0 : _a.call(options, e);
  });
  return {
    update(params) {
      options = { ...options, ...params };
    },
    destroy() {
      node.removeAttribute("data-escapee");
      unsubscribe();
    }
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/actions/floating/action.js
var defaultConfig = {
  strategy: "absolute",
  placement: "top",
  gutter: 5,
  flip: true,
  sameWidth: false,
  overflowPadding: 8
};
var ARROW_TRANSFORM = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function useFloating(reference, floating, opts = {}) {
  if (!floating || !reference || opts === null)
    return {
      destroy: noop2
    };
  const options = { ...defaultConfig, ...opts };
  const arrowEl = floating.querySelector("[data-arrow=true]");
  const middleware = [];
  if (options.flip) {
    middleware.push(flip({
      boundary: options.boundary,
      padding: options.overflowPadding
    }));
  }
  const arrowOffset = isHTMLElement2(arrowEl) ? arrowEl.offsetHeight / 2 : 0;
  if (options.gutter || options.offset) {
    const data = options.gutter ? { mainAxis: options.gutter } : options.offset;
    if ((data == null ? void 0 : data.mainAxis) != null) {
      data.mainAxis += arrowOffset;
    }
    middleware.push(offset(data));
  }
  middleware.push(shift({
    boundary: options.boundary,
    crossAxis: options.overlap,
    padding: options.overflowPadding
  }));
  if (arrowEl) {
    middleware.push(arrow({ element: arrowEl, padding: 8 }));
  }
  middleware.push(size({
    padding: options.overflowPadding,
    apply({ rects, availableHeight, availableWidth }) {
      if (options.sameWidth) {
        Object.assign(floating.style, {
          width: `${Math.round(rects.reference.width)}px`,
          minWidth: "unset"
        });
      }
      if (options.fitViewport) {
        Object.assign(floating.style, {
          maxWidth: `${availableWidth}px`,
          maxHeight: `${availableHeight}px`
        });
      }
    }
  }));
  function compute() {
    if (!reference || !floating)
      return;
    const { placement, strategy } = options;
    computePosition(reference, floating, {
      placement,
      middleware,
      strategy
    }).then((data) => {
      const x = Math.round(data.x);
      const y = Math.round(data.y);
      Object.assign(floating.style, {
        position: options.strategy,
        top: `${y}px`,
        left: `${x}px`
      });
      if (isHTMLElement2(arrowEl) && data.middlewareData.arrow) {
        const { x: x2, y: y2 } = data.middlewareData.arrow;
        const dir = data.placement.split("-")[0];
        Object.assign(arrowEl.style, {
          position: "absolute",
          left: x2 != null ? `${x2}px` : "",
          top: y2 != null ? `${y2}px` : "",
          [dir]: `calc(100% - ${arrowOffset}px)`,
          transform: ARROW_TRANSFORM[dir],
          backgroundColor: "inherit",
          zIndex: "inherit"
        });
      }
      return data;
    });
  }
  Object.assign(floating.style, {
    position: options.strategy
  });
  return {
    destroy: autoUpdate(reference, floating, compute)
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/actions/focus-trap/action.js
function createFocusTrap2(config = {}) {
  let trap;
  const { immediate, ...focusTrapOptions } = config;
  const hasFocus = writable(false);
  const isPaused = writable(false);
  const activate = (opts) => trap == null ? void 0 : trap.activate(opts);
  const deactivate = (opts) => {
    trap == null ? void 0 : trap.deactivate(opts);
  };
  const pause = () => {
    if (trap) {
      trap.pause();
      isPaused.set(true);
    }
  };
  const unpause = () => {
    if (trap) {
      trap.unpause();
      isPaused.set(false);
    }
  };
  const useFocusTrap = (node) => {
    trap = createFocusTrap(node, {
      ...focusTrapOptions,
      onActivate() {
        var _a;
        hasFocus.set(true);
        (_a = config.onActivate) == null ? void 0 : _a.call(config);
      },
      onDeactivate() {
        var _a;
        hasFocus.set(false);
        (_a = config.onDeactivate) == null ? void 0 : _a.call(config);
      }
    });
    if (immediate) {
      activate();
    }
    return {
      destroy() {
        deactivate();
        trap = void 0;
      }
    };
  };
  return {
    useFocusTrap,
    hasFocus: readonly(hasFocus),
    isPaused: readonly(isPaused),
    activate,
    deactivate,
    pause,
    unpause
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/actions/melt/index.js
function melt(node, params) {
  throw new Error("[MELTUI ERROR]: The `use:melt` action cannot be used without MeltUI's Preprocessor. See: https://www.melt-ui.com/docs/preprocessor");
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/actions/popper/action.js
var defaultConfig2 = {
  floating: {},
  focusTrap: {},
  clickOutside: {},
  escapeKeydown: {},
  portal: "body"
};
var usePopper = (popperElement, args) => {
  popperElement.dataset.escapee = "";
  const { anchorElement, open, options } = args;
  if (!anchorElement || !open || !options) {
    return { destroy: noop2 };
  }
  const opts = { ...defaultConfig2, ...options };
  const callbacks = [];
  if (opts.portal !== null) {
    const portal = usePortal(popperElement, opts.portal);
    if (portal == null ? void 0 : portal.destroy) {
      callbacks.push(portal.destroy);
    }
  }
  callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);
  if (opts.focusTrap !== null) {
    const { useFocusTrap } = createFocusTrap2({
      immediate: true,
      escapeDeactivates: false,
      allowOutsideClick: true,
      returnFocusOnDeactivate: false,
      fallbackFocus: popperElement,
      ...opts.focusTrap
    });
    const usedFocusTrap = useFocusTrap(popperElement);
    if (usedFocusTrap == null ? void 0 : usedFocusTrap.destroy) {
      callbacks.push(usedFocusTrap.destroy);
    }
  }
  if (opts.clickOutside !== null) {
    callbacks.push(useClickOutside(popperElement, {
      enabled: open,
      handler: (e) => {
        if (e.defaultPrevented)
          return;
        if (isHTMLElement2(anchorElement) && !anchorElement.contains(e.target)) {
          open.set(false);
          anchorElement.focus();
        }
      },
      ...opts.clickOutside
    }).destroy);
  }
  if (opts.escapeKeydown !== null) {
    callbacks.push(useEscapeKeydown(popperElement, {
      enabled: open,
      handler: () => {
        open.set(false);
      },
      ...opts.escapeKeydown
    }).destroy);
  }
  const unsubscribe = executeCallbacks2(...callbacks);
  return {
    destroy() {
      unsubscribe();
    }
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/internal/actions/portal.js
var usePortal = (el, target = "body") => {
  let targetEl;
  if (!isHTMLElement2(target) && typeof target !== "string") {
    return {
      destroy: noop2
    };
  }
  async function update(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetEl = document.querySelector(target);
      if (targetEl === null) {
        await tick();
        targetEl = document.querySelector(target);
      }
      if (targetEl === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetEl = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    el.dataset.portal = "";
    targetEl.appendChild(el);
    el.hidden = false;
  }
  function destroy() {
    el.remove();
  }
  update(target);
  return {
    update,
    destroy
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/label/create.js
function createLabel() {
  const root = builder("label", {
    action: (node) => {
      const mouseDown = addMeltEventListener(node, "mousedown", (e) => {
        if (!e.defaultPrevented && e.detail > 1) {
          e.preventDefault();
        }
      });
      return {
        destroy: mouseDown
      };
    }
  });
  return {
    elements: {
      root
    }
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/listbox/create.js
var INTERACTION_KEYS = [kbd2.ARROW_LEFT, kbd2.ESCAPE, kbd2.ARROW_RIGHT, kbd2.SHIFT, kbd2.CAPS_LOCK, kbd2.CONTROL, kbd2.ALT, kbd2.META, kbd2.ENTER, kbd2.F1, kbd2.F2, kbd2.F3, kbd2.F4, kbd2.F5, kbd2.F6, kbd2.F7, kbd2.F8, kbd2.F9, kbd2.F10, kbd2.F11, kbd2.F12];
var defaults7 = {
  positioning: {
    placement: "bottom",
    sameWidth: true
  },
  scrollAlignment: "nearest",
  loop: true,
  defaultOpen: false,
  closeOnOutsideClick: true,
  preventScroll: true,
  closeOnEscape: true,
  forceVisible: false,
  portal: void 0,
  builder: "listbox",
  disabled: false,
  required: false,
  name: void 0,
  typeahead: true,
  highlightOnHover: true
};
var listboxIdParts = ["trigger", "menu", "label"];
function createListbox(props) {
  const withDefaults = { ...defaults7, ...props };
  const activeTrigger = writable(null);
  const highlightedItem = writable(null);
  const selectedWritable = withDefaults.selected ?? writable(withDefaults.defaultSelected);
  const selected = overridable(selectedWritable, withDefaults == null ? void 0 : withDefaults.onSelectedChange);
  const highlighted = derived(highlightedItem, ($highlightedItem) => $highlightedItem ? getOptionProps($highlightedItem) : void 0);
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const options = toWritableStores2({
    ...omit2(withDefaults, "open", "defaultOpen", "builder", "ids"),
    multiple: withDefaults.multiple ?? false
  });
  const { scrollAlignment, loop, closeOnOutsideClick, closeOnEscape, preventScroll, portal, forceVisible, positioning, multiple, arrowSize, disabled, required, typeahead, name: nameProp, highlightOnHover } = options;
  const { name: name27, selector: selector10 } = createElHelpers(withDefaults.builder);
  const ids = toWritableStores2({ ...generateIds(listboxIdParts), ...withDefaults.ids });
  const { handleTypeaheadSearch } = createTypeaheadSearch({
    onMatch: (element2) => {
      highlightedItem.set(element2);
      element2.scrollIntoView({ block: get_store_value(scrollAlignment) });
    },
    getCurrentItem() {
      return get_store_value(highlightedItem);
    }
  });
  function getOptionProps(el) {
    const value = el.getAttribute("data-value");
    const label2 = el.getAttribute("data-label");
    const disabled2 = el.hasAttribute("data-disabled");
    return {
      value: value ? JSON.parse(value) : value,
      label: label2 ?? el.textContent ?? void 0,
      disabled: disabled2 ? true : false
    };
  }
  const setOption = (newOption) => {
    selected.update(($option) => {
      const $multiple = get_store_value(multiple);
      if ($multiple) {
        const optionArr = Array.isArray($option) ? $option : [];
        return toggle(newOption, optionArr, (itemA, itemB) => dequal(itemA.value, itemB.value));
      }
      return newOption;
    });
  };
  function selectItem(item) {
    const props2 = getOptionProps(item);
    setOption(props2);
  }
  async function openMenu() {
    open.set(true);
    const triggerEl = document.getElementById(get_store_value(ids.trigger));
    if (!triggerEl)
      return;
    activeTrigger.set(triggerEl);
    await tick();
    const menuElement = document.getElementById(get_store_value(ids.menu));
    if (!isHTMLElement2(menuElement))
      return;
    const selectedItem = menuElement.querySelector("[aria-selected=true]");
    if (!isHTMLElement2(selectedItem))
      return;
    highlightedItem.set(selectedItem);
  }
  function closeMenu() {
    open.set(false);
    highlightedItem.set(null);
  }
  const isVisible = derivedVisible({ open, forceVisible, activeTrigger });
  const isSelected = derived([selected], ([$selected]) => {
    return (value) => {
      if (Array.isArray($selected)) {
        return $selected.some((o) => dequal(o.value, value));
      }
      return dequal($selected == null ? void 0 : $selected.value, value);
    };
  });
  const isHighlighted = derived([highlighted], ([$value]) => {
    return (item) => {
      return dequal($value == null ? void 0 : $value.value, item);
    };
  });
  const trigger = builder(name27("trigger"), {
    stores: [open, highlightedItem, disabled, ids.menu, ids.trigger, ids.label],
    returned: ([$open, $highlightedItem, $disabled, $menuId, $triggerId, $labelId]) => {
      return {
        "aria-activedescendant": $highlightedItem == null ? void 0 : $highlightedItem.id,
        "aria-autocomplete": "list",
        "aria-controls": $menuId,
        "aria-expanded": $open,
        "aria-labelledby": $labelId,
        // autocomplete: 'off',
        id: $triggerId,
        role: "combobox",
        disabled: disabledAttr($disabled)
      };
    },
    action: (node) => {
      const isInput = isHTMLInputElement2(node);
      const unsubscribe = executeCallbacks2(
        addMeltEventListener(node, "click", () => {
          node.focus();
          const $open = get_store_value(open);
          if ($open) {
            closeMenu();
          } else {
            openMenu();
          }
        }),
        // Handle all input key events including typing, meta, and navigation.
        addMeltEventListener(node, "keydown", (e) => {
          const $open = get_store_value(open);
          if (!$open) {
            if (INTERACTION_KEYS.includes(e.key)) {
              return;
            }
            if (e.key === kbd2.TAB) {
              return;
            }
            if (e.key === kbd2.BACKSPACE && isInput && node.value === "") {
              return;
            }
            if (e.key === kbd2.SPACE && isHTMLButtonElement(node)) {
              return;
            }
            openMenu();
            tick().then(() => {
              const $selectedItem = get_store_value(selected);
              if ($selectedItem)
                return;
              const menuEl = document.getElementById(get_store_value(ids.menu));
              if (!isHTMLElement2(menuEl))
                return;
              const enabledItems = Array.from(menuEl.querySelectorAll(`${selector10("item")}:not([data-disabled]):not([data-hidden])`)).filter((item) => isHTMLElement2(item));
              if (!enabledItems.length)
                return;
              if (e.key === kbd2.ARROW_DOWN) {
                highlightedItem.set(enabledItems[0]);
                enabledItems[0].scrollIntoView({ block: get_store_value(scrollAlignment) });
              } else if (e.key === kbd2.ARROW_UP) {
                highlightedItem.set(last(enabledItems));
                last(enabledItems).scrollIntoView({ block: get_store_value(scrollAlignment) });
              }
            });
          }
          if (e.key === kbd2.TAB || e.key === kbd2.ESCAPE && get_store_value(closeOnEscape)) {
            closeMenu();
            return;
          }
          if (e.key === kbd2.ENTER || e.key === kbd2.SPACE && isHTMLButtonElement(node)) {
            e.preventDefault();
            const $highlightedItem = get_store_value(highlightedItem);
            if ($highlightedItem) {
              selectItem($highlightedItem);
            }
            if (!get_store_value(multiple)) {
              closeMenu();
            }
          }
          if (e.key === kbd2.ARROW_UP && e.altKey) {
            closeMenu();
          }
          if (FIRST_LAST_KEYS.includes(e.key)) {
            e.preventDefault();
            const menuElement = document.getElementById(get_store_value(ids.menu));
            if (!isHTMLElement2(menuElement))
              return;
            const itemElements = getOptions(menuElement);
            if (!itemElements.length)
              return;
            const candidateNodes = itemElements.filter((opt) => !isElementDisabled(opt) && opt.dataset.hidden === void 0);
            const $currentItem = get_store_value(highlightedItem);
            const currentIndex = $currentItem ? candidateNodes.indexOf($currentItem) : -1;
            const $loop = get_store_value(loop);
            const $scrollAlignment = get_store_value(scrollAlignment);
            let nextItem;
            switch (e.key) {
              case kbd2.ARROW_DOWN:
                nextItem = next(candidateNodes, currentIndex, $loop);
                break;
              case kbd2.ARROW_UP:
                nextItem = prev(candidateNodes, currentIndex, $loop);
                break;
              case kbd2.PAGE_DOWN:
                nextItem = forward(candidateNodes, currentIndex, 10, $loop);
                break;
              case kbd2.PAGE_UP:
                nextItem = back(candidateNodes, currentIndex, 10, $loop);
                break;
              case kbd2.HOME:
                nextItem = candidateNodes[0];
                break;
              case kbd2.END:
                nextItem = last(candidateNodes);
                break;
              default:
                return;
            }
            highlightedItem.set(nextItem);
            nextItem == null ? void 0 : nextItem.scrollIntoView({ block: $scrollAlignment });
          } else if (get_store_value(typeahead)) {
            const menuEl = document.getElementById(get_store_value(ids.menu));
            if (!isHTMLElement2(menuEl))
              return;
            handleTypeaheadSearch(e.key, getOptions(menuEl));
          }
        })
      );
      let unsubEscapeKeydown = noop2;
      const escape = useEscapeKeydown(node, {
        handler: () => {
          if (get_store_value(closeOnEscape)) {
            closeMenu();
          }
        }
      });
      if (escape && escape.destroy) {
        unsubEscapeKeydown = escape.destroy;
      }
      return {
        destroy() {
          unsubscribe();
          unsubEscapeKeydown();
        }
      };
    }
  });
  const menu = builder(name27("menu"), {
    stores: [isVisible, ids.menu],
    returned: ([$isVisible, $menuId]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        id: $menuId,
        role: "listbox",
        style: styleToString2({ display: $isVisible ? void 0 : "none" })
      };
    },
    action: (node) => {
      let unsubPopper = noop2;
      let unsubScroll = noop2;
      const unsubscribe = executeCallbacks2(
        // Bind the popper portal to the input element.
        effect([
          isVisible,
          preventScroll,
          closeOnEscape,
          portal,
          closeOnOutsideClick,
          positioning,
          activeTrigger
        ], ([$isVisible, $preventScroll, $closeOnEscape, $portal, $closeOnOutsideClick, $positioning, $activeTrigger]) => {
          unsubPopper();
          unsubScroll();
          if (!$isVisible || !$activeTrigger)
            return;
          if ($preventScroll) {
            unsubScroll = removeScroll();
          }
          const ignoreHandler = createClickOutsideIgnore(get_store_value(ids.trigger));
          const popper = usePopper(node, {
            anchorElement: $activeTrigger,
            open,
            options: {
              floating: $positioning,
              focusTrap: null,
              clickOutside: $closeOnOutsideClick ? {
                handler: (e) => {
                  const target = e.target;
                  if (!isElement(target))
                    return;
                  if (target === $activeTrigger || $activeTrigger.contains(target)) {
                    return;
                  }
                  closeMenu();
                },
                ignore: ignoreHandler
              } : null,
              escapeKeydown: $closeOnEscape ? {
                handler: () => {
                  closeMenu();
                }
              } : null,
              portal: getPortalDestination(node, $portal)
            }
          });
          if (popper && popper.destroy) {
            unsubPopper = popper.destroy;
          }
        })
      );
      return {
        destroy: () => {
          unsubscribe();
          unsubPopper();
          unsubScroll();
        }
      };
    }
  });
  const { elements: { root: labelBuilder } } = createLabel();
  const { action: labelAction } = get_store_value(labelBuilder);
  const label = builder(name27("label"), {
    stores: [ids.label, ids.trigger],
    returned: ([$labelId, $triggerId]) => {
      return {
        id: $labelId,
        for: $triggerId
      };
    },
    action: labelAction
  });
  const option = builder(name27("option"), {
    stores: [selected],
    returned: ([$selected]) => (props2) => {
      const selected2 = Array.isArray($selected) ? $selected.some((o) => dequal(o.value, props2.value)) : dequal($selected == null ? void 0 : $selected.value, props2.value);
      return {
        "data-value": JSON.stringify(props2.value),
        "data-label": props2.label,
        "data-disabled": disabledAttr(props2.disabled),
        "aria-disabled": props2.disabled ? true : void 0,
        "aria-selected": selected2,
        "data-selected": selected2 ? "" : void 0,
        id: generateId2(),
        role: "option"
      };
    },
    action: (node) => {
      const unsubscribe = executeCallbacks2(addMeltEventListener(node, "click", (e) => {
        if (isElementDisabled(node)) {
          e.preventDefault();
          return;
        }
        selectItem(node);
        if (!get_store_value(multiple)) {
          closeMenu();
        }
      }), effect(highlightOnHover, ($highlightOnHover) => {
        if (!$highlightOnHover)
          return;
        const unsub = executeCallbacks2(addMeltEventListener(node, "mouseover", () => {
          highlightedItem.set(node);
        }), addMeltEventListener(node, "mouseleave", () => {
          highlightedItem.set(null);
        }));
        return unsub;
      }));
      return { destroy: unsubscribe };
    }
  });
  const hiddenInput = builder(name27("hidden-input"), {
    stores: [selected, required, nameProp],
    returned: ([$selected, $required, $name]) => {
      const value = Array.isArray($selected) ? $selected.map((o) => o.value) : $selected == null ? void 0 : $selected.value;
      return {
        ...hiddenInputAttrs,
        required: $required ? true : void 0,
        value,
        name: $name
      };
    }
  });
  const arrow2 = builder(name27("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString2({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  onMount(() => {
    if (!isBrowser2)
      return;
    const menuEl = document.getElementById(get_store_value(ids.menu));
    if (!menuEl)
      return;
    const triggerEl = document.getElementById(get_store_value(ids.trigger));
    if (triggerEl) {
      activeTrigger.set(triggerEl);
    }
    const selectedEl = menuEl.querySelector("[data-selected]");
    if (!isHTMLElement2(selectedEl))
      return;
  });
  effect([highlightedItem], ([$highlightedItem]) => {
    if (!isBrowser2)
      return;
    const menuElement = document.getElementById(get_store_value(ids.menu));
    if (!isHTMLElement2(menuElement))
      return;
    getOptions(menuElement).forEach((node) => {
      if (node === $highlightedItem) {
        addHighlight(node);
      } else {
        removeHighlight(node);
      }
    });
  });
  return {
    ids,
    elements: {
      trigger,
      option,
      menu,
      label,
      hiddenInput,
      arrow: arrow2
    },
    states: {
      open,
      selected,
      highlighted,
      highlightedItem
    },
    helpers: {
      isSelected,
      isHighlighted,
      closeMenu
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/combobox/create.js
var INTERACTION_KEYS2 = [kbd2.ARROW_LEFT, kbd2.ESCAPE, kbd2.ARROW_RIGHT, kbd2.SHIFT, kbd2.CAPS_LOCK, kbd2.CONTROL, kbd2.ALT, kbd2.META, kbd2.ENTER, kbd2.F1, kbd2.F2, kbd2.F3, kbd2.F4, kbd2.F5, kbd2.F6, kbd2.F7, kbd2.F8, kbd2.F9, kbd2.F10, kbd2.F11, kbd2.F12];
var { name: name3 } = createElHelpers("combobox");

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/menu/create.js
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, kbd2.ARROW_RIGHT],
  rtl: [...SELECTION_KEYS, kbd2.ARROW_LEFT]
};
var SUB_CLOSE_KEYS = {
  ltr: [kbd2.ARROW_LEFT],
  rtl: [kbd2.ARROW_RIGHT]
};
var menuIdParts = ["menu", "trigger"];
var defaults8 = {
  arrowSize: 8,
  positioning: {
    placement: "bottom"
  },
  preventScroll: true,
  closeOnEscape: true,
  closeOnOutsideClick: true,
  portal: "body",
  loop: false,
  dir: "ltr",
  defaultOpen: false,
  typeahead: true
};
function createMenuBuilder(opts) {
  const { name: name27, selector: selector10 } = createElHelpers(opts.selector);
  const { preventScroll, arrowSize, positioning, closeOnEscape, closeOnOutsideClick, portal, forceVisible, typeahead, loop, closeFocus, disableFocusFirstItem } = opts.rootOptions;
  const rootOpen = opts.rootOpen;
  const rootActiveTrigger = opts.rootActiveTrigger;
  const nextFocusable = opts.nextFocusable;
  const prevFocusable = opts.prevFocusable;
  const isUsingKeyboard = writable(false);
  const lastPointerX = writable(0);
  const pointerGraceIntent = writable(null);
  const pointerDir = writable("right");
  const currentFocusedItem = writable(null);
  const pointerMovingToSubmenu = derivedWithUnsubscribe([pointerDir, pointerGraceIntent], ([$pointerDir, $pointerGraceIntent]) => {
    return (e) => {
      const isMovingTowards = $pointerDir === ($pointerGraceIntent == null ? void 0 : $pointerGraceIntent.side);
      return isMovingTowards && isPointerInGraceArea(e, $pointerGraceIntent == null ? void 0 : $pointerGraceIntent.area);
    };
  });
  const { typed, handleTypeaheadSearch } = createTypeaheadSearch();
  const rootIds = toWritableStores2({ ...generateIds(menuIdParts), ...opts.ids });
  const isVisible = derivedVisible({
    open: rootOpen,
    forceVisible,
    activeTrigger: rootActiveTrigger
  });
  const rootMenu = builder(name27(), {
    stores: [isVisible, portal, rootIds.menu, rootIds.trigger],
    returned: ([$isVisible, $portal, $rootMenuId, $rootTriggerId]) => {
      return {
        role: "menu",
        hidden: $isVisible ? void 0 : true,
        style: styleToString2({
          display: $isVisible ? void 0 : "none"
        }),
        id: $rootMenuId,
        "aria-labelledby": $rootTriggerId,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": $portal ? "" : void 0,
        tabindex: -1
      };
    },
    action: (node) => {
      let unsubPopper = noop2;
      const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$rootActiveTrigger)
          return;
        tick().then(() => {
          setMeltMenuAttribute(node, selector10);
          const popper = usePopper(node, {
            anchorElement: $rootActiveTrigger,
            open: rootOpen,
            options: {
              floating: $positioning,
              clickOutside: $closeOnOutsideClick ? void 0 : null,
              portal: getPortalDestination(node, $portal),
              escapeKeydown: $closeOnEscape ? void 0 : null
            }
          });
          if (popper && popper.destroy) {
            unsubPopper = popper.destroy;
          }
        });
      });
      const unsubEvents = executeCallbacks2(addMeltEventListener(node, "keydown", (e) => {
        const target = e.target;
        const menuEl = e.currentTarget;
        if (!isHTMLElement2(target) || !isHTMLElement2(menuEl))
          return;
        const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
        if (!isKeyDownInside)
          return;
        if (FIRST_LAST_KEYS.includes(e.key)) {
          handleMenuNavigation(e, get_store_value(loop) ?? false);
        }
        if (e.key === kbd2.TAB) {
          e.preventDefault();
          rootOpen.set(false);
          handleTabNavigation(e, nextFocusable, prevFocusable);
          return;
        }
        const isCharacterKey = e.key.length === 1;
        const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
        if (!isModifierKey && isCharacterKey && get_store_value(typeahead) === true) {
          handleTypeaheadSearch(e.key, getMenuItems(menuEl));
        }
      }));
      return {
        destroy() {
          unsubDerived();
          unsubEvents();
          unsubPopper();
        }
      };
    }
  });
  const rootTrigger = builder(name27("trigger"), {
    stores: [rootOpen, rootIds.menu, rootIds.trigger],
    returned: ([$rootOpen, $rootMenuId, $rootTriggerId]) => {
      return {
        "aria-controls": $rootMenuId,
        "aria-expanded": $rootOpen,
        "data-state": $rootOpen ? "open" : "closed",
        id: $rootTriggerId,
        tabindex: 0
      };
    },
    action: (node) => {
      applyAttrsIfDisabled(node);
      const unsub = executeCallbacks2(addMeltEventListener(node, "click", (e) => {
        const $rootOpen = get_store_value(rootOpen);
        const triggerEl = e.currentTarget;
        if (!isHTMLElement2(triggerEl))
          return;
        handleOpen(triggerEl);
        if (!$rootOpen)
          e.preventDefault();
      }), addMeltEventListener(node, "keydown", (e) => {
        const triggerEl = e.currentTarget;
        if (!isHTMLElement2(triggerEl))
          return;
        if (!(SELECTION_KEYS.includes(e.key) || e.key === kbd2.ARROW_DOWN))
          return;
        e.preventDefault();
        handleOpen(triggerEl);
        const menuId = triggerEl.getAttribute("aria-controls");
        if (!menuId)
          return;
        const menu = document.getElementById(menuId);
        if (!menu)
          return;
        const menuItems = getMenuItems(menu);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const rootArrow = builder(name27("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString2({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  const item = builder(name27("item"), {
    returned: () => {
      return {
        role: "menuitem",
        tabindex: -1,
        "data-orientation": "vertical"
      };
    },
    action: (node) => {
      setMeltMenuAttribute(node, selector10);
      applyAttrsIfDisabled(node);
      const unsub = executeCallbacks2(addMeltEventListener(node, "pointerdown", (e) => {
        const itemEl = e.currentTarget;
        if (!isHTMLElement2(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e.preventDefault();
          return;
        }
      }), addMeltEventListener(node, "click", (e) => {
        const itemEl = e.currentTarget;
        if (!isHTMLElement2(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e.preventDefault();
          return;
        }
        if (e.defaultPrevented) {
          handleRovingFocus(itemEl);
          return;
        }
        sleep(1).then(() => {
          rootOpen.set(false);
        });
      }), addMeltEventListener(node, "keydown", (e) => {
        onItemKeyDown(e);
      }), addMeltEventListener(node, "pointermove", (e) => {
        onMenuItemPointerMove(e);
      }), addMeltEventListener(node, "pointerleave", (e) => {
        onMenuItemPointerLeave(e);
      }), addMeltEventListener(node, "focusin", (e) => {
        onItemFocusIn(e);
      }), addMeltEventListener(node, "focusout", (e) => {
        onItemFocusOut(e);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const group = builder(name27("group"), {
    returned: () => {
      return (groupId) => ({
        role: "group",
        "aria-labelledby": groupId
      });
    }
  });
  const groupLabel = builder(name27("group-label"), {
    returned: () => {
      return (groupId) => ({
        id: groupId
      });
    }
  });
  const checkboxItemDefaults = {
    defaultChecked: false,
    disabled: false
  };
  const createCheckboxItem = (props) => {
    const withDefaults = { ...checkboxItemDefaults, ...props };
    const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked ?? null);
    const checked = overridable(checkedWritable, withDefaults.onCheckedChange);
    const disabled = writable(withDefaults.disabled);
    const checkboxItem = builder(name27("checkbox-item"), {
      stores: [checked, disabled],
      returned: ([$checked, $disabled]) => {
        return {
          role: "menuitemcheckbox",
          tabindex: -1,
          "data-orientation": "vertical",
          "aria-checked": isIndeterminate($checked) ? "mixed" : $checked ? "true" : "false",
          "data-disabled": disabledAttr($disabled),
          "data-state": getCheckedState($checked)
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector10);
        applyAttrsIfDisabled(node);
        const unsub = executeCallbacks2(addMeltEventListener(node, "pointerdown", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement2(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement2(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e.preventDefault();
            return;
          }
          if (e.defaultPrevented) {
            handleRovingFocus(itemEl);
            return;
          }
          checked.update((prev2) => {
            if (isIndeterminate(prev2))
              return true;
            return !prev2;
          });
          tick().then(() => {
            rootOpen.set(false);
          });
        }), addMeltEventListener(node, "keydown", (e) => {
          onItemKeyDown(e);
        }), addMeltEventListener(node, "pointermove", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement2(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            onItemLeave(e);
            return;
          }
          onMenuItemPointerMove(e, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e) => {
          onMenuItemPointerLeave(e);
        }), addMeltEventListener(node, "focusin", (e) => {
          onItemFocusIn(e);
        }), addMeltEventListener(node, "focusout", (e) => {
          onItemFocusOut(e);
        }));
        return {
          destroy: unsub
        };
      }
    });
    return {
      elements: {
        checkboxItem
      },
      states: {
        checked
      },
      options: {
        disabled
      }
    };
  };
  const createMenuRadioGroup = (args = {}) => {
    const valueWritable = args.value ?? writable(args.defaultValue ?? null);
    const value = overridable(valueWritable, args.onValueChange);
    const radioGroup = builder(name27("radio-group"), {
      returned: () => ({
        role: "group"
      })
    });
    const radioItemDefaults = {
      disabled: false
    };
    const radioItem = builder(name27("radio-item"), {
      stores: [value],
      returned: ([$value]) => {
        return (itemProps) => {
          const { value: itemValue, disabled } = { ...radioItemDefaults, ...itemProps };
          const checked = $value === itemValue;
          return {
            disabled,
            role: "menuitemradio",
            "data-state": checked ? "checked" : "unchecked",
            "aria-checked": checked,
            "data-disabled": disabledAttr(disabled),
            "data-value": itemValue,
            "data-orientation": "vertical",
            tabindex: -1
          };
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector10);
        const unsub = executeCallbacks2(addMeltEventListener(node, "pointerdown", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement2(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement2(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e.preventDefault();
            return;
          }
          if (e.defaultPrevented) {
            if (!isHTMLElement2(itemEl))
              return;
            handleRovingFocus(itemEl);
            return;
          }
          value.set(itemValue);
          tick().then(() => {
            rootOpen.set(false);
          });
        }), addMeltEventListener(node, "keydown", (e) => {
          onItemKeyDown(e);
        }), addMeltEventListener(node, "pointermove", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement2(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            onItemLeave(e);
            return;
          }
          onMenuItemPointerMove(e, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e) => {
          onMenuItemPointerLeave(e);
        }), addMeltEventListener(node, "focusin", (e) => {
          onItemFocusIn(e);
        }), addMeltEventListener(node, "focusout", (e) => {
          onItemFocusOut(e);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isChecked = derived(value, ($value) => {
      return (itemValue) => {
        return $value === itemValue;
      };
    });
    return {
      elements: {
        radioGroup,
        radioItem
      },
      states: {
        value
      },
      helpers: {
        isChecked
      }
    };
  };
  const { elements: { root: separator } } = createSeparator({
    orientation: "horizontal"
  });
  const subMenuDefaults = {
    ...defaults8,
    disabled: false,
    positioning: {
      placement: "right-start",
      gutter: 8
    }
  };
  const createSubmenu = (args) => {
    const withDefaults = { ...subMenuDefaults, ...args };
    const subOpenWritable = withDefaults.open ?? writable(false);
    const subOpen = overridable(subOpenWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
    const options = toWritableStores2(omit2(withDefaults, "ids"));
    const { positioning: positioning2, arrowSize: arrowSize2, disabled } = options;
    const subActiveTrigger = writable(null);
    const subOpenTimer = writable(null);
    const pointerGraceTimer = writable(0);
    const subIds = toWritableStores2({ ...generateIds(menuIdParts), ...withDefaults.ids });
    onMount(() => {
      const subTrigger2 = document.getElementById(get_store_value(subIds.trigger));
      if (subTrigger2) {
        subActiveTrigger.set(subTrigger2);
      }
    });
    const subIsVisible = derivedVisible({
      open: subOpen,
      forceVisible,
      activeTrigger: subActiveTrigger
    });
    const subMenu = builder(name27("submenu"), {
      stores: [subIsVisible, subIds.menu, subIds.trigger],
      returned: ([$subIsVisible, $subMenuId, $subTriggerId]) => {
        return {
          role: "menu",
          hidden: $subIsVisible ? void 0 : true,
          style: styleToString2({
            display: $subIsVisible ? void 0 : "none"
          }),
          id: $subMenuId,
          "aria-labelledby": $subTriggerId,
          "data-state": $subIsVisible ? "open" : "closed",
          // unit tests fail on `.closest` if the id starts with a number
          // so using a data attribute
          "data-id": $subMenuId,
          tabindex: -1
        };
      },
      action: (node) => {
        let unsubPopper = noop2;
        const unsubDerived = effect([subIsVisible, positioning2], ([$subIsVisible, $positioning]) => {
          unsubPopper();
          if (!$subIsVisible)
            return;
          const activeTrigger = get_store_value(subActiveTrigger);
          if (!activeTrigger)
            return;
          tick().then(() => {
            const parentMenuEl = getParentMenu(activeTrigger);
            const popper = usePopper(node, {
              anchorElement: activeTrigger,
              open: subOpen,
              options: {
                floating: $positioning,
                portal: isHTMLElement2(parentMenuEl) ? parentMenuEl : void 0,
                clickOutside: null,
                focusTrap: null,
                escapeKeydown: null
              }
            });
            if (popper && popper.destroy) {
              unsubPopper = popper.destroy;
            }
          });
        });
        const unsubEvents = executeCallbacks2(addMeltEventListener(node, "keydown", (e) => {
          if (e.key === kbd2.ESCAPE) {
            return;
          }
          const target = e.target;
          const menuEl = e.currentTarget;
          if (!isHTMLElement2(target) || !isHTMLElement2(menuEl))
            return;
          const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
          if (!isKeyDownInside)
            return;
          if (FIRST_LAST_KEYS.includes(e.key)) {
            e.stopImmediatePropagation();
            handleMenuNavigation(e, get_store_value(loop) ?? false);
            return;
          }
          const isCloseKey = SUB_CLOSE_KEYS["ltr"].includes(e.key);
          const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
          const isCharacterKey = e.key.length === 1;
          if (isCloseKey) {
            const $subActiveTrigger = get_store_value(subActiveTrigger);
            e.preventDefault();
            subOpen.update(() => {
              if ($subActiveTrigger) {
                handleRovingFocus($subActiveTrigger);
              }
              return false;
            });
            return;
          }
          if (e.key === kbd2.TAB) {
            e.preventDefault();
            rootOpen.set(false);
            handleTabNavigation(e, nextFocusable, prevFocusable);
            return;
          }
          if (!isModifierKey && isCharacterKey && get_store_value(typeahead) === true) {
            handleTypeaheadSearch(e.key, getMenuItems(menuEl));
          }
        }), addMeltEventListener(node, "pointermove", (e) => {
          onMenuPointerMove(e);
        }), addMeltEventListener(node, "focusout", (e) => {
          const $subActiveTrigger = get_store_value(subActiveTrigger);
          if (get_store_value(isUsingKeyboard)) {
            const target = e.target;
            const submenuEl = document.getElementById(get_store_value(subIds.menu));
            if (!isHTMLElement2(submenuEl) || !isHTMLElement2(target))
              return;
            if (!submenuEl.contains(target) && target !== $subActiveTrigger) {
              subOpen.set(false);
            }
          } else {
            const menuEl = e.currentTarget;
            const relatedTarget = e.relatedTarget;
            if (!isHTMLElement2(relatedTarget) || !isHTMLElement2(menuEl))
              return;
            if (!menuEl.contains(relatedTarget) && relatedTarget !== $subActiveTrigger) {
              subOpen.set(false);
            }
          }
        }));
        return {
          destroy() {
            unsubDerived();
            unsubPopper();
            unsubEvents();
          }
        };
      }
    });
    const subTrigger = builder(name27("subtrigger"), {
      stores: [subOpen, disabled, subIds.menu, subIds.trigger],
      returned: ([$subOpen, $disabled, $subMenuId, $subTriggerId]) => {
        return {
          role: "menuitem",
          id: $subTriggerId,
          tabindex: -1,
          "aria-controls": $subMenuId,
          "aria-expanded": $subOpen,
          "data-state": $subOpen ? "open" : "closed",
          "data-disabled": disabledAttr($disabled),
          "aria-haspopop": "menu"
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector10);
        applyAttrsIfDisabled(node);
        const unsubTimer = () => {
          clearTimerStore(subOpenTimer);
          window.clearTimeout(get_store_value(pointerGraceTimer));
          pointerGraceIntent.set(null);
        };
        const unsubEvents = executeCallbacks2(addMeltEventListener(node, "click", (e) => {
          if (e.defaultPrevented)
            return;
          const triggerEl = e.currentTarget;
          if (!isHTMLElement2(triggerEl) || isElementDisabled(triggerEl))
            return;
          handleRovingFocus(triggerEl);
          if (!get_store_value(subOpen)) {
            subOpen.update((prev2) => {
              const isAlreadyOpen = prev2;
              if (!isAlreadyOpen) {
                subActiveTrigger.set(triggerEl);
                return !prev2;
              }
              return prev2;
            });
          }
        }), addMeltEventListener(node, "keydown", (e) => {
          const $typed = get_store_value(typed);
          const triggerEl = e.currentTarget;
          if (!isHTMLElement2(triggerEl) || isElementDisabled(triggerEl))
            return;
          const isTypingAhead = $typed.length > 0;
          if (isTypingAhead && e.key === kbd2.SPACE)
            return;
          if (SUB_OPEN_KEYS["ltr"].includes(e.key)) {
            if (!get_store_value(subOpen)) {
              triggerEl.click();
              e.preventDefault();
              return;
            }
            const menuId = triggerEl.getAttribute("aria-controls");
            if (!menuId)
              return;
            const menuEl = document.getElementById(menuId);
            if (!isHTMLElement2(menuEl))
              return;
            const firstItem = getMenuItems(menuEl)[0];
            handleRovingFocus(firstItem);
          }
        }), addMeltEventListener(node, "pointermove", (e) => {
          if (!isMouse(e))
            return;
          onItemEnter(e);
          if (e.defaultPrevented)
            return;
          const triggerEl = e.currentTarget;
          if (!isHTMLElement2(triggerEl))
            return;
          if (!isFocusWithinSubmenu(get_store_value(subIds.menu))) {
            handleRovingFocus(triggerEl);
          }
          const openTimer = get_store_value(subOpenTimer);
          if (!get_store_value(subOpen) && !openTimer && !isElementDisabled(triggerEl)) {
            subOpenTimer.set(window.setTimeout(() => {
              subOpen.update(() => {
                subActiveTrigger.set(triggerEl);
                return true;
              });
              clearTimerStore(subOpenTimer);
            }, 100));
          }
        }), addMeltEventListener(node, "pointerleave", (e) => {
          if (!isMouse(e))
            return;
          clearTimerStore(subOpenTimer);
          const submenuEl = document.getElementById(get_store_value(subIds.menu));
          const contentRect = submenuEl == null ? void 0 : submenuEl.getBoundingClientRect();
          if (contentRect) {
            const side = submenuEl == null ? void 0 : submenuEl.dataset.side;
            const rightSide = side === "right";
            const bleed = rightSide ? -5 : 5;
            const contentNearEdge = contentRect[rightSide ? "left" : "right"];
            const contentFarEdge = contentRect[rightSide ? "right" : "left"];
            pointerGraceIntent.set({
              area: [
                // Apply a bleed on clientX to ensure that our exit point is
                // consistently within polygon bounds
                { x: e.clientX + bleed, y: e.clientY },
                { x: contentNearEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.bottom },
                { x: contentNearEdge, y: contentRect.bottom }
              ],
              side
            });
            window.clearTimeout(get_store_value(pointerGraceTimer));
            pointerGraceTimer.set(window.setTimeout(() => {
              pointerGraceIntent.set(null);
            }, 300));
          } else {
            onTriggerLeave(e);
            if (e.defaultPrevented)
              return;
            pointerGraceIntent.set(null);
          }
        }), addMeltEventListener(node, "focusout", (e) => {
          const triggerEl = e.currentTarget;
          if (!isHTMLElement2(triggerEl))
            return;
          removeHighlight(triggerEl);
          const relatedTarget = e.relatedTarget;
          if (!isHTMLElement2(relatedTarget))
            return;
          const menuId = triggerEl.getAttribute("aria-controls");
          if (!menuId)
            return;
          const menu = document.getElementById(menuId);
          if (menu && !menu.contains(relatedTarget)) {
            subOpen.set(false);
          }
        }), addMeltEventListener(node, "focusin", (e) => {
          onItemFocusIn(e);
        }));
        return {
          destroy() {
            unsubTimer();
            unsubEvents();
          }
        };
      }
    });
    const subArrow = builder(name27("subarrow"), {
      stores: arrowSize2,
      returned: ($arrowSize) => ({
        "data-arrow": true,
        style: styleToString2({
          position: "absolute",
          width: `var(--arrow-size, ${$arrowSize}px)`,
          height: `var(--arrow-size, ${$arrowSize}px)`
        })
      })
    });
    effect([rootOpen], ([$rootOpen]) => {
      if (!$rootOpen) {
        subActiveTrigger.set(null);
        subOpen.set(false);
      }
    });
    effect([pointerGraceIntent], ([$pointerGraceIntent]) => {
      if (!isBrowser2 || $pointerGraceIntent)
        return;
      window.clearTimeout(get_store_value(pointerGraceTimer));
    });
    effect([subOpen], ([$subOpen]) => {
      if (!isBrowser2)
        return;
      sleep(1).then(() => {
        const menuEl = document.getElementById(get_store_value(subIds.menu));
        if (!menuEl)
          return;
        if ($subOpen && get_store_value(isUsingKeyboard)) {
          const menuItems = getMenuItems(menuEl);
          if (!menuItems.length)
            return;
          handleRovingFocus(menuItems[0]);
        }
        if (!$subOpen) {
          const focusedItem = get_store_value(currentFocusedItem);
          if (focusedItem && menuEl.contains(focusedItem)) {
            removeHighlight(focusedItem);
          }
        }
        if (menuEl && !$subOpen) {
          const subTriggerEl = document.getElementById(get_store_value(subIds.trigger));
          if (!subTriggerEl || document.activeElement === subTriggerEl)
            return;
          removeHighlight(subTriggerEl);
        }
      });
    });
    return {
      ids: subIds,
      elements: {
        subTrigger,
        subMenu,
        subArrow
      },
      states: {
        subOpen
      },
      options
    };
  };
  onMount(() => {
    const triggerEl = document.getElementById(get_store_value(rootIds.trigger));
    if (isHTMLElement2(triggerEl) && get_store_value(rootOpen)) {
      rootActiveTrigger.set(triggerEl);
    }
    const unsubs = [];
    const handlePointer = () => isUsingKeyboard.set(false);
    const handleKeyDown = () => {
      isUsingKeyboard.set(true);
      unsubs.push(executeCallbacks2(addEventListener2(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener2(document, "pointermove", handlePointer, { capture: true, once: true })));
    };
    const keydownListener = (e) => {
      if (e.key === kbd2.ESCAPE && get_store_value(closeOnEscape)) {
        rootOpen.set(false);
        return;
      }
    };
    unsubs.push(addEventListener2(document, "keydown", handleKeyDown, { capture: true }));
    unsubs.push(addEventListener2(document, "keydown", keydownListener));
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect([rootOpen, currentFocusedItem], ([$rootOpen, $currentFocusedItem]) => {
    if (!$rootOpen && $currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
  });
  effect([rootOpen, rootActiveTrigger, preventScroll], ([$rootOpen, $rootActiveTrigger, $preventScroll]) => {
    if (!isBrowser2)
      return;
    const unsubs = [];
    if (opts.removeScroll && $rootOpen && $preventScroll) {
      unsubs.push(removeScroll());
    }
    const $closeFocus = get_store_value(closeFocus);
    if (!$rootOpen) {
      if ($rootActiveTrigger) {
        handleFocus({ prop: $closeFocus, defaultEl: $rootActiveTrigger });
      } else {
        handleFocus({
          prop: $closeFocus,
          defaultEl: document.getElementById(get_store_value(rootIds.trigger))
        });
      }
    }
    sleep(1).then(() => {
      const menuEl = document.getElementById(get_store_value(rootIds.menu));
      if (menuEl && $rootOpen && get_store_value(isUsingKeyboard)) {
        if (get_store_value(disableFocusFirstItem)) {
          handleRovingFocus(menuEl);
          return;
        }
        const menuItems = getMenuItems(menuEl);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      }
    });
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect(rootOpen, ($rootOpen) => {
    if (!isBrowser2)
      return;
    const handlePointer = () => isUsingKeyboard.set(false);
    const handleKeyDown = (e) => {
      isUsingKeyboard.set(true);
      if (e.key === kbd2.ESCAPE && $rootOpen && get_store_value(closeOnEscape)) {
        rootOpen.set(false);
        return;
      }
    };
    return executeCallbacks2(addEventListener2(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener2(document, "pointermove", handlePointer, { capture: true, once: true }), addEventListener2(document, "keydown", handleKeyDown, { capture: true }));
  });
  function handleOpen(triggerEl) {
    rootOpen.update((prev2) => {
      const isOpen = !prev2;
      if (isOpen) {
        nextFocusable.set(getNextFocusable(triggerEl));
        prevFocusable.set(getPreviousFocusable(triggerEl));
        rootActiveTrigger.set(triggerEl);
      }
      return isOpen;
    });
  }
  function onItemFocusIn(e) {
    const itemEl = e.currentTarget;
    if (!isHTMLElement2(itemEl))
      return;
    const $currentFocusedItem = get_store_value(currentFocusedItem);
    if ($currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
    addHighlight(itemEl);
    currentFocusedItem.set(itemEl);
  }
  function onItemFocusOut(e) {
    const itemEl = e.currentTarget;
    if (!isHTMLElement2(itemEl))
      return;
    removeHighlight(itemEl);
  }
  function onItemEnter(e) {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  }
  function onItemLeave(e) {
    if (isPointerMovingToSubmenu(e)) {
      return;
    }
    const target = e.target;
    if (!isHTMLElement2(target))
      return;
    const parentMenuEl = getParentMenu(target);
    if (!parentMenuEl)
      return;
    handleRovingFocus(parentMenuEl);
  }
  function onTriggerLeave(e) {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  }
  function onMenuPointerMove(e) {
    if (!isMouse(e))
      return;
    const target = e.target;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement2(currentTarget) || !isHTMLElement2(target))
      return;
    const $lastPointerX = get_store_value(lastPointerX);
    const pointerXHasChanged = $lastPointerX !== e.clientX;
    if (currentTarget.contains(target) && pointerXHasChanged) {
      const newDir = e.clientX > $lastPointerX ? "right" : "left";
      pointerDir.set(newDir);
      lastPointerX.set(e.clientX);
    }
  }
  function onMenuItemPointerMove(e, currTarget = null) {
    if (!isMouse(e))
      return;
    onItemEnter(e);
    if (e.defaultPrevented)
      return;
    if (currTarget) {
      handleRovingFocus(currTarget);
      return;
    }
    const currentTarget = e.currentTarget;
    if (!isHTMLElement2(currentTarget))
      return;
    handleRovingFocus(currentTarget);
  }
  function onMenuItemPointerLeave(e) {
    if (!isMouse(e))
      return;
    onItemLeave(e);
  }
  function onItemKeyDown(e) {
    const $typed = get_store_value(typed);
    const isTypingAhead = $typed.length > 0;
    if (isTypingAhead && e.key === kbd2.SPACE) {
      e.preventDefault();
      return;
    }
    if (SELECTION_KEYS.includes(e.key)) {
      e.preventDefault();
      const itemEl = e.currentTarget;
      if (!isHTMLElement2(itemEl))
        return;
      itemEl.click();
    }
  }
  function isIndeterminate(checked) {
    return checked === "indeterminate";
  }
  function getCheckedState(checked) {
    return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
  }
  function isPointerMovingToSubmenu(e) {
    return get_store_value(pointerMovingToSubmenu)(e);
  }
  function getParentMenu(element2) {
    const parentMenuEl = element2.closest('[role="menu"]');
    if (!isHTMLElement2(parentMenuEl))
      return null;
    return parentMenuEl;
  }
  return {
    ids: rootIds,
    trigger: rootTrigger,
    menu: rootMenu,
    open: rootOpen,
    item,
    group,
    groupLabel,
    arrow: rootArrow,
    options: opts.rootOptions,
    createCheckboxItem,
    createSubmenu,
    createMenuRadioGroup,
    separator,
    handleTypeaheadSearch
  };
}
function handleTabNavigation(e, nextFocusable, prevFocusable) {
  if (e.shiftKey) {
    const $prevFocusable = get_store_value(prevFocusable);
    if ($prevFocusable) {
      e.preventDefault();
      sleep(1).then(() => $prevFocusable.focus());
      prevFocusable.set(null);
    }
  } else {
    const $nextFocusable = get_store_value(nextFocusable);
    if ($nextFocusable) {
      e.preventDefault();
      sleep(1).then(() => $nextFocusable.focus());
      nextFocusable.set(null);
    }
  }
}
function getMenuItems(menuElement) {
  return Array.from(menuElement.querySelectorAll(`[data-melt-menu-id="${menuElement.id}"]`)).filter((item) => isHTMLElement2(item));
}
function applyAttrsIfDisabled(element2) {
  if (!element2 || !isElementDisabled(element2))
    return;
  element2.setAttribute("data-disabled", "");
  element2.setAttribute("aria-disabled", "true");
}
function clearTimerStore(timerStore) {
  if (!isBrowser2)
    return;
  const timer = get_store_value(timerStore);
  if (timer) {
    window.clearTimeout(timer);
    timerStore.set(null);
  }
}
function isMouse(e) {
  return e.pointerType === "mouse";
}
function setMeltMenuAttribute(element2, selector10) {
  if (!element2)
    return;
  const menuEl = element2.closest(`${selector10()}, ${selector10("submenu")}`);
  if (!isHTMLElement2(menuEl))
    return;
  element2.setAttribute("data-melt-menu-id", menuEl.id);
}
function handleMenuNavigation(e, loop) {
  e.preventDefault();
  const currentFocusedItem = document.activeElement;
  const currentTarget = e.currentTarget;
  if (!isHTMLElement2(currentFocusedItem) || !isHTMLElement2(currentTarget))
    return;
  const menuItems = getMenuItems(currentTarget);
  if (!menuItems.length)
    return;
  const candidateNodes = menuItems.filter((item) => {
    if (item.hasAttribute("data-disabled") || item.getAttribute("disabled") === "true") {
      return false;
    }
    return true;
  });
  const currentIndex = candidateNodes.indexOf(currentFocusedItem);
  let nextIndex;
  switch (e.key) {
    case kbd2.ARROW_DOWN:
      if (loop) {
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : 0;
      } else {
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : currentIndex;
      }
      break;
    case kbd2.ARROW_UP:
      if (loop) {
        nextIndex = currentIndex > 0 ? currentIndex - 1 : candidateNodes.length - 1;
      } else {
        nextIndex = currentIndex < 0 ? candidateNodes.length - 1 : currentIndex > 0 ? currentIndex - 1 : 0;
      }
      break;
    case kbd2.HOME:
      nextIndex = 0;
      break;
    case kbd2.END:
      nextIndex = candidateNodes.length - 1;
      break;
    default:
      return;
  }
  handleRovingFocus(candidateNodes[nextIndex]);
}
function isPointerInGraceArea(e, area) {
  if (!area)
    return false;
  const cursorPos = { x: e.clientX, y: e.clientY };
  return isPointInPolygon(cursorPos, area);
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isFocusWithinSubmenu(submenuId) {
  const activeEl = document.activeElement;
  if (!isHTMLElement2(activeEl))
    return false;
  const submenuEl = activeEl.closest(`[data-id="${submenuId}"]`);
  return isHTMLElement2(submenuEl);
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/context-menu/create.js
var defaults9 = {
  arrowSize: 8,
  positioning: {
    placement: "bottom-start"
  },
  preventScroll: true,
  closeOnEscape: true,
  closeOnOutsideClick: true,
  portal: void 0,
  loop: false,
  dir: "ltr",
  defaultOpen: false,
  forceVisible: false,
  typeahead: true,
  disableFocusFirstItem: true,
  closeFocus: void 0
};
var { name: name4, selector: selector2 } = createElHelpers("context-menu");
function createContextMenu(props) {
  const withDefaults = { ...defaults9, ...props };
  const rootOptions = toWritableStores2(omit2(withDefaults, "ids"));
  const { positioning, closeOnOutsideClick, portal, forceVisible, closeOnEscape, loop } = rootOptions;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const rootOpen = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const rootActiveTrigger = writable(null);
  const nextFocusable = writable(null);
  const prevFocusable = writable(null);
  const { item, createCheckboxItem, arrow: arrow2, createSubmenu, createMenuRadioGroup, ids, separator, handleTypeaheadSearch, group, groupLabel } = createMenuBuilder({
    rootOpen,
    rootActiveTrigger,
    rootOptions,
    nextFocusable,
    prevFocusable,
    selector: "context-menu",
    removeScroll: true,
    ids: withDefaults.ids
  });
  const point = writable(null);
  const virtual = derivedWithUnsubscribe([point], ([$point]) => {
    if ($point === null)
      return null;
    return {
      getBoundingClientRect: () => DOMRect.fromRect({
        width: 0,
        height: 0,
        ...$point
      })
    };
  });
  const longPressTimer = writable(0);
  function handleClickOutside(e) {
    if (e.defaultPrevented)
      return;
    const target = e.target;
    if (!(target instanceof Element))
      return;
    const isClickInsideTrigger = target.closest(`[data-id="${get_store_value(ids.trigger)}"]`) !== null;
    if (!isClickInsideTrigger || isLeftClick(e)) {
      rootOpen.set(false);
      return;
    }
  }
  const isVisible = derivedVisible({
    open: rootOpen,
    forceVisible,
    activeTrigger: rootActiveTrigger
  });
  const menu = builder(name4(), {
    stores: [isVisible, portal, ids.menu, ids.trigger],
    returned: ([$isVisible, $portal, $menuId, $triggerId]) => {
      return {
        role: "menu",
        hidden: $isVisible ? void 0 : true,
        style: styleToString2({
          display: $isVisible ? void 0 : "none"
        }),
        id: $menuId,
        "aria-labelledby": $triggerId,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": $portal ? "" : void 0,
        tabindex: -1
      };
    },
    action: (node) => {
      let unsubPopper = noop2;
      const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$rootActiveTrigger)
          return;
        tick().then(() => {
          setMeltMenuAttribute(node, selector2);
          const $virtual = get_store_value(virtual);
          const popper = usePopper(node, {
            anchorElement: $virtual ? $virtual : $rootActiveTrigger,
            open: rootOpen,
            options: {
              floating: $positioning,
              clickOutside: $closeOnOutsideClick ? {
                handler: handleClickOutside
              } : null,
              portal: getPortalDestination(node, $portal),
              escapeKeydown: $closeOnEscape ? void 0 : null
            }
          });
          if (!popper || !popper.destroy)
            return;
          unsubPopper = popper.destroy;
        });
      });
      const unsubEvents = executeCallbacks2(addMeltEventListener(node, "keydown", (e) => {
        const target = e.target;
        const menuEl = e.currentTarget;
        if (!isHTMLElement2(target) || !isHTMLElement2(menuEl))
          return;
        const isKeyDownInside = target.closest("[role='menu']") === menuEl;
        if (!isKeyDownInside)
          return;
        if (FIRST_LAST_KEYS.includes(e.key)) {
          handleMenuNavigation(e, get_store_value(loop));
        }
        if (e.key === kbd2.TAB) {
          e.preventDefault();
          rootOpen.set(false);
          handleTabNavigation(e, nextFocusable, prevFocusable);
          return;
        }
        const isCharacterKey = e.key.length === 1;
        const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
        if (!isModifierKey && isCharacterKey) {
          handleTypeaheadSearch(e.key, getMenuItems(menuEl));
        }
      }));
      return {
        destroy() {
          unsubDerived();
          unsubEvents();
          unsubPopper();
        }
      };
    }
  });
  const trigger = builder(name4("trigger"), {
    stores: [rootOpen, ids.trigger],
    returned: ([$rootOpen, $triggerId]) => {
      return {
        "data-state": $rootOpen ? "open" : "closed",
        id: $triggerId,
        style: styleToString2({
          WebkitTouchCallout: "none"
        }),
        "data-id": $triggerId
      };
    },
    action: (node) => {
      applyAttrsIfDisabled(node);
      const handleOpen = (e) => {
        point.set({
          x: e.clientX,
          y: e.clientY
        });
        nextFocusable.set(getNextFocusable(node));
        prevFocusable.set(getPreviousFocusable(node));
        rootActiveTrigger.set(node);
        rootOpen.set(true);
      };
      const unsubTimer = () => {
        clearTimerStore(longPressTimer);
      };
      const unsub = executeCallbacks2(addMeltEventListener(node, "contextmenu", (e) => {
        clearTimerStore(longPressTimer);
        handleOpen(e);
        e.preventDefault();
      }), addMeltEventListener(node, "pointerdown", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
        longPressTimer.set(window.setTimeout(() => handleOpen(e), 700));
      }), addMeltEventListener(node, "pointermove", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
      }), addMeltEventListener(node, "pointercancel", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
      }), addMeltEventListener(node, "pointerup", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
      }));
      return {
        destroy() {
          unsubTimer();
          unsub();
        }
      };
    }
  });
  return {
    ids,
    elements: {
      menu,
      trigger,
      item,
      arrow: arrow2,
      separator,
      group,
      groupLabel
    },
    states: {
      open: rootOpen
    },
    builders: {
      createSubmenu,
      createCheckboxItem,
      createMenuRadioGroup
    },
    options: rootOptions
  };
}
function isTouchOrPen(e) {
  return e.pointerType !== "mouse";
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/date-field/_internal/parts.js
var DATE_SEGMENT_PARTS = ["day", "month", "year"];
var TIME_SEGMENT_PARTS = ["hour", "minute", "second", "dayPeriod"];
var NON_EDITABLE_SEGMENT_PARTS = ["literal", "timeZoneName"];
var EDITABLE_SEGMENT_PARTS = [...DATE_SEGMENT_PARTS, ...TIME_SEGMENT_PARTS];
var ALL_SEGMENT_PARTS = [
  ...EDITABLE_SEGMENT_PARTS,
  ...NON_EDITABLE_SEGMENT_PARTS
];
var ALL_EXCEPT_LITERAL_PARTS = ALL_SEGMENT_PARTS.filter((part) => part !== "literal");

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/calendar/create.js
var { name: name5 } = createElHelpers("calendar");

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/date-field/create.js
var { name: name6 } = createElHelpers("dateField");

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/date-range-field/create.js
var { name: name7 } = createElHelpers("dateField");

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/dialog/create.js
var { name: name8 } = createElHelpers("dialog");
var defaults10 = {
  preventScroll: true,
  closeOnEscape: true,
  closeOnOutsideClick: true,
  role: "dialog",
  defaultOpen: false,
  portal: "body",
  forceVisible: false,
  openFocus: void 0,
  closeFocus: void 0
};
var openDialogIds = writable([]);
var dialogIdParts = ["content", "title", "description"];
function createDialog(props) {
  const withDefaults = { ...defaults10, ...props };
  const options = toWritableStores2(omit2(withDefaults, "ids"));
  const { preventScroll, closeOnEscape, closeOnOutsideClick, role, portal, forceVisible, openFocus, closeFocus } = options;
  const activeTrigger = writable(null);
  const ids = toWritableStores2({
    ...generateIds(dialogIdParts),
    ...withDefaults.ids
  });
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {
    return $open || $forceVisible;
  });
  let unsubScroll = noop2;
  function handleOpen(e) {
    const el = e.currentTarget;
    const triggerEl = e.currentTarget;
    if (!isHTMLElement2(el) || !isHTMLElement2(triggerEl))
      return;
    open.set(true);
    activeTrigger.set(triggerEl);
  }
  function handleClose() {
    open.set(false);
    handleFocus({
      prop: get_store_value(closeFocus),
      defaultEl: get_store_value(activeTrigger)
    });
  }
  effect([open], ([$open]) => {
    sleep(100).then(() => {
      if ($open) {
        openDialogIds.update((prev2) => {
          prev2.push(get_store_value(ids.content));
          return prev2;
        });
      } else {
        openDialogIds.update((prev2) => prev2.filter((id) => id !== get_store_value(ids.content)));
      }
    });
  });
  const trigger = builder(name8("trigger"), {
    stores: [open, ids.content],
    returned: ([$open, $contentId]) => {
      return {
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        "aria-controls": $contentId,
        type: "button"
      };
    },
    action: (node) => {
      const unsub = executeCallbacks2(addMeltEventListener(node, "click", (e) => {
        handleOpen(e);
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd2.ENTER && e.key !== kbd2.SPACE)
          return;
        e.preventDefault();
        handleOpen(e);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const overlay = builder(name8("overlay"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString2({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": true,
        "data-state": $isVisible ? "open" : "closed"
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop2;
      if (get_store_value(closeOnEscape)) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      return {
        destroy() {
          unsubEscapeKeydown();
        }
      };
    }
  });
  const content = builder(name8("content"), {
    stores: [isVisible, ids.content, ids.description, ids.title],
    returned: ([$isVisible, $contentId, $descriptionId, $titleId]) => {
      return {
        id: $contentId,
        role: get_store_value(role),
        "aria-describedby": $descriptionId,
        "aria-labelledby": $titleId,
        "data-state": $isVisible ? "open" : "closed",
        tabindex: -1,
        hidden: $isVisible ? void 0 : true,
        style: styleToString2({
          display: $isVisible ? void 0 : "none"
        })
      };
    },
    action: (node) => {
      let activate = noop2;
      let deactivate = noop2;
      const destroy = executeCallbacks2(effect([open], ([$open]) => {
        if (!$open)
          return;
        const focusTrap = createFocusTrap2({
          immediate: false,
          escapeDeactivates: false,
          returnFocusOnDeactivate: false,
          fallbackFocus: node
        });
        activate = focusTrap.activate;
        deactivate = focusTrap.deactivate;
        const ac = focusTrap.useFocusTrap(node);
        if (ac && ac.destroy) {
          return ac.destroy;
        } else {
          return focusTrap.deactivate;
        }
      }), effect([closeOnOutsideClick, open], ([$closeOnOutsideClick, $open]) => {
        return useClickOutside(node, {
          enabled: $open,
          handler: (e) => {
            if (e.defaultPrevented)
              return;
            const $openDialogIds = get_store_value(openDialogIds);
            const isLast = last($openDialogIds) === get_store_value(ids.content);
            if ($closeOnOutsideClick && isLast) {
              handleClose();
            }
          }
        }).destroy;
      }), effect([closeOnEscape], ([$closeOnEscape]) => {
        if (!$closeOnEscape)
          return noop2;
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          return escapeKeydown.destroy;
        }
        return noop2;
      }), effect([isVisible], ([$isVisible]) => {
        tick().then(() => {
          if (!$isVisible) {
            deactivate();
          } else {
            activate();
          }
        });
      }));
      return {
        destroy: () => {
          unsubScroll();
          destroy();
        }
      };
    }
  });
  const portalled = builder(name8("portalled"), {
    stores: portal,
    returned: ($portal) => ({
      "data-portal": $portal ? "" : void 0
    }),
    action: (node) => {
      const unsubPortal = effect([portal], ([$portal]) => {
        if (!$portal)
          return noop2;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop2;
        const portalAction = usePortal(node, portalDestination);
        if (portalAction && portalAction.destroy) {
          return portalAction.destroy;
        } else {
          return noop2;
        }
      });
      return {
        destroy() {
          unsubPortal();
        }
      };
    }
  });
  const title = builder(name8("title"), {
    stores: [ids.title],
    returned: ([$titleId]) => ({
      id: $titleId
    })
  });
  const description = builder(name8("description"), {
    stores: [ids.description],
    returned: ([$descriptionId]) => ({
      id: $descriptionId
    })
  });
  const close = builder(name8("close"), {
    returned: () => ({
      type: "button"
    }),
    action: (node) => {
      const unsub = executeCallbacks2(addMeltEventListener(node, "click", () => {
        handleClose();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd2.SPACE && e.key !== kbd2.ENTER)
          return;
        e.preventDefault();
        handleClose();
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect([open, preventScroll], ([$open, $preventScroll]) => {
    if (!isBrowser2)
      return;
    if ($preventScroll && $open)
      unsubScroll = removeScroll();
    if ($open) {
      const contentEl = document.getElementById(get_store_value(ids.content));
      handleFocus({ prop: get_store_value(openFocus), defaultEl: contentEl });
    }
    return () => {
      if (!get_store_value(forceVisible)) {
        unsubScroll();
      }
    };
  });
  return {
    ids,
    elements: {
      content,
      trigger,
      title,
      description,
      overlay,
      close,
      portalled
    },
    states: {
      open
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/dropdown-menu/create.js
var defaults11 = {
  arrowSize: 8,
  positioning: {
    placement: "bottom"
  },
  preventScroll: true,
  closeOnEscape: true,
  closeOnOutsideClick: true,
  portal: void 0,
  loop: false,
  dir: "ltr",
  defaultOpen: false,
  forceVisible: false,
  typeahead: true,
  closeFocus: void 0,
  disableFocusFirstItem: false
};
function createDropdownMenu(props) {
  const withDefaults = { ...defaults11, ...props };
  const rootOptions = toWritableStores2(omit2(withDefaults, "ids"));
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const rootOpen = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const rootActiveTrigger = writable(null);
  const nextFocusable = writable(null);
  const prevFocusable = writable(null);
  const { trigger, menu, item, arrow: arrow2, createSubmenu, createCheckboxItem, createMenuRadioGroup, separator, group, groupLabel, ids } = createMenuBuilder({
    rootOptions,
    rootOpen,
    rootActiveTrigger,
    nextFocusable,
    prevFocusable,
    selector: "dropdown-menu",
    removeScroll: true,
    ids: withDefaults.ids
  });
  return {
    ids,
    elements: {
      trigger,
      menu,
      item,
      arrow: arrow2,
      separator,
      group,
      groupLabel
    },
    states: {
      open: rootOpen
    },
    builders: {
      createCheckboxItem,
      createSubmenu,
      createMenuRadioGroup
    },
    options: rootOptions
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/link-preview/create.js
var { name: name9 } = createElHelpers("hover-card");
var defaults12 = {
  defaultOpen: false,
  openDelay: 1e3,
  closeDelay: 100,
  positioning: {
    placement: "bottom"
  },
  arrowSize: 8,
  closeOnOutsideClick: true,
  forceVisible: false,
  portal: "body",
  closeOnEscape: true
};
var linkPreviewIdParts = ["trigger", "content"];
function createLinkPreview(props = {}) {
  const withDefaults = { ...defaults12, ...props };
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const hasSelection = writable(false);
  const isPointerDownOnContent = writable(false);
  const containSelection = writable(false);
  const activeTrigger = writable(null);
  const options = toWritableStores2(omit2(withDefaults, "ids"));
  const { openDelay, closeDelay, positioning, arrowSize, closeOnOutsideClick, forceVisible, portal, closeOnEscape } = options;
  const ids = toWritableStores2({ ...generateIds(linkPreviewIdParts), ...withDefaults.ids });
  let timeout = null;
  let originalBodyUserSelect;
  const handleOpen = derived(openDelay, ($openDelay) => {
    return () => {
      if (timeout) {
        window.clearTimeout(timeout);
        timeout = null;
      }
      timeout = window.setTimeout(() => {
        open.set(true);
      }, $openDelay);
    };
  });
  const handleClose = derived([closeDelay, isPointerDownOnContent, hasSelection], ([$closeDelay, $isPointerDownOnContent, $hasSelection]) => {
    return () => {
      if (timeout) {
        window.clearTimeout(timeout);
        timeout = null;
      }
      if (!$isPointerDownOnContent && !$hasSelection) {
        timeout = window.setTimeout(() => {
          open.set(false);
        }, $closeDelay);
      }
    };
  });
  const trigger = builder(name9("trigger"), {
    stores: [open, ids.trigger, ids.content],
    returned: ([$open, $triggerId, $contentId]) => {
      return {
        role: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        "data-state": $open ? "open" : "closed",
        "aria-controls": $contentId,
        id: $triggerId
      };
    },
    action: (node) => {
      const unsub = executeCallbacks2(addMeltEventListener(node, "pointerenter", (e) => {
        if (isTouch(e))
          return;
        get_store_value(handleOpen)();
      }), addMeltEventListener(node, "pointerleave", (e) => {
        if (isTouch(e))
          return;
        get_store_value(handleClose)();
      }), addMeltEventListener(node, "focus", (e) => {
        if (!isElement(e.currentTarget) || !isFocusVisible(e.currentTarget))
          return;
        get_store_value(handleOpen)();
      }), addMeltEventListener(node, "blur", () => get_store_value(handleClose)()));
      return {
        destroy: unsub
      };
    }
  });
  const isVisible = derivedVisible({ open, forceVisible, activeTrigger });
  const content = builder(name9("content"), {
    stores: [isVisible, portal, ids.content],
    returned: ([$isVisible, $portal, $contentId]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString2({
          "pointer-events": $isVisible ? void 0 : "none",
          opacity: $isVisible ? 1 : 0,
          userSelect: "text",
          WebkitUserSelect: "text"
        }),
        id: $contentId,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": $portal ? "" : void 0
      };
    },
    action: (node) => {
      let unsub = noop2;
      const unsubTimers = () => {
        if (timeout) {
          window.clearTimeout(timeout);
        }
      };
      let unsubPopper = noop2;
      const unsubDerived = effect([isVisible, activeTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $activeTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$activeTrigger)
          return;
        const popper = usePopper(node, {
          anchorElement: $activeTrigger,
          open,
          options: {
            floating: $positioning,
            clickOutside: $closeOnOutsideClick ? void 0 : null,
            portal: getPortalDestination(node, $portal),
            focusTrap: null,
            escapeKeydown: $closeOnEscape ? void 0 : null
          }
        });
        if (popper && popper.destroy) {
          unsubPopper = popper.destroy;
        }
      });
      unsub = executeCallbacks2(addMeltEventListener(node, "pointerdown", (e) => {
        const currentTarget = e.currentTarget;
        const target = e.target;
        if (!isHTMLElement2(currentTarget) || !isHTMLElement2(target))
          return;
        if (currentTarget.contains(target)) {
          containSelection.set(true);
        }
        hasSelection.set(false);
        isPointerDownOnContent.set(true);
      }), addMeltEventListener(node, "pointerenter", (e) => {
        if (isTouch(e))
          return;
        get_store_value(handleOpen)();
      }), addMeltEventListener(node, "pointerleave", (e) => {
        if (isTouch(e))
          return;
        get_store_value(handleClose)();
      }), addMeltEventListener(node, "focusout", (e) => {
        e.preventDefault();
      }));
      return {
        destroy() {
          unsub();
          unsubPopper();
          unsubTimers();
          unsubDerived();
        }
      };
    }
  });
  const arrow2 = builder(name9("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString2({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  effect([containSelection], ([$containSelection]) => {
    if (!isBrowser2 || !$containSelection)
      return;
    const body = document.body;
    const contentElement = document.getElementById(get_store_value(ids.content));
    if (!contentElement)
      return;
    originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
    const originalContentUserSelect = contentElement.style.userSelect || contentElement.style.webkitUserSelect;
    body.style.userSelect = "none";
    body.style.webkitUserSelect = "none";
    contentElement.style.userSelect = "text";
    contentElement.style.webkitUserSelect = "text";
    return () => {
      body.style.userSelect = originalBodyUserSelect;
      body.style.webkitUserSelect = originalBodyUserSelect;
      contentElement.style.userSelect = originalContentUserSelect;
      contentElement.style.webkitUserSelect = originalContentUserSelect;
    };
  });
  onMount(() => {
    const triggerEl = document.getElementById(get_store_value(ids.trigger));
    if (!triggerEl)
      return;
    activeTrigger.set(triggerEl);
  });
  effect([open], ([$open]) => {
    if (!isBrowser2 || !$open) {
      hasSelection.set(false);
      return;
    }
    const handlePointerUp = () => {
      containSelection.set(false);
      isPointerDownOnContent.set(false);
      sleep(1).then(() => {
        var _a;
        const isSelection = ((_a = document.getSelection()) == null ? void 0 : _a.toString()) !== "";
        if (isSelection) {
          hasSelection.set(true);
        }
      });
    };
    document.addEventListener("pointerup", handlePointerUp);
    const contentElement = document.getElementById(get_store_value(ids.content));
    if (!contentElement)
      return;
    const tabbables = getTabbableNodes(contentElement);
    tabbables.forEach((tabbable) => tabbable.setAttribute("tabindex", "-1"));
    return () => {
      document.removeEventListener("pointerup", handlePointerUp);
      hasSelection.set(false);
      isPointerDownOnContent.set(false);
    };
  });
  return {
    ids,
    elements: {
      trigger,
      content,
      arrow: arrow2
    },
    states: {
      open
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/menubar/create.js
var MENUBAR_NAV_KEYS = [kbd2.ARROW_LEFT, kbd2.ARROW_RIGHT, kbd2.HOME, kbd2.END];
var { name: name10 } = createElHelpers("menubar");
var defaults13 = {
  loop: true,
  closeOnEscape: true
};
var menubarIdParts = ["menubar"];
function createMenubar(props) {
  const withDefaults = { ...defaults13, ...props };
  const options = toWritableStores2(omit2(withDefaults, "ids"));
  const { loop, closeOnEscape } = options;
  const activeMenu = writable("");
  const nextFocusable = writable(null);
  const prevFocusable = writable(null);
  const lastFocusedMenuTrigger = writable(null);
  const closeTimer = writable(0);
  let scrollRemoved = false;
  const ids = toWritableStores2({ ...generateIds(menubarIdParts), ...withDefaults.ids });
  const menubar = builder(name10(), {
    stores: [ids.menubar],
    returned([$menubarId]) {
      return {
        role: "menubar",
        "data-melt-menubar": "",
        "data-orientation": "horizontal",
        id: $menubarId
      };
    },
    action: (node) => {
      const menuTriggers = Array.from(node.querySelectorAll("[data-melt-menubar-trigger]"));
      if (!isHTMLElement2(menuTriggers[0]))
        return {};
      menuTriggers[0].tabIndex = 0;
      return {
        destroy: noop2
      };
    }
  });
  const menuDefaults = {
    positioning: {
      placement: "bottom-start"
    },
    preventScroll: true,
    arrowSize: 8,
    dir: "ltr",
    loop: false,
    closeOnEscape: true,
    closeOnOutsideClick: true,
    portal: void 0,
    forceVisible: false,
    defaultOpen: false,
    typeahead: true,
    closeFocus: void 0,
    disableFocusFirstItem: false
  };
  const createMenu = (props2) => {
    const withDefaults2 = { ...menuDefaults, ...props2 };
    const rootOpen = writable(false);
    const rootActiveTrigger = writable(null);
    const options2 = toWritableStores2(withDefaults2);
    const { positioning, portal, forceVisible } = options2;
    const m = createMenuBuilder({
      rootOptions: options2,
      rootOpen,
      rootActiveTrigger,
      nextFocusable,
      prevFocusable,
      selector: "menubar-menu",
      removeScroll: false
    });
    const isVisible = derivedVisible({
      open: rootOpen,
      forceVisible,
      activeTrigger: rootActiveTrigger
    });
    const menu = builder(name10("menu"), {
      stores: [isVisible, portal, m.ids.menu, m.ids.trigger, ids.menubar],
      returned: ([$isVisible, $portal, $menuId, $triggerId, $menubarId]) => {
        return {
          role: "menu",
          hidden: $isVisible ? void 0 : true,
          style: styleToString2({
            display: $isVisible ? void 0 : "none"
          }),
          id: $menuId,
          "aria-labelledby": $triggerId,
          "data-state": $isVisible ? "open" : "closed",
          "data-melt-scope": $menubarId,
          "data-portal": $portal ? "" : void 0,
          tabindex: -1
        };
      },
      action: (node) => {
        let unsubPopper = noop2;
        const unsubDerived = effect([rootOpen, rootActiveTrigger, positioning, portal], ([$rootOpen, $rootActiveTrigger, $positioning, $portal]) => {
          unsubPopper();
          if (!($rootOpen && $rootActiveTrigger))
            return;
          tick().then(() => {
            const popper = usePopper(node, {
              anchorElement: $rootActiveTrigger,
              open: rootOpen,
              options: {
                floating: $positioning,
                portal: getPortalDestination(node, $portal),
                clickOutside: {
                  ignore: (e) => {
                    const target = e.target;
                    const menubarEl = document.getElementById(get_store_value(ids.menubar));
                    if (!menubarEl || !isElement(target))
                      return false;
                    return menubarEl.contains(target);
                  },
                  handler: () => {
                    activeMenu.set("");
                  }
                }
              }
            });
            if (popper && popper.destroy) {
              unsubPopper = popper.destroy;
            }
          });
        });
        const unsubEvents = executeCallbacks2(addMeltEventListener(node, "keydown", (e) => {
          const target = e.target;
          const menuEl = e.currentTarget;
          if (!isHTMLElement2(menuEl) || !isHTMLElement2(target))
            return;
          if (MENUBAR_NAV_KEYS.includes(e.key)) {
            handleCrossMenuNavigation(e);
          }
          const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
          if (!isKeyDownInside)
            return;
          if (FIRST_LAST_KEYS.includes(e.key)) {
            handleMenuNavigation(e);
          }
          if (e.key === kbd2.TAB) {
            e.preventDefault();
            rootActiveTrigger.set(null);
            rootOpen.set(false);
            handleTabNavigation(e, nextFocusable, prevFocusable);
          }
          const isCharacterKey = e.key.length === 1;
          const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
          if (!isModifierKey && isCharacterKey) {
            m.handleTypeaheadSearch(e.key, getMenuItems(menuEl));
          }
        }));
        return {
          destroy() {
            unsubDerived();
            unsubEvents();
            unsubPopper();
          }
        };
      }
    });
    const trigger = builder(name10("trigger"), {
      stores: [rootOpen, m.ids.menu, m.ids.trigger],
      returned: ([$rootOpen, $menuId, $triggerId]) => {
        return {
          "aria-controls": $menuId,
          "aria-expanded": $rootOpen,
          "data-state": $rootOpen ? "open" : "closed",
          id: $triggerId,
          "aria-haspopup": "menu",
          "data-orientation": "horizontal",
          role: "menuitem"
        };
      },
      action: (node) => {
        applyAttrsIfDisabled(node);
        const menubarEl = document.getElementById(get_store_value(ids.menubar));
        if (!menubarEl)
          return {};
        const menubarTriggers = Array.from(menubarEl.querySelectorAll("[data-melt-menubar-trigger]"));
        if (!menubarTriggers.length)
          return {};
        const unsubEffect = effect([lastFocusedMenuTrigger], ([$lastFocusedMenuTrigger]) => {
          if (!$lastFocusedMenuTrigger && menubarTriggers[0] === node) {
            node.tabIndex = 0;
          } else if ($lastFocusedMenuTrigger === node) {
            node.tabIndex = 0;
          } else {
            node.tabIndex = -1;
          }
        });
        if (menubarTriggers[0] === node) {
          node.tabIndex = 0;
        } else {
          node.tabIndex = -1;
        }
        const unsub = executeCallbacks2(addMeltEventListener(node, "click", (e) => {
          const $rootOpen = get_store_value(rootOpen);
          const triggerEl = e.currentTarget;
          if (!isHTMLElement2(triggerEl))
            return;
          handleOpen(triggerEl);
          if (!$rootOpen)
            e.preventDefault();
        }), addMeltEventListener(node, "keydown", (e) => {
          const triggerEl = e.currentTarget;
          if (!isHTMLElement2(triggerEl))
            return;
          if (SELECTION_KEYS.includes(e.key) || e.key === kbd2.ARROW_DOWN) {
            e.preventDefault();
            handleOpen(triggerEl);
            const menuId = triggerEl.getAttribute("aria-controls");
            if (!menuId)
              return;
            const menu2 = document.getElementById(menuId);
            if (!menu2)
              return;
            const menuItems = getMenuItems(menu2);
            if (!menuItems.length)
              return;
            handleRovingFocus(menuItems[0]);
          }
        }), addMeltEventListener(node, "pointerenter", (e) => {
          const triggerEl = e.currentTarget;
          if (!isHTMLElement2(triggerEl))
            return;
          const $activeMenu = get_store_value(activeMenu);
          const $rootOpen = get_store_value(rootOpen);
          if ($activeMenu && !$rootOpen) {
            rootOpen.set(true);
            activeMenu.set(get_store_value(m.ids.menu));
            rootActiveTrigger.set(triggerEl);
          }
        }));
        return {
          destroy() {
            unsub();
            unsubEffect();
          }
        };
      }
    });
    function handleOpen(triggerEl) {
      rootOpen.update((prev2) => {
        const isOpen = !prev2;
        if (isOpen) {
          nextFocusable.set(getNextFocusable(triggerEl));
          prevFocusable.set(getPreviousFocusable(triggerEl));
          rootActiveTrigger.set(triggerEl);
          activeMenu.set(get_store_value(m.ids.menu));
        } else {
          rootActiveTrigger.set(null);
        }
        return isOpen;
      });
    }
    effect([activeMenu], ([$activeMenu]) => {
      if (!isBrowser2)
        return;
      if ($activeMenu === get_store_value(m.ids.menu)) {
        if (get_store_value(rootOpen))
          return;
        const triggerEl = document.getElementById(get_store_value(m.ids.trigger));
        if (!triggerEl)
          return;
        rootActiveTrigger.set(triggerEl);
        addHighlight(triggerEl);
        rootOpen.set(true);
        return;
      }
      if ($activeMenu !== get_store_value(m.ids.menu)) {
        if (!isBrowser2)
          return;
        if (get_store_value(rootOpen)) {
          const triggerEl = document.getElementById(get_store_value(m.ids.trigger));
          if (!triggerEl)
            return;
          rootActiveTrigger.set(null);
          rootOpen.set(false);
          removeHighlight(triggerEl);
        }
        return;
      }
    });
    effect([rootOpen], ([$rootOpen]) => {
      if (!isBrowser2)
        return;
      const triggerEl = document.getElementById(get_store_value(m.ids.trigger));
      if (!triggerEl)
        return;
      if (!$rootOpen && get_store_value(activeMenu) === get_store_value(m.ids.menu)) {
        rootActiveTrigger.set(null);
        activeMenu.set("");
        removeHighlight(triggerEl);
        return;
      }
      if ($rootOpen) {
        lastFocusedMenuTrigger.set(triggerEl);
        addHighlight(triggerEl);
      }
    });
    onMount(() => {
      if (!isBrowser2)
        return;
      const triggerEl = document.getElementById(get_store_value(m.ids.trigger));
      if (isHTMLElement2(triggerEl) && get_store_value(rootOpen)) {
        rootActiveTrigger.set(triggerEl);
      }
    });
    return {
      ids: m.ids,
      elements: {
        menu,
        trigger,
        item: m.item,
        arrow: m.arrow,
        separator: m.separator,
        group: m.group,
        groupLabel: m.groupLabel
      },
      builders: {
        createCheckboxItem: m.createCheckboxItem,
        createSubmenu: m.createSubmenu,
        createMenuRadioGroup: m.createMenuRadioGroup
      },
      states: {
        open: rootOpen
      },
      options: options2
    };
  };
  function handleCrossMenuNavigation(e) {
    if (!isBrowser2)
      return;
    e.preventDefault();
    const currentTarget = e.currentTarget;
    const target = e.target;
    if (!isHTMLElement2(target) || !isHTMLElement2(currentTarget))
      return;
    const targetIsSubTrigger = target.hasAttribute("data-melt-menubar-menu-subtrigger");
    const isKeyDownInsideSubMenu = target.closest('[role="menu"]') !== currentTarget;
    const prevMenuKey = kbd2.ARROW_LEFT;
    const isPrevKey = e.key === prevMenuKey;
    const isNextKey = !isPrevKey;
    if (isNextKey && targetIsSubTrigger)
      return;
    if (isPrevKey && isKeyDownInsideSubMenu)
      return;
    const menubarEl = document.getElementById(get_store_value(ids.menubar));
    if (!isHTMLElement2(menubarEl))
      return;
    const triggers = getMenuTriggers(menubarEl);
    const currTriggerId = currentTarget.getAttribute("aria-labelledby");
    const currIndex = triggers.findIndex((trigger) => trigger.id === currTriggerId);
    let nextIndex;
    switch (e.key) {
      case kbd2.ARROW_RIGHT:
        nextIndex = currIndex < triggers.length - 1 ? currIndex + 1 : 0;
        break;
      case kbd2.ARROW_LEFT:
        nextIndex = currIndex > 0 ? currIndex - 1 : triggers.length - 1;
        break;
      case kbd2.HOME:
        nextIndex = 0;
        break;
      case kbd2.END:
        nextIndex = triggers.length - 1;
        break;
      default:
        return;
    }
    const nextFocusedTrigger = triggers[nextIndex];
    const menuId = nextFocusedTrigger.getAttribute("aria-controls");
    menuId && activeMenu.set(menuId);
  }
  function getMenuTriggers(el) {
    const menuEl = el.closest('[role="menubar"]');
    if (!isHTMLElement2(menuEl))
      return [];
    return Array.from(menuEl.querySelectorAll("[data-melt-menubar-trigger]")).filter((el2) => isHTMLElement2(el2));
  }
  function handleMenubarNavigation(e) {
    e.preventDefault();
    const currentFocusedItem = document.activeElement;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement2(currentTarget) || !isHTMLElement2(currentFocusedItem))
      return;
    const menuTriggers = getMenuTriggers(currentTarget);
    if (!menuTriggers.length)
      return;
    const candidateNodes = menuTriggers.filter((item) => {
      if (item.hasAttribute("data-disabled")) {
        return false;
      }
      if (item.getAttribute("disabled") === "true") {
        return false;
      }
      return true;
    });
    const currentIndex = candidateNodes.indexOf(currentFocusedItem);
    let nextIndex;
    const $loop = get_store_value(loop);
    switch (e.key) {
      case kbd2.ARROW_RIGHT:
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : $loop ? 0 : currentIndex;
        break;
      case kbd2.ARROW_LEFT:
        nextIndex = currentIndex > 0 ? currentIndex - 1 : $loop ? candidateNodes.length - 1 : 0;
        break;
      case kbd2.HOME:
        nextIndex = 0;
        break;
      case kbd2.END:
        nextIndex = candidateNodes.length - 1;
        break;
      default:
        return;
    }
    handleRovingFocus(candidateNodes[nextIndex]);
  }
  onMount(() => {
    if (!isBrowser2)
      return;
    const menubarEl = document.getElementById(get_store_value(ids.menubar));
    if (!menubarEl)
      return;
    const unsubEvents = executeCallbacks2(addMeltEventListener(menubarEl, "keydown", (e) => {
      const target = e.target;
      const menuEl = e.currentTarget;
      if (!isHTMLElement2(menuEl) || !isHTMLElement2(target))
        return;
      const isTargetTrigger = target.hasAttribute("data-melt-menubar-trigger");
      if (!isTargetTrigger)
        return;
      if (MENUBAR_NAV_KEYS.includes(e.key)) {
        handleMenubarNavigation(e);
      }
    }), addEventListener2(document, "keydown", (e) => {
      if (get_store_value(closeOnEscape) && e.key === kbd2.ESCAPE) {
        window.clearTimeout(get_store_value(closeTimer));
        activeMenu.set("");
      }
    }));
    return () => {
      unsubEvents();
    };
  });
  const unsubs = [];
  effect([activeMenu], ([$activeMenu]) => {
    if (!isBrowser2)
      return;
    if (!$activeMenu) {
      unsubs.forEach((unsub) => unsub());
      scrollRemoved = false;
    } else if (!scrollRemoved) {
      unsubs.push(removeScroll());
      scrollRemoved = true;
    }
  });
  onDestroy(() => {
    unsubs.forEach((unsub) => unsub());
  });
  return {
    ids,
    elements: {
      menubar
    },
    builders: {
      createMenu
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/pagination/create.js
var { name: name11, selector: selector3 } = createElHelpers("pagination");

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/pin-input/create.js
var { name: name12, selector: selector4 } = createElHelpers("pin-input");

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/popover/create.js
var defaults14 = {
  positioning: {
    placement: "bottom"
  },
  arrowSize: 8,
  defaultOpen: false,
  disableFocusTrap: false,
  closeOnEscape: true,
  preventScroll: false,
  onOpenChange: void 0,
  closeOnOutsideClick: true,
  portal: void 0,
  forceVisible: false,
  openFocus: void 0,
  closeFocus: void 0
};
var { name: name13 } = createElHelpers("popover");
var popoverIdParts = ["trigger", "content"];
function createPopover(args) {
  const withDefaults = { ...defaults14, ...args };
  const options = toWritableStores2(omit2(withDefaults, "open", "ids"));
  const { positioning, arrowSize, disableFocusTrap, preventScroll, closeOnEscape, closeOnOutsideClick, portal, forceVisible, openFocus, closeFocus } = options;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const activeTrigger = writable(null);
  const ids = toWritableStores2({ ...generateIds(popoverIdParts), ...withDefaults.ids });
  onMount(() => {
    activeTrigger.set(document.getElementById(get_store_value(ids.trigger)));
  });
  function handleClose() {
    open.set(false);
    const triggerEl = document.getElementById(get_store_value(ids.trigger));
    handleFocus({ prop: get_store_value(closeFocus), defaultEl: triggerEl });
  }
  const isVisible = derivedVisible({ open, activeTrigger, forceVisible });
  const content = builder(name13("content"), {
    stores: [isVisible, portal, ids.content],
    returned: ([$isVisible, $portal, $contentId]) => {
      return {
        hidden: $isVisible && isBrowser2 ? void 0 : true,
        tabindex: -1,
        style: styleToString2({
          display: $isVisible ? void 0 : "none"
        }),
        id: $contentId,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": $portal ? "" : void 0
      };
    },
    action: (node) => {
      let unsubPopper = noop2;
      const unsubDerived = effect([
        isVisible,
        activeTrigger,
        positioning,
        disableFocusTrap,
        closeOnEscape,
        closeOnOutsideClick,
        portal
      ], ([$isVisible, $activeTrigger, $positioning, $disableFocusTrap, $closeOnEscape, $closeOnOutsideClick, $portal]) => {
        unsubPopper();
        if (!$isVisible || !$activeTrigger)
          return;
        const popper = usePopper(node, {
          anchorElement: $activeTrigger,
          open,
          options: {
            floating: $positioning,
            focusTrap: $disableFocusTrap ? null : {
              returnFocusOnDeactivate: false
            },
            clickOutside: $closeOnOutsideClick ? void 0 : null,
            escapeKeydown: $closeOnEscape ? {
              handler: () => {
                handleClose();
              }
            } : null,
            portal: getPortalDestination(node, $portal)
          }
        });
        if (popper && popper.destroy) {
          unsubPopper = popper.destroy;
        }
      });
      return {
        destroy() {
          unsubDerived();
          unsubPopper();
        }
      };
    }
  });
  function toggleOpen(triggerEl) {
    open.update((prev2) => {
      return !prev2;
    });
    if (triggerEl) {
      activeTrigger.set(triggerEl);
    }
  }
  const trigger = builder(name13("trigger"), {
    stores: [open, ids.content, ids.trigger],
    returned: ([$open, $contentId, $triggerId]) => {
      return {
        role: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        "data-state": $open ? "open" : "closed",
        "aria-controls": $contentId,
        id: $triggerId
      };
    },
    action: (node) => {
      const unsub = executeCallbacks2(addMeltEventListener(node, "click", () => {
        toggleOpen(node);
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd2.ENTER && e.key !== kbd2.SPACE)
          return;
        e.preventDefault();
        toggleOpen(node);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const arrow2 = builder(name13("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString2({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  const close = builder(name13("close"), {
    returned: () => ({
      type: "button"
    }),
    action: (node) => {
      const unsub = executeCallbacks2(addMeltEventListener(node, "click", (e) => {
        if (e.defaultPrevented)
          return;
        handleClose();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.defaultPrevented)
          return;
        if (e.key !== kbd2.ENTER && e.key !== kbd2.SPACE)
          return;
        e.preventDefault();
        toggleOpen();
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect([open, activeTrigger, preventScroll], ([$open, $activeTrigger, $preventScroll]) => {
    if (!isBrowser2)
      return;
    const unsubs = [];
    if ($open) {
      if (!$activeTrigger) {
        tick().then(() => {
          const triggerEl2 = document.getElementById(get_store_value(ids.trigger));
          if (!isHTMLElement2(triggerEl2))
            return;
          activeTrigger.set(triggerEl2);
        });
      }
      if ($preventScroll) {
        unsubs.push(removeScroll());
      }
      const triggerEl = $activeTrigger ?? document.getElementById(get_store_value(ids.trigger));
      handleFocus({ prop: get_store_value(openFocus), defaultEl: triggerEl });
    }
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  return {
    ids,
    elements: {
      trigger,
      content,
      arrow: arrow2,
      close
    },
    states: {
      open
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/progress/create.js
var defaults15 = {
  defaultValue: 0,
  max: 100
};
var { name: name14 } = createElHelpers("progress");
var createProgress = (props) => {
  const withDefaults = { ...defaults15, ...props };
  const options = toWritableStores2(omit2(withDefaults, "value"));
  const { max } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const root = builder(name14(), {
    stores: [value, max],
    returned: ([$value, $max]) => {
      return {
        value: $value,
        max: $max,
        role: "meter",
        "aria-valuemin": 0,
        "aria-valuemax": $max,
        "aria-valuenow": $value,
        "data-value": $value,
        "data-state": $value === null ? "indeterminate" : $value === $max ? "complete" : "loading",
        "data-max": $max
      };
    }
  });
  return {
    elements: {
      root
    },
    states: {
      value
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/radio-group/create.js
var defaults16 = {
  orientation: "vertical",
  loop: true,
  disabled: false,
  required: false,
  defaultValue: void 0
};
var { name: name15, selector: selector5 } = createElHelpers("radio-group");
function createRadioGroup(props) {
  const withDefaults = { ...defaults16, ...props };
  const options = toWritableStores2(omit2(withDefaults, "value"));
  const { disabled, required, loop, orientation } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const focusedHistory = {
    prev: null,
    curr: null
  };
  onMount(() => {
    return addEventListener2(document, "focus", (e) => {
      const focusedItem = e.target;
      if (!isHTMLElement2(focusedItem))
        return;
      focusedHistory.prev = focusedHistory.curr;
      focusedHistory.curr = focusedItem;
    });
  });
  let hasActiveTabIndex = false;
  effect(value, ($value) => {
    if ($value === void 0) {
      hasActiveTabIndex = false;
    } else {
      hasActiveTabIndex = true;
    }
  });
  const selectItem = (item2) => {
    const disabled2 = item2.dataset.disabled === "true";
    const itemValue = item2.dataset.value;
    if (disabled2 || itemValue === void 0)
      return;
    value.set(itemValue);
  };
  const root = builder(name15(), {
    stores: [required, orientation],
    returned: ([$required, $orientation]) => {
      return {
        role: "radiogroup",
        "aria-required": $required,
        "data-orientation": $orientation
      };
    }
  });
  const item = builder(name15("item"), {
    stores: [value, orientation, disabled],
    returned: ([$value, $orientation, $disabled]) => {
      return (props2) => {
        const itemValue = typeof props2 === "string" ? props2 : props2.value;
        const argDisabled = typeof props2 === "string" ? false : !!props2.disabled;
        const disabled2 = $disabled || argDisabled;
        const checked = $value === itemValue;
        const tabindex = !hasActiveTabIndex ? 0 : checked ? 0 : -1;
        hasActiveTabIndex = true;
        return {
          disabled: disabled2,
          "data-value": itemValue,
          "data-orientation": $orientation,
          "data-disabled": disabledAttr(disabled2),
          "data-state": checked ? "checked" : "unchecked",
          "aria-checked": checked,
          type: "button",
          role: "radio",
          tabindex
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks2(addMeltEventListener(node, "click", () => {
        selectItem(node);
      }), addMeltEventListener(node, "keydown", (e) => {
        const el = e.currentTarget;
        if (!isHTMLElement2(el))
          return;
        const root2 = el.closest(selector5());
        if (!isHTMLElement2(root2))
          return;
        const items = Array.from(root2.querySelectorAll(selector5("item"))).filter((el2) => isHTMLElement2(el2));
        const currentIndex = items.indexOf(el);
        const dir = getElemDirection(root2);
        const { nextKey, prevKey } = getDirectionalKeys(dir, get_store_value(orientation));
        const $loop = get_store_value(loop);
        let itemToFocus = null;
        if (e.key === nextKey) {
          e.preventDefault();
          const nextIndex = currentIndex + 1;
          if (nextIndex >= items.length && $loop) {
            itemToFocus = items[0];
          } else {
            itemToFocus = items[nextIndex];
          }
        } else if (e.key === prevKey) {
          e.preventDefault();
          const prevIndex = currentIndex - 1;
          if (prevIndex < 0 && $loop) {
            itemToFocus = items[items.length - 1];
          } else {
            itemToFocus = items[prevIndex];
          }
        } else if (e.key === kbd2.HOME) {
          e.preventDefault();
          itemToFocus = items[0];
        } else if (e.key === kbd2.END) {
          e.preventDefault();
          itemToFocus = items[items.length - 1];
        }
        if (itemToFocus) {
          itemToFocus.focus();
          selectItem(itemToFocus);
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const hiddenInput = builder(name15("hidden-input"), {
    stores: [disabled, value, required],
    returned: ([$disabled, $value, $required]) => {
      return {
        ...hiddenInputAttrs,
        disabled: disabledAttr($disabled),
        value: $value,
        required: $required
      };
    },
    action: (_node) => {
      _node;
    }
  });
  const isChecked = derived(value, ($value) => {
    return (itemValue) => {
      return $value === itemValue;
    };
  });
  return {
    elements: {
      root,
      item,
      hiddenInput
    },
    states: {
      value
    },
    helpers: {
      isChecked
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/range-calendar/create.js
var { name: name16 } = createElHelpers("calendar");

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/select/create.js
var { name: name17 } = createElHelpers("select");
function createSelect(props) {
  const listbox = createListbox({ ...props, builder: "select" });
  const group = builder(name17("group"), {
    returned: () => {
      return (groupId) => ({
        role: "group",
        "aria-labelledby": groupId
      });
    }
  });
  const groupLabel = builder(name17("group-label"), {
    returned: () => {
      return (groupId) => ({
        id: groupId
      });
    }
  });
  const selectedLabel = derived(listbox.states.selected, ($selected) => {
    if (Array.isArray($selected)) {
      return $selected.map((o) => o.label).join(", ");
    }
    return ($selected == null ? void 0 : $selected.label) ?? "";
  });
  return {
    ...listbox,
    elements: {
      ...listbox.elements,
      group,
      groupLabel
    },
    states: {
      ...listbox.states,
      selectedLabel
    }
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/separator/create.js
var defaults17 = {
  orientation: "horizontal",
  decorative: false
};
var createSeparator = (props) => {
  const withDefaults = { ...defaults17, ...props };
  const options = toWritableStores2(withDefaults);
  const { orientation, decorative } = options;
  const root = builder("separator", {
    stores: [orientation, decorative],
    returned: ([$orientation, $decorative]) => {
      const ariaOrientation = $orientation === "vertical" ? $orientation : void 0;
      return {
        role: $decorative ? "none" : "separator",
        "aria-orientation": ariaOrientation,
        "aria-hidden": $decorative,
        "data-orientation": $orientation
      };
    }
  });
  return {
    elements: {
      root
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/slider/create.js
var defaults18 = {
  defaultValue: [],
  min: 0,
  max: 100,
  step: 1,
  orientation: "horizontal",
  disabled: false
};
var { name: name18 } = createElHelpers("slider");
var createSlider = (props) => {
  const withDefaults = { ...defaults18, ...props };
  const options = toWritableStores2(omit2(withDefaults, "value", "onValueChange", "defaultValue"));
  const { min, max, step, orientation, disabled } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const isActive = writable(false);
  const currentThumbIndex = writable(0);
  const activeThumb = writable(null);
  const meltIds = generateIds(["root"]);
  const updatePosition = (val, index) => {
    value.update((prev2) => {
      if (!prev2)
        return [val];
      const newValue = [...prev2];
      const direction = newValue[index] > val ? -1 : 1;
      function swap() {
        newValue[index] = newValue[index + direction];
        newValue[index + direction] = val;
        const thumbs = getAllThumbs();
        if (thumbs) {
          thumbs[index + direction].focus();
          activeThumb.set({ thumb: thumbs[index + direction], index: index + direction });
        }
      }
      if (direction === -1 && val < newValue[index - 1]) {
        swap();
        return newValue;
      } else if (direction === 1 && val > newValue[index + 1]) {
        swap();
        return newValue;
      }
      const $min = get_store_value(min);
      const $max = get_store_value(max);
      const $step = get_store_value(step);
      newValue[index] = snapValueToStep(val, $min, $max, $step);
      return newValue;
    });
  };
  const getAllThumbs = () => {
    const root2 = getElementByMeltId(meltIds.root);
    if (!root2)
      return null;
    return Array.from(root2.querySelectorAll('[data-melt-part="thumb"]')).filter((thumb2) => isHTMLElement2(thumb2));
  };
  const position = derived([min, max], ([$min, $max]) => {
    return (val) => {
      const pos = (val - $min) / ($max - $min) * 100;
      return pos;
    };
  });
  const ticks = derived([min, max, step], ([$min, $max, $step]) => {
    const difference = $max - $min;
    let count = Math.ceil(difference / $step);
    if (difference % $step == 0) {
      count++;
    }
    return count;
  });
  const root = builder(name18(), {
    stores: [disabled, orientation],
    returned: ([$disabled, $orientation]) => {
      return {
        disabled: disabledAttr($disabled),
        "aria-disabled": ariaDisabledAttr($disabled),
        "data-orientation": $orientation,
        style: $disabled ? void 0 : "touch-action: none;",
        "data-melt-id": meltIds.root
      };
    }
  });
  const range = builder(name18("range"), {
    stores: [value, orientation, position],
    returned: ([$value, $orientation, $position]) => {
      const minimum = $value.length > 1 ? $position(Math.min(...$value) ?? 0) : 0;
      const maximum = 100 - $position(Math.max(...$value) ?? 0);
      const orientationStyles = $orientation === "horizontal" ? { left: `${minimum}%`, right: `${maximum}%` } : { top: `${maximum}%`, bottom: `${minimum}%` };
      return {
        style: styleToString2({
          position: "absolute",
          ...orientationStyles
        })
      };
    }
  });
  const thumb = builder(name18("thumb"), {
    stores: [value, position, min, max, disabled, orientation],
    returned: ([$value, $position, $min, $max, $disabled, $orientation]) => {
      let index = -1;
      return () => {
        index++;
        const currentThumb = get_store_value(currentThumbIndex);
        if (currentThumb < $value.length) {
          currentThumbIndex.update((prev2) => prev2 + 1);
        }
        const thumbPosition = `${$position($value[index])}%`;
        return {
          role: "slider",
          "aria-valuemin": $min,
          "aria-valuemax": $max,
          "aria-valuenow": $value[index],
          "data-melt-part": "thumb",
          style: styleToString2({
            position: "absolute",
            ...$orientation === "horizontal" ? { left: thumbPosition, translate: "-50% 0" } : { bottom: thumbPosition, translate: "0 50%" }
          }),
          tabindex: $disabled ? -1 : 0
        };
      };
    },
    action: (node) => {
      const unsub = addMeltEventListener(node, "keydown", (event) => {
        const $min = get_store_value(min);
        const $max = get_store_value(max);
        if (get_store_value(disabled))
          return;
        const target = event.currentTarget;
        if (!isHTMLElement2(target))
          return;
        const thumbs = getAllThumbs();
        if (!(thumbs == null ? void 0 : thumbs.length))
          return;
        const index = thumbs.indexOf(target);
        currentThumbIndex.set(index);
        if (![
          kbd2.ARROW_LEFT,
          kbd2.ARROW_RIGHT,
          kbd2.ARROW_UP,
          kbd2.ARROW_DOWN,
          kbd2.HOME,
          kbd2.END
        ].includes(event.key)) {
          return;
        }
        event.preventDefault();
        const $step = get_store_value(step);
        const $value = get_store_value(value);
        const $orientation = get_store_value(orientation);
        switch (event.key) {
          case kbd2.HOME: {
            updatePosition($min, index);
            break;
          }
          case kbd2.END: {
            updatePosition($max, index);
            break;
          }
          case kbd2.ARROW_LEFT: {
            if ($orientation !== "horizontal")
              break;
            if (event.metaKey) {
              updatePosition($min, index);
            } else if ($value[index] > $min) {
              const newValue = $value[index] - $step;
              updatePosition(newValue, index);
            }
            break;
          }
          case kbd2.ARROW_RIGHT: {
            if ($orientation !== "horizontal")
              break;
            if (event.metaKey) {
              updatePosition($max, index);
            } else if ($value[index] < $max) {
              const newValue = $value[index] + $step;
              if (newValue <= $max) {
                updatePosition(newValue, index);
              }
            }
            break;
          }
          case kbd2.ARROW_UP: {
            if (event.metaKey) {
              updatePosition($max, index);
            } else if ($value[index] > $min && $orientation === "vertical") {
              const newValue = $value[index] + $step;
              updatePosition(newValue, index);
            } else if ($value[index] < $max) {
              const newValue = $value[index] + $step;
              if (newValue <= $max) {
                updatePosition(newValue, index);
              }
            }
            break;
          }
          case kbd2.ARROW_DOWN: {
            if (event.metaKey) {
              updatePosition($min, index);
            } else if ($value[index] < $max && $orientation === "vertical") {
              const newValue = $value[index] - $step;
              updatePosition(newValue, index);
            } else if ($value[index] > $min) {
              const newValue = $value[index] - $step;
              updatePosition(newValue, index);
            }
            break;
          }
        }
      });
      return {
        destroy: unsub
      };
    }
  });
  const tick2 = builder(name18("tick"), {
    stores: [ticks, value, min, max, step, orientation],
    returned: ([$ticks, $value, $min, $max, $step, $orientation]) => {
      let index = -1;
      return () => {
        index++;
        const horizontal = $orientation === "horizontal";
        const style = {
          position: "absolute"
        };
        const positionPercentage = index * ($step / ($max - $min)) * 100;
        style[horizontal ? "left" : "bottom"] = `${positionPercentage}%`;
        if (index === $ticks - 1) {
          style.translate = horizontal ? "-100% 0" : "0 100%";
        } else if (index !== 0) {
          style.translate = horizontal ? "-50% 0" : "0 50%";
        }
        const tickValue = $min + index * $step;
        const bounded = $value.length === 1 ? tickValue <= $value[0] : $value[0] <= tickValue && tickValue <= $value[$value.length - 1];
        return {
          "data-bounded": bounded ? true : void 0,
          style: styleToString2(style)
        };
      };
    }
  });
  effect([root, min, max, disabled, orientation, step], ([$root, $min, $max, $disabled, $orientation, $step]) => {
    if (!isBrowser2 || $disabled)
      return;
    const applyPosition = (clientXY, activeThumbIdx, leftOrBottom, rightOrTop) => {
      const percent = (clientXY - leftOrBottom) / (rightOrTop - leftOrBottom);
      const val = percent * ($max - $min) + $min;
      if (val < $min) {
        updatePosition($min, activeThumbIdx);
      } else if (val > $max) {
        updatePosition($max, activeThumbIdx);
      } else {
        const step2 = $step;
        const min2 = $min;
        const currentStep = Math.floor((val - min2) / step2);
        const midpointOfCurrentStep = min2 + currentStep * step2 + step2 / 2;
        const midpointOfNextStep = min2 + (currentStep + 1) * step2 + step2 / 2;
        const newValue = val >= midpointOfCurrentStep && val < midpointOfNextStep ? (currentStep + 1) * step2 + min2 : currentStep * step2 + min2;
        if (newValue <= $max) {
          updatePosition(newValue, activeThumbIdx);
        }
      }
    };
    const getClosestThumb = (e) => {
      const thumbs = getAllThumbs();
      if (!thumbs)
        return;
      thumbs.forEach((thumb3) => thumb3.blur());
      const distances = thumbs.map((thumb3) => {
        if ($orientation === "horizontal") {
          const { left, right } = thumb3.getBoundingClientRect();
          return Math.abs(e.clientX - (left + right) / 2);
        } else {
          const { top, bottom } = thumb3.getBoundingClientRect();
          return Math.abs(e.clientY - (top + bottom) / 2);
        }
      });
      const thumb2 = thumbs[distances.indexOf(Math.min(...distances))];
      const index = thumbs.indexOf(thumb2);
      return { thumb: thumb2, index };
    };
    const pointerDown = (e) => {
      if (e.button !== 0)
        return;
      const sliderEl = getElementByMeltId($root["data-melt-id"]);
      const closestThumb = getClosestThumb(e);
      if (!closestThumb || !sliderEl)
        return;
      const target = e.target;
      if (!isHTMLElement2(target) || !sliderEl.contains(target))
        return;
      e.preventDefault();
      activeThumb.set(closestThumb);
      closestThumb.thumb.focus();
      isActive.set(true);
      if ($orientation === "horizontal") {
        const { left, right } = sliderEl.getBoundingClientRect();
        applyPosition(e.clientX, closestThumb.index, left, right);
      } else {
        const { top, bottom } = sliderEl.getBoundingClientRect();
        applyPosition(e.clientY, closestThumb.index, bottom, top);
      }
    };
    const pointerUp = () => {
      isActive.set(false);
    };
    const pointerMove = (e) => {
      if (!get_store_value(isActive))
        return;
      const sliderEl = getElementByMeltId($root["data-melt-id"]);
      const closestThumb = get_store_value(activeThumb);
      if (!sliderEl || !closestThumb)
        return;
      closestThumb.thumb.focus();
      if ($orientation === "horizontal") {
        const { left, right } = sliderEl.getBoundingClientRect();
        applyPosition(e.clientX, closestThumb.index, left, right);
      } else {
        const { top, bottom } = sliderEl.getBoundingClientRect();
        applyPosition(e.clientY, closestThumb.index, bottom, top);
      }
    };
    const unsub = executeCallbacks2(addEventListener2(document, "pointerdown", pointerDown), addEventListener2(document, "pointerup", pointerUp), addEventListener2(document, "pointerleave", pointerUp), addEventListener2(document, "pointermove", pointerMove));
    return () => {
      unsub();
    };
  });
  effect([step, min, max, value], function fixValue([$step, $min, $max, $value]) {
    const isValidValue = (v) => {
      const snappedValue = snapValueToStep(v, $min, $max, $step);
      return snappedValue === v;
    };
    const gcv = (v) => {
      return snapValueToStep(v, $min, $max, $step);
    };
    if ($value.some((v) => !isValidValue(v))) {
      value.update((prev2) => {
        return [...prev2].map(gcv);
      });
    }
  });
  return {
    elements: {
      root,
      thumb,
      range,
      tick: tick2
    },
    states: {
      value,
      ticks
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/switch/create.js
var defaults19 = {
  defaultChecked: false,
  disabled: false,
  required: false,
  name: "",
  value: ""
};
var { name: name19 } = createElHelpers("switch");
function createSwitch(props) {
  const propsWithDefaults = { ...defaults19, ...props };
  const options = toWritableStores2(omit2(propsWithDefaults, "checked"));
  const { disabled, required, name: nameStore, value } = options;
  const checkedWritable = propsWithDefaults.checked ?? writable(propsWithDefaults.defaultChecked);
  const checked = overridable(checkedWritable, propsWithDefaults == null ? void 0 : propsWithDefaults.onCheckedChange);
  function toggleSwitch() {
    if (get_store_value(disabled))
      return;
    checked.update((prev2) => !prev2);
  }
  const root = builder(name19(), {
    stores: [checked, disabled, required],
    returned: ([$checked, $disabled, $required]) => {
      return {
        "data-disabled": disabledAttr($disabled),
        disabled: disabledAttr($disabled),
        "data-state": $checked ? "checked" : "unchecked",
        type: "button",
        role: "switch",
        "aria-checked": $checked ? "true" : "false",
        "aria-required": $required ? "true" : void 0
      };
    },
    action(node) {
      const unsub = executeCallbacks2(addMeltEventListener(node, "click", () => {
        toggleSwitch();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd2.ENTER && e.key !== kbd2.SPACE)
          return;
        e.preventDefault();
        toggleSwitch();
      }));
      return {
        destroy: unsub
      };
    }
  });
  const input = builder(name19("input"), {
    stores: [checked, nameStore, required, disabled, value],
    returned: ([$checked, $name, $required, $disabled, $value]) => {
      return {
        type: "checkbox",
        "aria-hidden": true,
        hidden: true,
        tabindex: -1,
        name: $name,
        value: $value,
        checked: $checked,
        required: $required,
        disabled: disabledAttr($disabled),
        style: styleToString2({
          position: "absolute",
          opacity: 0,
          "pointer-events": "none",
          margin: 0,
          transform: "translateX(-100%)"
        })
      };
    }
  });
  return {
    elements: {
      root,
      input
    },
    states: {
      checked
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/tabs/create.js
var defaults20 = {
  orientation: "horizontal",
  activateOnFocus: true,
  loop: true,
  autoSet: true
};
var { name: name20, selector: selector6 } = createElHelpers("tabs");
function createTabs(props) {
  const withDefaults = { ...defaults20, ...props };
  const options = toWritableStores2(omit2(withDefaults, "defaultValue", "value", "onValueChange", "autoSet"));
  const { orientation, activateOnFocus, loop } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  let ssrValue = withDefaults.defaultValue ?? get_store_value(value);
  const root = builder(name20(), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        "data-orientation": $orientation
      };
    }
  });
  const list = builder(name20("list"), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        role: "tablist",
        "aria-orientation": $orientation,
        "data-orientation": $orientation
      };
    }
  });
  const parseTriggerProps = (props2) => {
    if (typeof props2 === "string") {
      return { value: props2 };
    } else {
      return props2;
    }
  };
  const trigger = builder(name20("trigger"), {
    stores: [value, orientation],
    returned: ([$value, $orientation]) => {
      return (props2) => {
        const { value: tabValue, disabled } = parseTriggerProps(props2);
        if (!$value && !ssrValue && withDefaults.autoSet) {
          ssrValue = tabValue;
          $value = tabValue;
          value.set(tabValue);
        }
        const sourceOfTruth = isBrowser2 ? $value : ssrValue;
        const isActive = sourceOfTruth === tabValue;
        return {
          type: "button",
          role: "tab",
          "data-state": isActive ? "active" : "inactive",
          tabindex: isActive ? 0 : -1,
          "data-value": tabValue,
          "data-orientation": $orientation,
          "data-disabled": disabledAttr(disabled),
          disabled: disabledAttr(disabled)
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks2(addMeltEventListener(node, "focus", () => {
        const disabled = node.dataset.disabled === "true";
        const tabValue = node.dataset.value;
        if (get_store_value(activateOnFocus) && !disabled && tabValue !== void 0) {
          value.set(tabValue);
        }
      }), addMeltEventListener(node, "click", (e) => {
        node.focus();
        e.preventDefault();
        const disabled = node.dataset.disabled === "true";
        if (disabled)
          return;
        const tabValue = node.dataset.value;
        node.focus();
        if (tabValue !== void 0) {
          value.set(tabValue);
        }
      }), addMeltEventListener(node, "keydown", (e) => {
        const tabValue = node.dataset.value;
        if (!tabValue)
          return;
        const el = e.currentTarget;
        if (!isHTMLElement2(el))
          return;
        const rootEl = el.closest(selector6());
        if (!isHTMLElement2(rootEl))
          return;
        const $loop = get_store_value(loop);
        const triggers = Array.from(rootEl.querySelectorAll('[role="tab"]')).filter((trigger2) => isHTMLElement2(trigger2));
        const enabledTriggers = triggers.filter((el2) => !el2.hasAttribute("data-disabled"));
        const triggerIdx = enabledTriggers.findIndex((el2) => el2 === e.target);
        const dir = getElemDirection(rootEl);
        const { nextKey, prevKey } = getDirectionalKeys(dir, get_store_value(orientation));
        if (e.key === nextKey) {
          e.preventDefault();
          const nextEl = next(enabledTriggers, triggerIdx, $loop);
          nextEl.focus();
        } else if (e.key === prevKey) {
          e.preventDefault();
          const prevEl = prev(enabledTriggers, triggerIdx, $loop);
          prevEl.focus();
        } else if (e.key === kbd2.ENTER || e.key === kbd2.SPACE) {
          e.preventDefault();
          value.set(tabValue);
        } else if (e.key === kbd2.HOME) {
          e.preventDefault();
          const firstTrigger = enabledTriggers[0];
          firstTrigger.focus();
        } else if (e.key === kbd2.END) {
          e.preventDefault();
          const lastTrigger = last(enabledTriggers);
          lastTrigger.focus();
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const content = builder(name20("content"), {
    stores: value,
    returned: ($value) => {
      return (tabValue) => {
        return {
          role: "tabpanel",
          // TODO: improve
          "aria-labelledby": tabValue,
          hidden: isBrowser2 ? $value === tabValue ? void 0 : true : ssrValue === tabValue ? void 0 : true,
          tabindex: 0
        };
      };
    }
  });
  return {
    elements: {
      root,
      list,
      trigger,
      content
    },
    states: {
      value
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/tags-input/create.js
var { name: name21, attribute, selector: selector7 } = createElHelpers("tags-input");

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/toast/create.js
var { name: name22 } = createElHelpers("toast");

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/toggle/create.js
var defaults21 = {
  defaultPressed: false,
  disabled: false
};
function createToggle(props) {
  const withDefaults = { ...defaults21, ...props };
  const options = toWritableStores2(omit2(withDefaults, "pressed"));
  const { disabled } = options;
  const pressedWritable = withDefaults.pressed ?? writable(withDefaults.defaultPressed);
  const pressed = overridable(pressedWritable, withDefaults == null ? void 0 : withDefaults.onPressedChange);
  function handleToggle() {
    const $disabled = get_store_value(disabled);
    if ($disabled)
      return;
    pressed.update((v) => !v);
  }
  const root = builder("toggle", {
    stores: [pressed, disabled],
    returned: ([$pressed, $disabled]) => {
      return {
        "data-disabled": disabledAttr($disabled),
        disabled: disabledAttr($disabled),
        "data-state": $pressed ? "on" : "off",
        "aria-pressed": $pressed,
        type: "button"
      };
    },
    action: (node) => {
      const unsub = executeCallbacks2(addMeltEventListener(node, "click", () => {
        handleToggle();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd2.ENTER && e.key !== kbd2.SPACE)
          return;
        e.preventDefault();
        handleToggle();
      }));
      return {
        destroy: unsub
      };
    }
  });
  return {
    elements: {
      root
    },
    states: {
      pressed
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/toggle-group/create.js
var defaults22 = {
  type: "single",
  orientation: "horizontal",
  loop: true,
  rovingFocus: true,
  disabled: false,
  defaultValue: ""
};
var { name: name23, selector: selector8 } = createElHelpers("toggle-group");
var createToggleGroup = (props) => {
  const withDefaults = { ...defaults22, ...props };
  const options = toWritableStores2(omit2(withDefaults, "value"));
  const { type, orientation, loop, rovingFocus, disabled } = options;
  const defaultValue = withDefaults.defaultValue ? withDefaults.defaultValue : withDefaults.type === "single" ? "undefined" : [];
  const valueWritable = withDefaults.value ?? writable(defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const root = builder(name23(), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        role: "group",
        "data-orientation": $orientation
      };
    }
  });
  const item = builder(name23("item"), {
    stores: [value, disabled, orientation, type],
    returned: ([$value, $disabled, $orientation, $type]) => {
      return (props2) => {
        const itemValue = typeof props2 === "string" ? props2 : props2.value;
        const argDisabled = typeof props2 === "string" ? false : !!props2.disabled;
        const disabled2 = $disabled || argDisabled;
        const pressed = Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;
        const isSingle = $type === "single";
        const isMultiple = $type === "multiple" || $type === void 0;
        return {
          disabled: disabledAttr(disabled2),
          pressed,
          "data-orientation": $orientation,
          "data-disabled": disabledAttr(disabled2),
          "data-state": pressed ? "on" : "off",
          "data-value": itemValue,
          "aria-pressed": isMultiple ? pressed : void 0,
          "aria-checked": isSingle ? pressed : void 0,
          type: "button",
          role: isSingle ? "radio" : void 0,
          tabindex: pressed ? 0 : -1
        };
      };
    },
    action: (node) => {
      let unsub = noop2;
      const parentGroup = node.closest(selector8());
      if (!isHTMLElement2(parentGroup))
        return {};
      const items = Array.from(parentGroup.querySelectorAll(selector8("item")));
      const $value = get_store_value(value);
      const anyPressed = Array.isArray($value) ? $value.length > 0 : $value !== null;
      if (!anyPressed && items[0] === node) {
        node.tabIndex = 0;
      }
      function getNodeProps() {
        const itemValue = node.dataset.value;
        const disabled2 = node.dataset.disabled === "true";
        return { value: itemValue, disabled: disabled2 };
      }
      function handleValueUpdate() {
        const { value: itemValue, disabled: disabled2 } = getNodeProps();
        if (itemValue === void 0 || disabled2)
          return;
        value.update(($value2) => {
          if (Array.isArray($value2)) {
            if ($value2.includes(itemValue)) {
              return $value2.filter((i) => i !== itemValue);
            }
            $value2.push(itemValue);
            return $value2;
          }
          return $value2 === itemValue ? void 0 : itemValue;
        });
      }
      unsub = executeCallbacks2(addMeltEventListener(node, "click", () => {
        handleValueUpdate();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key === kbd2.SPACE || e.key === kbd2.ENTER) {
          e.preventDefault();
          handleValueUpdate();
          return;
        }
        if (!get_store_value(rovingFocus))
          return;
        const el = e.currentTarget;
        if (!isHTMLElement2(el))
          return;
        const root2 = el.closest(selector8());
        if (!isHTMLElement2(root2))
          return;
        const items2 = Array.from(root2.querySelectorAll(selector8("item") + ":not([data-disabled])")).filter((item2) => isHTMLElement2(item2));
        const currentIndex = items2.indexOf(el);
        const dir = getElemDirection(el);
        const $orientation = get_store_value(orientation);
        const nextKey = {
          horizontal: dir === "rtl" ? kbd2.ARROW_LEFT : kbd2.ARROW_RIGHT,
          vertical: kbd2.ARROW_DOWN
        }[$orientation ?? "horizontal"];
        const prevKey = {
          horizontal: dir === "rtl" ? kbd2.ARROW_RIGHT : kbd2.ARROW_LEFT,
          vertical: kbd2.ARROW_UP
        }[$orientation ?? "horizontal"];
        const $loop = get_store_value(loop);
        if (e.key === nextKey) {
          e.preventDefault();
          const nextIndex = currentIndex + 1;
          if (nextIndex >= items2.length && $loop) {
            handleRovingFocus(items2[0]);
          } else {
            handleRovingFocus(items2[nextIndex]);
          }
        } else if (e.key === prevKey) {
          e.preventDefault();
          const prevIndex = currentIndex - 1;
          if (prevIndex < 0 && $loop) {
            handleRovingFocus(items2[items2.length - 1]);
          } else {
            handleRovingFocus(items2[prevIndex]);
          }
        } else if (e.key === kbd2.HOME) {
          e.preventDefault();
          handleRovingFocus(items2[0]);
        } else if (e.key === kbd2.END) {
          e.preventDefault();
          handleRovingFocus(items2[items2.length - 1]);
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const isPressed = derived(value, ($value) => {
    return (itemValue) => {
      return Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;
    };
  });
  return {
    elements: {
      root,
      item
    },
    states: {
      value
    },
    helpers: {
      isPressed
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/toolbar/create.js
var { name: name24, selector: selector9 } = createElHelpers("toolbar");

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/tooltip/create.js
var defaults23 = {
  positioning: {
    placement: "bottom"
  },
  arrowSize: 8,
  defaultOpen: false,
  closeOnPointerDown: true,
  openDelay: 1e3,
  closeDelay: 0,
  forceVisible: false,
  portal: "body",
  closeOnEscape: true,
  disableHoverableContent: false,
  group: void 0
};
var { name: name25 } = createElHelpers("tooltip");
var groupMap = /* @__PURE__ */ new Map();
var tooltipIdParts = ["trigger", "content"];
function createTooltip(props) {
  const withDefaults = { ...defaults23, ...props };
  const options = toWritableStores2(omit2(withDefaults, "open", "ids"));
  const { positioning, arrowSize, closeOnPointerDown, openDelay, closeDelay, forceVisible, portal, closeOnEscape, disableHoverableContent, group } = options;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const openReason = writable(null);
  const ids = toWritableStores2({ ...generateIds(tooltipIdParts), ...withDefaults.ids });
  let clickedTrigger = false;
  const getEl = (part) => {
    if (!isBrowser2)
      return null;
    return document.getElementById(get_store_value(ids[part]));
  };
  let openTimeout = null;
  let closeTimeout = null;
  function openTooltip(reason) {
    if (closeTimeout) {
      window.clearTimeout(closeTimeout);
      closeTimeout = null;
    }
    if (!openTimeout) {
      openTimeout = window.setTimeout(() => {
        open.set(true);
        openReason.update((prev2) => prev2 ?? reason);
        openTimeout = null;
      }, get_store_value(openDelay));
    }
  }
  function closeTooltip(isBlur) {
    if (openTimeout) {
      window.clearTimeout(openTimeout);
      openTimeout = null;
    }
    if (isBlur && isMouseInTooltipArea) {
      openReason.set("pointer");
      return;
    }
    if (!closeTimeout) {
      closeTimeout = window.setTimeout(() => {
        open.set(false);
        openReason.set(null);
        if (isBlur)
          clickedTrigger = false;
        closeTimeout = null;
      }, get_store_value(closeDelay));
    }
  }
  const trigger = builder(name25("trigger"), {
    stores: [ids.content, ids.trigger],
    returned: ([$contentId, $triggerId]) => {
      return {
        "aria-describedby": $contentId,
        id: $triggerId
      };
    },
    action: (node) => {
      const keydownHandler = (e) => {
        if (get_store_value(closeOnEscape) && e.key === kbd2.ESCAPE) {
          if (openTimeout) {
            window.clearTimeout(openTimeout);
            openTimeout = null;
          }
          open.set(false);
        }
      };
      const unsub = executeCallbacks2(addMeltEventListener(node, "pointerdown", () => {
        const $closeOnPointerDown = get_store_value(closeOnPointerDown);
        if (!$closeOnPointerDown)
          return;
        open.set(false);
        clickedTrigger = true;
        if (openTimeout) {
          window.clearTimeout(openTimeout);
          openTimeout = null;
        }
      }), addMeltEventListener(node, "pointerenter", (e) => {
        if (isTouch(e))
          return;
        openTooltip("pointer");
      }), addMeltEventListener(node, "pointerleave", (e) => {
        if (isTouch(e))
          return;
        if (openTimeout) {
          window.clearTimeout(openTimeout);
          openTimeout = null;
        }
      }), addMeltEventListener(node, "focus", () => {
        if (clickedTrigger)
          return;
        openTooltip("focus");
      }), addMeltEventListener(node, "blur", () => closeTooltip(true)), addMeltEventListener(node, "keydown", keydownHandler), addEventListener2(document, "keydown", keydownHandler));
      return {
        destroy: unsub
      };
    }
  });
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {
    return $open || $forceVisible;
  });
  const content = builder(name25("content"), {
    stores: [isVisible, portal, ids.content],
    returned: ([$isVisible, $portal, $contentId]) => {
      return {
        role: "tooltip",
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString2({
          display: $isVisible ? void 0 : "none"
        }),
        id: $contentId,
        "data-portal": $portal ? "" : void 0
      };
    },
    action: (node) => {
      let unsubFloating = noop2;
      let unsubPortal = noop2;
      const unsubDerived = effect([isVisible, positioning, portal], ([$isVisible, $positioning, $portal]) => {
        const triggerEl = getEl("trigger");
        if (!$isVisible || !triggerEl) {
          unsubPortal();
          unsubFloating();
          return;
        }
        const floatingReturn = useFloating(triggerEl, node, $positioning);
        unsubFloating = floatingReturn.destroy;
        if (!$portal) {
          unsubPortal();
          return;
        }
        const portalDest = getPortalDestination(node, $portal);
        if (portalDest) {
          const portalReturn = usePortal(node, portalDest);
          if (portalReturn && portalReturn.destroy) {
            unsubPortal = portalReturn.destroy;
          }
        }
      });
      const unsubEvents = executeCallbacks2(addMeltEventListener(node, "pointerenter", () => openTooltip("pointer")), addMeltEventListener(node, "pointerdown", () => openTooltip("pointer")));
      return {
        destroy() {
          unsubEvents();
          unsubPortal();
          unsubFloating();
          unsubDerived();
        }
      };
    }
  });
  const arrow2 = builder(name25("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString2({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  let isMouseInTooltipArea = false;
  effect(open, ($open) => {
    const currentGroup = get_store_value(group);
    if (currentGroup === void 0 || currentGroup === false) {
      return;
    }
    if (!$open) {
      if (groupMap.get(currentGroup) === open) {
        groupMap.delete(currentGroup);
      }
      return;
    }
    const currentOpen = groupMap.get(currentGroup);
    currentOpen == null ? void 0 : currentOpen.set(false);
    groupMap.set(currentGroup, open);
  });
  effect([open, openReason], ([$open, $openReason]) => {
    if (!$open || !isBrowser2)
      return;
    return executeCallbacks2(addEventListener2(document, "mousemove", (e) => {
      const contentEl = getEl("content");
      const triggerEl = getEl("trigger");
      if (!contentEl || !triggerEl)
        return;
      const polygonElements = get_store_value(disableHoverableContent) ? [triggerEl] : [triggerEl, contentEl];
      const polygon = makeHullFromElements(polygonElements);
      isMouseInTooltipArea = pointInPolygon({
        x: e.clientX,
        y: e.clientY
      }, polygon);
      if ($openReason !== "pointer")
        return;
      if (!isMouseInTooltipArea) {
        closeTooltip();
      }
    }));
  });
  return {
    ids,
    elements: {
      trigger,
      content,
      arrow: arrow2
    },
    states: { open },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.61.2_svelte@4.2.19/node_modules/@melt-ui/svelte/dist/builders/tree/create.js
var { name: name26 } = createElHelpers("tree-view");

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/internal/attrs.js
function createBitAttrs(bit, parts) {
  const attrs = {};
  parts.forEach((part) => {
    attrs[part] = {
      [`data-bits-${bit}-${part}`]: ""
    };
  });
  return (part) => attrs[part];
}
function disabledAttrs(disabled) {
  return disabled ? { "aria-disabled": true, "data-disabled": "" } : {};
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/internal/events.js
function createDispatcher() {
  const dispatch = createEventDispatcher();
  return (e) => {
    const { originalEvent } = e.detail;
    const { cancelable } = e;
    const type = originalEvent.type;
    const shouldContinue = dispatch(type, { originalEvent, currentTarget: originalEvent.currentTarget }, { cancelable });
    if (!shouldContinue) {
      e.preventDefault();
    }
  };
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/internal/id.js
function generateId3() {
  return nanoid(10);
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/internal/object.js
function removeUndefined2(obj) {
  const result = {};
  for (const key in obj) {
    const value = obj[key];
    if (value !== void 0) {
      result[key] = value;
    }
  }
  return result;
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/internal/style.js
function styleToString3(style) {
  return Object.keys(style).reduce((str, key) => {
    if (style[key] === void 0)
      return str;
    return str + `${key}:${style[key]};`;
  }, "");
}
var srOnlyStyles2 = styleToString3({
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0"
});
var hiddenInputStyles = styleToString3({
  position: "absolute",
  width: "25px",
  height: "25px",
  opacity: "0",
  margin: "0px",
  pointerEvents: "none",
  transform: "translateX(-100%)"
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/internal/updater.js
function getOptionUpdater(options) {
  return function(key, value) {
    if (value === void 0)
      return;
    const store = options[key];
    if (store) {
      store.set(value);
    }
  };
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/accordion/ctx.js
var NAME2 = "accordion";
var ITEM_NAME = "accordion-item";
var PARTS = ["root", "content", "header", "item", "trigger"];
var getAttrs = createBitAttrs(NAME2, PARTS);
function setCtx(props) {
  const accordion = createAccordion(removeUndefined2(props));
  setContext(NAME2, accordion);
  return {
    ...accordion,
    updateOption: getOptionUpdater(accordion.options)
  };
}
function getCtx2() {
  return getContext(NAME2);
}
function setItem(props) {
  setContext(ITEM_NAME, { ...props });
  const { elements: { item } } = getCtx2();
  return { item, props };
}
function getItemProps() {
  const itemProps = getContext(ITEM_NAME);
  return itemProps;
}
function getContent() {
  const { elements: { content }, helpers: { isSelected }, states: { value } } = getCtx2();
  const { value: props } = getItemProps();
  return { content, props, isSelected, value };
}
function getTrigger() {
  const { elements: { trigger } } = getCtx2();
  const { value: props } = getItemProps();
  return { props, trigger };
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/accordion/components/Accordion.svelte
var file2 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/accordion/components/Accordion.svelte";
var get_default_slot_changes_12 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_12 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes2 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context2 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block2(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context_12
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file2, 37, 1, 745);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1026)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes_12
            ),
            get_default_slot_context_12
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(37:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1026)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(35:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["multiple", "value", "onValueChange", "disabled", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $root;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  let { multiple = false } = $$props;
  let { value = void 0 } = $$props;
  let { onValueChange = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { asChild = false } = $$props;
  const { elements: { root }, states: { value: localValue }, updateOption } = setCtx({
    multiple,
    disabled,
    defaultValue: value,
    onValueChange: ({ next: next2 }) => {
      if (value !== next2) {
        onValueChange == null ? void 0 : onValueChange(next2);
        $$invalidate(5, value = next2);
      }
      return next2;
    }
  });
  validate_store(root, "root");
  component_subscribe($$self, root, (value2) => $$invalidate(9, $root = value2));
  const attrs = getAttrs("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("multiple" in $$new_props) $$invalidate(6, multiple = $$new_props.multiple);
    if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$new_props) $$invalidate(7, onValueChange = $$new_props.onValueChange);
    if ("disabled" in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCtx,
    getAttrs,
    multiple,
    value,
    onValueChange,
    disabled,
    asChild,
    root,
    localValue,
    updateOption,
    attrs,
    builder: builder2,
    $root
  });
  $$self.$inject_state = ($$new_props) => {
    if ("multiple" in $$props) $$invalidate(6, multiple = $$new_props.multiple);
    if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$props) $$invalidate(7, onValueChange = $$new_props.onValueChange);
    if ("disabled" in $$props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    32) {
      $: localValue.set(value);
    }
    if ($$self.$$.dirty & /*multiple*/
    64) {
      $: updateOption("multiple", multiple);
    }
    if ($$self.$$.dirty & /*disabled*/
    256) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*$root*/
    512) {
      $: $$invalidate(1, builder2 = $root);
    }
  };
  return [
    asChild,
    builder2,
    root,
    attrs,
    $$restProps,
    value,
    multiple,
    onValueChange,
    disabled,
    $root,
    $$scope,
    slots
  ];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      multiple: 6,
      value: 5,
      onValueChange: 7,
      disabled: 8,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment2.name
    });
  }
  get multiple() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValueChange() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValueChange(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Accordion_default = Accordion;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/accordion/components/AccordionItem.svelte
var file3 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/accordion/components/AccordionItem.svelte";
var get_default_slot_changes_13 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_13 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes3 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context3 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block3(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_13
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file3, 14, 1, 348);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_13
            ),
            get_default_slot_context_13
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context3
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["value", "disabled", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $item;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionItem", slots, ["default"]);
  let { value } = $$props;
  let { disabled = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { item, props } = setItem({ value, disabled });
  validate_store(item, "item");
  component_subscribe($$self, item, (value2) => $$invalidate(7, $item = value2));
  const attrs = getAttrs("item");
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<AccordionItem> was created without expected prop 'value'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
    if ("disabled" in $$new_props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setItem,
    getAttrs,
    value,
    disabled,
    asChild,
    item,
    props,
    attrs,
    builder: builder2,
    $item
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
    if ("disabled" in $$props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$item*/
    128) {
      $: $$invalidate(1, builder2 = $item(props));
    }
  };
  return [
    asChild,
    builder2,
    item,
    attrs,
    $$restProps,
    value,
    disabled,
    $item,
    $$scope,
    slots
  ];
}
var AccordionItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { value: 5, disabled: 6, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionItem",
      options,
      id: create_fragment3.name
    });
  }
  get value() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionItem_default = AccordionItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/accordion/components/AccordionHeader.svelte
var file4 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/accordion/components/AccordionHeader.svelte";
var get_default_slot_changes_14 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_14 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes4 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context4 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block4(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_14
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file4, 15, 1, 325);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_14
            ),
            get_default_slot_context_14
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context4
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(13:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block4, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["level", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $header;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionHeader", slots, ["default"]);
  let { level = 3 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { heading: header } } = getCtx2();
  validate_store(header, "header");
  component_subscribe($$self, header, (value) => $$invalidate(6, $header = value));
  const attrs = getAttrs("header");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("level" in $$new_props) $$invalidate(5, level = $$new_props.level);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getAttrs,
    getCtx: getCtx2,
    level,
    asChild,
    header,
    attrs,
    builder: builder2,
    $header
  });
  $$self.$inject_state = ($$new_props) => {
    if ("level" in $$props) $$invalidate(5, level = $$new_props.level);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$header, level*/
    96) {
      $: $$invalidate(1, builder2 = $header(level));
    }
  };
  return [asChild, builder2, header, attrs, $$restProps, level, $header, $$scope, slots];
}
var AccordionHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { level: 5, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionHeader",
      options,
      id: create_fragment4.name
    });
  }
  get level() {
    throw new Error("<AccordionHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set level(value) {
    throw new Error("<AccordionHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<AccordionHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AccordionHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionHeader_default = AccordionHeader;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/accordion/components/AccordionTrigger.svelte
var file5 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/accordion/components/AccordionTrigger.svelte";
var get_default_slot_changes_15 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_15 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes5 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context5 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block5(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_15
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file5, 14, 1, 397);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_15
            ),
            get_default_slot_context_15
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context5
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $trigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionTrigger", slots, ["default"]);
  let { asChild = false } = $$props;
  const { trigger, props } = getTrigger();
  validate_store(trigger, "trigger");
  component_subscribe($$self, trigger, (value) => $$invalidate(6, $trigger = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs("trigger");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getTrigger,
    getAttrs,
    createDispatcher,
    asChild,
    trigger,
    props,
    dispatch,
    attrs,
    builder: builder2,
    $trigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$trigger*/
    64) {
      $: $$invalidate(1, builder2 = $trigger(props));
    }
  };
  return [
    asChild,
    builder2,
    trigger,
    dispatch,
    attrs,
    $$restProps,
    $trigger,
    $$scope,
    slots
  ];
}
var AccordionTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionTrigger",
      options,
      id: create_fragment5.name
    });
  }
  get asChild() {
    throw new Error("<AccordionTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AccordionTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionTrigger_default = AccordionTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/accordion/components/AccordionContent.svelte
var file6 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/accordion/components/AccordionContent.svelte";
var get_default_slot_changes_5 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_5 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_4 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_4 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_3 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_3 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_2 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_2 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_16 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_16 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes6 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context6 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
function create_if_block_5(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_5
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file6, 40, 1, 1395);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes_5
            ),
            get_default_slot_context_5
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13],
        /*attrs*/
        ctx2[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(40:29) ",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_4
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file6, 36, 1, 1221);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_4
            ),
            get_default_slot_context_4
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(36:46) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_3
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file6, 32, 1, 1033);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_3
            ),
            get_default_slot_context_3
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(32:45) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_2
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file6, 22, 1, 794);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_2
            ),
            get_default_slot_context_2
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(22:62) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_16
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file6, 18, 1, 586);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_16
            ),
            get_default_slot_context_16
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(18:43) ",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context6
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes6
            ),
            get_default_slot_context6
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(16:0) {#if asChild && $isSelected(props)}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let show_if;
  let show_if_1;
  let show_if_2;
  let show_if_3;
  let show_if_4;
  let show_if_5;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block6,
    create_if_block_1,
    create_if_block_2,
    create_if_block_3,
    create_if_block_4,
    create_if_block_5
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*asChild, $isSelected*/
    320) show_if = null;
    if (dirty & /*transition, $isSelected*/
    257) show_if_1 = null;
    if (dirty & /*inTransition, outTransition, $isSelected*/
    276) show_if_2 = null;
    if (dirty & /*inTransition, $isSelected*/
    260) show_if_3 = null;
    if (dirty & /*outTransition, $isSelected*/
    272) show_if_4 = null;
    if (dirty & /*$isSelected*/
    256) show_if_5 = null;
    if (show_if == null) show_if = !!/*asChild*/
    (ctx2[6] && /*$isSelected*/
    ctx2[8](
      /*props*/
      ctx2[11]
    ));
    if (show_if) return 0;
    if (show_if_1 == null) show_if_1 = !!/*transition*/
    (ctx2[0] && /*$isSelected*/
    ctx2[8](
      /*props*/
      ctx2[11]
    ));
    if (show_if_1) return 1;
    if (show_if_2 == null) show_if_2 = !!/*inTransition*/
    (ctx2[2] && /*outTransition*/
    ctx2[4] && /*$isSelected*/
    ctx2[8](
      /*props*/
      ctx2[11]
    ));
    if (show_if_2) return 2;
    if (show_if_3 == null) show_if_3 = !!/*inTransition*/
    (ctx2[2] && /*$isSelected*/
    ctx2[8](
      /*props*/
      ctx2[11]
    ));
    if (show_if_3) return 3;
    if (show_if_4 == null) show_if_4 = !!/*outTransition*/
    (ctx2[4] && /*$isSelected*/
    ctx2[8](
      /*props*/
      ctx2[11]
    ));
    if (show_if_4) return 4;
    if (show_if_5 == null) show_if_5 = !!/*$isSelected*/
    ctx2[8](
      /*props*/
      ctx2[11]
    );
    if (show_if_5) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $content;
  let $isSelected;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionContent", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { content, isSelected, props } = getContent();
  validate_store(content, "content");
  component_subscribe($$self, content, (value) => $$invalidate(14, $content = value));
  validate_store(isSelected, "isSelected");
  component_subscribe($$self, isSelected, (value) => $$invalidate(8, $isSelected = value));
  const attrs = getAttrs("content");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getContent,
    getAttrs,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    content,
    isSelected,
    props,
    attrs,
    builder: builder2,
    $content,
    $isSelected
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$content*/
    16384) {
      $: $$invalidate(7, builder2 = $content(props));
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $isSelected,
    content,
    isSelected,
    props,
    attrs,
    $$restProps,
    $content,
    $$scope,
    slots
  ];
}
var AccordionContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionContent",
      options,
      id: create_fragment6.name
    });
  }
  get transition() {
    throw new Error("<AccordionContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<AccordionContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<AccordionContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<AccordionContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<AccordionContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<AccordionContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<AccordionContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<AccordionContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<AccordionContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<AccordionContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<AccordionContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<AccordionContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<AccordionContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AccordionContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionContent_default = AccordionContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/index.js
var alert_dialog_exports = {};
__export(alert_dialog_exports, {
  Action: () => AlertDialogAction_default,
  AlertDialog: () => AlertDialog_default,
  AlertDialogAction: () => AlertDialogAction_default,
  AlertDialogCancel: () => AlertDialogCancel_default,
  AlertDialogContent: () => AlertDialogContent_default,
  AlertDialogDescription: () => AlertDialogDescription_default,
  AlertDialogOverlay: () => AlertDialogOverlay_default,
  AlertDialogPortal: () => AlertDialogPortal_default,
  AlertDialogTitle: () => AlertDialogTitle_default,
  AlertDialogTrigger: () => AlertDialogTrigger_default,
  Cancel: () => AlertDialogCancel_default,
  Content: () => AlertDialogContent_default,
  Description: () => AlertDialogDescription_default,
  Overlay: () => AlertDialogOverlay_default,
  Portal: () => AlertDialogPortal_default,
  Root: () => AlertDialog_default,
  Title: () => AlertDialogTitle_default,
  Trigger: () => AlertDialogTrigger_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/ctx.js
var NAME3 = "alert-dialog";
var PARTS2 = [
  "action",
  "cancel",
  "content",
  "description",
  "overlay",
  "portal",
  "title",
  "trigger"
];
var getAttrs2 = createBitAttrs(NAME3, PARTS2);
function setCtx2(props) {
  const alertDialog = createDialog({
    ...removeUndefined2(props),
    role: "alertdialog"
  });
  setContext(NAME3, alertDialog);
  return {
    ...alertDialog,
    updateOption: getOptionUpdater(alertDialog.options)
  };
}
function getCtx3() {
  return getContext(NAME3);
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialog.svelte
var get_default_slot_changes7 = (dirty) => ({ ids: dirty & /*$idValues*/
1 });
var get_default_slot_context7 = (ctx) => ({ ids: (
  /*$idValues*/
  ctx[0]
) });
function create_fragment7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context7
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $idValues*/
        2049)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes7
            ),
            get_default_slot_context7
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let $idValues;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlertDialog", slots, ["default"]);
  let { preventScroll = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { closeOnOutsideClick = false } = $$props;
  let { portal = void 0 } = $$props;
  let { forceVisible = true } = $$props;
  let { open = void 0 } = $$props;
  let { onOpenChange = void 0 } = $$props;
  let { openFocus = void 0 } = $$props;
  let { closeFocus = void 0 } = $$props;
  const { states: { open: localOpen }, updateOption, ids } = setCtx2({
    closeOnEscape,
    preventScroll,
    closeOnOutsideClick,
    portal,
    forceVisible,
    defaultOpen: open,
    openFocus,
    closeFocus,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange == null ? void 0 : onOpenChange(next2);
        $$invalidate(2, open = next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.content, ids.description, ids.title], ([$contentId, $descriptionId, $titleId]) => ({
    content: $contentId,
    description: $descriptionId,
    title: $titleId
  }));
  validate_store(idValues, "idValues");
  component_subscribe($$self, idValues, (value) => $$invalidate(0, $idValues = value));
  const writable_props = [
    "preventScroll",
    "closeOnEscape",
    "closeOnOutsideClick",
    "portal",
    "forceVisible",
    "open",
    "onOpenChange",
    "openFocus",
    "closeFocus"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<AlertDialog> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("preventScroll" in $$props2) $$invalidate(3, preventScroll = $$props2.preventScroll);
    if ("closeOnEscape" in $$props2) $$invalidate(4, closeOnEscape = $$props2.closeOnEscape);
    if ("closeOnOutsideClick" in $$props2) $$invalidate(5, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("portal" in $$props2) $$invalidate(6, portal = $$props2.portal);
    if ("forceVisible" in $$props2) $$invalidate(7, forceVisible = $$props2.forceVisible);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(8, onOpenChange = $$props2.onOpenChange);
    if ("openFocus" in $$props2) $$invalidate(9, openFocus = $$props2.openFocus);
    if ("closeFocus" in $$props2) $$invalidate(10, closeFocus = $$props2.closeFocus);
    if ("$$scope" in $$props2) $$invalidate(11, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    derived,
    setCtx: setCtx2,
    preventScroll,
    closeOnEscape,
    closeOnOutsideClick,
    portal,
    forceVisible,
    open,
    onOpenChange,
    openFocus,
    closeFocus,
    localOpen,
    updateOption,
    ids,
    idValues,
    $idValues
  });
  $$self.$inject_state = ($$props2) => {
    if ("preventScroll" in $$props2) $$invalidate(3, preventScroll = $$props2.preventScroll);
    if ("closeOnEscape" in $$props2) $$invalidate(4, closeOnEscape = $$props2.closeOnEscape);
    if ("closeOnOutsideClick" in $$props2) $$invalidate(5, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("portal" in $$props2) $$invalidate(6, portal = $$props2.portal);
    if ("forceVisible" in $$props2) $$invalidate(7, forceVisible = $$props2.forceVisible);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(8, onOpenChange = $$props2.onOpenChange);
    if ("openFocus" in $$props2) $$invalidate(9, openFocus = $$props2.openFocus);
    if ("closeFocus" in $$props2) $$invalidate(10, closeFocus = $$props2.closeFocus);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    4) {
      $: open !== void 0 && localOpen.set(open);
    }
    if ($$self.$$.dirty & /*preventScroll*/
    8) {
      $: updateOption("preventScroll", preventScroll);
    }
    if ($$self.$$.dirty & /*closeOnEscape*/
    16) {
      $: updateOption("closeOnEscape", closeOnEscape);
    }
    if ($$self.$$.dirty & /*closeOnOutsideClick*/
    32) {
      $: updateOption("closeOnOutsideClick", closeOnOutsideClick);
    }
    if ($$self.$$.dirty & /*portal*/
    64) {
      $: updateOption("portal", portal);
    }
    if ($$self.$$.dirty & /*forceVisible*/
    128) {
      $: updateOption("forceVisible", forceVisible);
    }
    if ($$self.$$.dirty & /*openFocus*/
    512) {
      $: updateOption("openFocus", openFocus);
    }
    if ($$self.$$.dirty & /*closeFocus*/
    1024) {
      $: updateOption("closeFocus", closeFocus);
    }
  };
  return [
    $idValues,
    idValues,
    open,
    preventScroll,
    closeOnEscape,
    closeOnOutsideClick,
    portal,
    forceVisible,
    onOpenChange,
    openFocus,
    closeFocus,
    $$scope,
    slots
  ];
}
var AlertDialog = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      preventScroll: 3,
      closeOnEscape: 4,
      closeOnOutsideClick: 5,
      portal: 6,
      forceVisible: 7,
      open: 2,
      onOpenChange: 8,
      openFocus: 9,
      closeFocus: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertDialog",
      options,
      id: create_fragment7.name
    });
  }
  get preventScroll() {
    throw new Error("<AlertDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScroll(value) {
    throw new Error("<AlertDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<AlertDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<AlertDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnOutsideClick() {
    throw new Error("<AlertDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnOutsideClick(value) {
    throw new Error("<AlertDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get portal() {
    throw new Error("<AlertDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portal(value) {
    throw new Error("<AlertDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forceVisible() {
    throw new Error("<AlertDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forceVisible(value) {
    throw new Error("<AlertDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<AlertDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<AlertDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onOpenChange() {
    throw new Error("<AlertDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onOpenChange(value) {
    throw new Error("<AlertDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openFocus() {
    throw new Error("<AlertDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openFocus(value) {
    throw new Error("<AlertDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeFocus() {
    throw new Error("<AlertDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeFocus(value) {
    throw new Error("<AlertDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlertDialog_default = AlertDialog;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogTitle.svelte
var file7 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogTitle.svelte";
var get_default_slot_changes_17 = (dirty) => ({ builder: dirty & /*builder*/
4 });
var get_default_slot_context_17 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes8 = (dirty) => ({ builder: dirty & /*builder*/
4 });
var get_default_slot_context8 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block6(ctx) {
  let previous_tag = (
    /*level*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*level*/
    ctx[0]
  );
  validate_void_dynamic_element(
    /*level*/
    ctx[0]
  );
  let svelte_element = (
    /*level*/
    ctx[0] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element) svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*level*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*level*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*level*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*level*/
            ctx2[0]
          );
          validate_void_dynamic_element(
            /*level*/
            ctx2[0]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*level*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*level*/
        ctx2[0];
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(21:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context8
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes8
            ),
            get_default_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(19:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_17
  );
  let svelte_element_levels = [
    /*builder*/
    ctx[2],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*level*/
        ctx[0]
      );
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*level*/
        (ctx[0] || "null").toUpperCase(),
        {}
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot) default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*level*/
        ctx[0]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file7, 21, 1, 382);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[2].action(svelte_element));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_17
            ),
            get_default_slot_context_17
          );
        }
      }
      set_dynamic_element_data(
        /*level*/
        ctx2[0]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        dirty & /*builder*/
        4 && /*builder*/
        ctx2[2],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(22:1) <svelte:element this={level} {...builder} use:builder.action {...$$restProps} {...attrs}>",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block7, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["level", "asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $title;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlertDialogTitle", slots, ["default"]);
  let { level = "h2" } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { title }, ids } = getCtx3();
  validate_store(title, "title");
  component_subscribe($$self, title, (value) => $$invalidate(7, $title = value));
  const attrs = getAttrs2("title");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("level" in $$new_props) $$invalidate(0, level = $$new_props.level);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(6, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx3,
    getAttrs: getAttrs2,
    level,
    asChild,
    id,
    title,
    ids,
    attrs,
    builder: builder2,
    $title
  });
  $$self.$inject_state = ($$new_props) => {
    if ("level" in $$props) $$invalidate(0, level = $$new_props.level);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(6, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    64) {
      $: if (id) {
        ids.title.set(id);
      }
    }
    if ($$self.$$.dirty & /*$title*/
    128) {
      $: $$invalidate(2, builder2 = $title);
    }
  };
  return [level, asChild, builder2, title, attrs, $$restProps, id, $title, $$scope, slots];
}
var AlertDialogTitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { level: 0, asChild: 1, id: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertDialogTitle",
      options,
      id: create_fragment8.name
    });
  }
  get level() {
    throw new Error("<AlertDialogTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set level(value) {
    throw new Error("<AlertDialogTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<AlertDialogTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AlertDialogTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<AlertDialogTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<AlertDialogTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlertDialogTitle_default = AlertDialogTitle;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogAction.svelte
var file8 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogAction.svelte";
var get_default_slot_changes_18 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_18 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes9 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context9 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block7(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_18
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file8, 16, 1, 386);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_18
            ),
            get_default_slot_context_18
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context9
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes9
            ),
            get_default_slot_context9
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(14:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block8, create_else_block7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $close;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlertDialogAction", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { close } } = getCtx3();
  validate_store(close, "close");
  component_subscribe($$self, close, (value) => $$invalidate(6, $close = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs2("action");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    createDispatcher,
    getCtx: getCtx3,
    getAttrs: getAttrs2,
    asChild,
    close,
    dispatch,
    attrs,
    builder: builder2,
    $close
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$close*/
    64) {
      $: $$invalidate(1, builder2 = $close);
    }
  };
  return [asChild, builder2, close, dispatch, attrs, $$restProps, $close, $$scope, slots];
}
var AlertDialogAction = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertDialogAction",
      options,
      id: create_fragment9.name
    });
  }
  get asChild() {
    throw new Error("<AlertDialogAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AlertDialogAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlertDialogAction_default = AlertDialogAction;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogCancel.svelte
var file9 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogCancel.svelte";
var get_default_slot_changes_19 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_19 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes10 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context10 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block8(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_19
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file9, 16, 1, 386);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_19
            ),
            get_default_slot_context_19
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context10
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes10
            ),
            get_default_slot_context10
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(14:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block9, create_else_block8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $close;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlertDialogCancel", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { close } } = getCtx3();
  validate_store(close, "close");
  component_subscribe($$self, close, (value) => $$invalidate(6, $close = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs2("cancel");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx3,
    getAttrs: getAttrs2,
    createDispatcher,
    asChild,
    close,
    dispatch,
    attrs,
    builder: builder2,
    $close
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$close*/
    64) {
      $: $$invalidate(1, builder2 = $close);
    }
  };
  return [asChild, builder2, close, dispatch, attrs, $$restProps, $close, $$scope, slots];
}
var AlertDialogCancel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertDialogCancel",
      options,
      id: create_fragment10.name
    });
  }
  get asChild() {
    throw new Error("<AlertDialogCancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AlertDialogCancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlertDialogCancel_default = AlertDialogCancel;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogPortal.svelte
var file10 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogPortal.svelte";
var get_default_slot_changes_110 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_110 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes11 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context11 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block9(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context_110
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file10, 14, 1, 293);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes_110
            ),
            get_default_slot_context_110
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context11
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes11
            ),
            get_default_slot_context11
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block10, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $portalled;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlertDialogPortal", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { portalled } } = getCtx3();
  validate_store(portalled, "portalled");
  component_subscribe($$self, portalled, (value) => $$invalidate(5, $portalled = value));
  const attrs = getAttrs2("portal");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx3,
    getAttrs: getAttrs2,
    asChild,
    portalled,
    attrs,
    builder: builder2,
    $portalled
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$portalled*/
    32) {
      $: $$invalidate(1, builder2 = $portalled);
    }
  };
  return [asChild, builder2, portalled, attrs, $$restProps, $portalled, $$scope, slots];
}
var AlertDialogPortal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertDialogPortal",
      options,
      id: create_fragment11.name
    });
  }
  get asChild() {
    throw new Error("<AlertDialogPortal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AlertDialogPortal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlertDialogPortal_default = AlertDialogPortal;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogContent.svelte
var file11 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogContent.svelte";
var get_default_slot_changes_52 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_52 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_42 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_42 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_32 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_32 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_22 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_22 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_111 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_111 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes12 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context12 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
function create_if_block_52(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_52
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file11, 49, 1, 1394);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes_52
            ),
            get_default_slot_context_52
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12],
        /*attrs*/
        ctx2[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(49:16) ",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_42
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file11, 45, 1, 1233);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_42
            ),
            get_default_slot_context_42
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(45:33) ",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_32
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file11, 41, 1, 1058);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_32
            ),
            get_default_slot_context_32
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(41:32) ",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_22
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file11, 31, 1, 832);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_22
            ),
            get_default_slot_context_22
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(31:49) ",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_111
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file11, 27, 1, 637);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_111
            ),
            get_default_slot_context_111
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(27:30) ",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context12
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes12
            ),
            get_default_slot_context12
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(25:0) {#if asChild && $open}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block11,
    create_if_block_12,
    create_if_block_22,
    create_if_block_32,
    create_if_block_42,
    create_if_block_52
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$open*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$open*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$open*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 4;
    if (
      /*$open*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "id",
    "asChild"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $content;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlertDialogContent", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { content }, states: { open }, ids } = getCtx3();
  validate_store(content, "content");
  component_subscribe($$self, content, (value) => $$invalidate(14, $content = value));
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  const attrs = getAttrs2("content");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("id" in $$new_props) $$invalidate(13, id = $$new_props.id);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx3,
    getAttrs: getAttrs2,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    id,
    asChild,
    content,
    open,
    ids,
    attrs,
    builder: builder2,
    $content,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("id" in $$props) $$invalidate(13, id = $$new_props.id);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    8192) {
      $: if (id) {
        ids.content.set(id);
      }
    }
    if ($$self.$$.dirty & /*$content*/
    16384) {
      $: $$invalidate(7, builder2 = $content);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $open,
    content,
    open,
    attrs,
    $$restProps,
    id,
    $content,
    $$scope,
    slots
  ];
}
var AlertDialogContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      id: 13,
      asChild: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertDialogContent",
      options,
      id: create_fragment12.name
    });
  }
  get transition() {
    throw new Error("<AlertDialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<AlertDialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<AlertDialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<AlertDialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<AlertDialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<AlertDialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<AlertDialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<AlertDialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<AlertDialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<AlertDialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<AlertDialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<AlertDialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<AlertDialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<AlertDialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<AlertDialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AlertDialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlertDialogContent_default = AlertDialogContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogOverlay.svelte
var file12 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogOverlay.svelte";
var get_default_slot_changes13 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context13 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
function create_if_block_53(ctx) {
  let div;
  let builder_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file12, 34, 1, 1165);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12],
        /*attrs*/
        ctx2[11]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_53.name,
    type: "if",
    source: "(34:16) ",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file12, 32, 1, 1039);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(32:33) ",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file12, 30, 1, 899);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
    },
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(30:32) ",
    ctx
  });
  return block;
}
function create_if_block_23(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file12, 23, 1, 722);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(23:49) ",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file12, 21, 1, 562);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(21:30) ",
    ctx
  });
  return block;
}
function create_if_block12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context13
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        16512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes13
            ),
            get_default_slot_context13
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(19:0) {#if asChild && $open}",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block12,
    create_if_block_13,
    create_if_block_23,
    create_if_block_33,
    create_if_block_43,
    create_if_block_53
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$open*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$open*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$open*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 4;
    if (
      /*$open*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $overlay;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlertDialogOverlay", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { overlay }, states: { open } } = getCtx3();
  validate_store(overlay, "overlay");
  component_subscribe($$self, overlay, (value) => $$invalidate(13, $overlay = value));
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  const attrs = getAttrs2("overlay");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx3,
    getAttrs: getAttrs2,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    overlay,
    open,
    attrs,
    builder: builder2,
    $overlay,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$overlay*/
    8192) {
      $: $$invalidate(7, builder2 = $overlay);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $open,
    overlay,
    open,
    attrs,
    $$restProps,
    $overlay,
    $$scope,
    slots
  ];
}
var AlertDialogOverlay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertDialogOverlay",
      options,
      id: create_fragment13.name
    });
  }
  get transition() {
    throw new Error("<AlertDialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<AlertDialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<AlertDialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<AlertDialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<AlertDialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<AlertDialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<AlertDialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<AlertDialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<AlertDialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<AlertDialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<AlertDialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<AlertDialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<AlertDialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AlertDialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlertDialogOverlay_default = AlertDialogOverlay;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogTrigger.svelte
var file13 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogTrigger.svelte";
var get_default_slot_changes_112 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_112 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes14 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context14 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block10(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_112
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file13, 16, 1, 391);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_112
            ),
            get_default_slot_context_112
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block10.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context14
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes14
            ),
            get_default_slot_context14
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(14:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block13, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $trigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlertDialogTrigger", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { trigger } } = getCtx3();
  validate_store(trigger, "trigger");
  component_subscribe($$self, trigger, (value) => $$invalidate(6, $trigger = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs2("trigger");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx3,
    getAttrs: getAttrs2,
    createDispatcher,
    asChild,
    trigger,
    dispatch,
    attrs,
    builder: builder2,
    $trigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$trigger*/
    64) {
      $: $$invalidate(1, builder2 = $trigger);
    }
  };
  return [
    asChild,
    builder2,
    trigger,
    dispatch,
    attrs,
    $$restProps,
    $trigger,
    $$scope,
    slots
  ];
}
var AlertDialogTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertDialogTrigger",
      options,
      id: create_fragment14.name
    });
  }
  get asChild() {
    throw new Error("<AlertDialogTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AlertDialogTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlertDialogTrigger_default = AlertDialogTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogDescription.svelte
var file14 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/alert-dialog/components/AlertDialogDescription.svelte";
var get_default_slot_changes_113 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_113 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes15 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context15 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block11(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_113
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file14, 20, 1, 381);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_113
            ),
            get_default_slot_context_113
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block11.name,
    type: "else",
    source: "(20:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context15
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes15
            ),
            get_default_slot_context15
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(18:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block14, create_else_block11];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $description;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlertDialogDescription", slots, ["default"]);
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { description }, ids } = getCtx3();
  validate_store(description, "description");
  component_subscribe($$self, description, (value) => $$invalidate(6, $description = value));
  const attrs = getAttrs2("description");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx3,
    getAttrs: getAttrs2,
    asChild,
    id,
    description,
    ids,
    attrs,
    builder: builder2,
    $description
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    32) {
      $: if (id) {
        ids.description.set(id);
      }
    }
    if ($$self.$$.dirty & /*$description*/
    64) {
      $: $$invalidate(1, builder2 = $description);
    }
  };
  return [
    asChild,
    builder2,
    description,
    attrs,
    $$restProps,
    id,
    $description,
    $$scope,
    slots
  ];
}
var AlertDialogDescription = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { asChild: 0, id: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertDialogDescription",
      options,
      id: create_fragment15.name
    });
  }
  get asChild() {
    throw new Error("<AlertDialogDescription>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AlertDialogDescription>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<AlertDialogDescription>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<AlertDialogDescription>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlertDialogDescription_default = AlertDialogDescription;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/aspect-ratio/index.js
var aspect_ratio_exports = {};
__export(aspect_ratio_exports, {
  AspectRatio: () => AspectRatio_default,
  Root: () => AspectRatio_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/aspect-ratio/components/AspectRatio.svelte
var file15 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/aspect-ratio/components/AspectRatio.svelte";
function create_fragment16(ctx) {
  let div1;
  let div0;
  let style_padding_bottom = `${100 / /*ratio*/
  ctx[0]}%`;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div0_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div_data = assign(div_data, div0_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div0, div_data);
      set_style(div0, "position", `absolute`);
      set_style(div0, "top", `0`);
      set_style(div0, "right", `0`);
      set_style(div0, "bottom", `0`);
      set_style(div0, "left", `0`);
      add_location(div0, file15, 4, 1, 135);
      set_style(div1, "position", `relative`);
      set_style(div1, "width", `100%`);
      set_style(div1, "padding-bottom", style_padding_bottom);
      add_location(div1, file15, 3, 0, 45);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div0, div_data = get_spread_update(div0_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      set_style(div0, "position", `absolute`);
      set_style(div0, "top", `0`);
      set_style(div0, "right", `0`);
      set_style(div0, "bottom", `0`);
      set_style(div0, "left", `0`);
      if (dirty & /*ratio*/
      1 && style_padding_bottom !== (style_padding_bottom = `${100 / /*ratio*/
      ctx2[0]}%`)) {
        set_style(div1, "padding-bottom", style_padding_bottom);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  const omit_props_names = ["ratio"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AspectRatio", slots, ["default"]);
  let { ratio = 1 / 1 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ratio" in $$new_props) $$invalidate(0, ratio = $$new_props.ratio);
    if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ ratio });
  $$self.$inject_state = ($$new_props) => {
    if ("ratio" in $$props) $$invalidate(0, ratio = $$new_props.ratio);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ratio, $$restProps, $$scope, slots];
}
var AspectRatio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { ratio: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AspectRatio",
      options,
      id: create_fragment16.name
    });
  }
  get ratio() {
    throw new Error("<AspectRatio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ratio(value) {
    throw new Error("<AspectRatio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AspectRatio_default = AspectRatio;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/avatar/index.js
var avatar_exports = {};
__export(avatar_exports, {
  Avatar: () => Avatar_default,
  AvatarFallback: () => AvatarFallback_default,
  AvatarImage: () => AvatarImage_default,
  Fallback: () => AvatarFallback_default,
  Image: () => AvatarImage_default,
  Root: () => Avatar_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/avatar/ctx.js
var NAME4 = "avatar";
var PARTS3 = ["root", "image", "fallback"];
var getAttrs3 = createBitAttrs(NAME4, PARTS3);
function setCtx3(props) {
  const avatar = createAvatar(removeUndefined2(props));
  setContext(NAME4, avatar);
  return {
    ...avatar,
    updateOption: getOptionUpdater(avatar.options)
  };
}
function getImage(src = "") {
  const avatar = getContext(NAME4);
  if (!src) {
    avatar.options.src.set("");
  } else {
    avatar.options.src.set(src);
  }
  return avatar;
}
function getCtx4() {
  return getContext(NAME4);
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/avatar/components/Avatar.svelte
var file16 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/avatar/components/Avatar.svelte";
var get_default_slot_changes_114 = (dirty) => ({});
var get_default_slot_context_114 = (ctx) => ({ attrs: (
  /*attrs*/
  ctx[1]
) });
var get_default_slot_changes16 = (dirty) => ({});
var get_default_slot_context16 = (ctx) => ({ attrs: (
  /*attrs*/
  ctx[1]
) });
function create_else_block12(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context_114
  );
  let div_levels = [
    /*$$restProps*/
    ctx[2],
    /*attrs*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file16, 27, 1, 618);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes_114
            ),
            get_default_slot_context_114
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        /*attrs*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block12.name,
    type: "else",
    source: "(27:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context16
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes16
            ),
            get_default_slot_context16
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(25:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block15, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  const omit_props_names = ["delayMs", "loadingStatus", "onLoadingStatusChange", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Avatar", slots, ["default"]);
  let { delayMs = void 0 } = $$props;
  let { loadingStatus = void 0 } = $$props;
  let { onLoadingStatusChange = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { states: { loadingStatus: localLoadingStatus }, updateOption } = setCtx3({
    src: "",
    delayMs,
    onLoadingStatusChange: ({ next: next2 }) => {
      $$invalidate(3, loadingStatus = next2);
      onLoadingStatusChange == null ? void 0 : onLoadingStatusChange(next2);
      return next2;
    }
  });
  const attrs = getAttrs3("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("delayMs" in $$new_props) $$invalidate(4, delayMs = $$new_props.delayMs);
    if ("loadingStatus" in $$new_props) $$invalidate(3, loadingStatus = $$new_props.loadingStatus);
    if ("onLoadingStatusChange" in $$new_props) $$invalidate(5, onLoadingStatusChange = $$new_props.onLoadingStatusChange);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setCtx: setCtx3,
    getAttrs: getAttrs3,
    delayMs,
    loadingStatus,
    onLoadingStatusChange,
    asChild,
    localLoadingStatus,
    updateOption,
    attrs
  });
  $$self.$inject_state = ($$new_props) => {
    if ("delayMs" in $$props) $$invalidate(4, delayMs = $$new_props.delayMs);
    if ("loadingStatus" in $$props) $$invalidate(3, loadingStatus = $$new_props.loadingStatus);
    if ("onLoadingStatusChange" in $$props) $$invalidate(5, onLoadingStatusChange = $$new_props.onLoadingStatusChange);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*loadingStatus*/
    8) {
      $: loadingStatus !== void 0 && localLoadingStatus.set(loadingStatus);
    }
    if ($$self.$$.dirty & /*delayMs*/
    16) {
      $: updateOption("delayMs", delayMs);
    }
  };
  return [
    asChild,
    attrs,
    $$restProps,
    loadingStatus,
    delayMs,
    onLoadingStatusChange,
    $$scope,
    slots
  ];
}
var Avatar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, {
      delayMs: 4,
      loadingStatus: 3,
      onLoadingStatusChange: 5,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Avatar",
      options,
      id: create_fragment17.name
    });
  }
  get delayMs() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delayMs(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loadingStatus() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loadingStatus(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onLoadingStatusChange() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onLoadingStatusChange(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Avatar_default = Avatar;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/avatar/components/AvatarImage.svelte
var file17 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/avatar/components/AvatarImage.svelte";
var get_default_slot_changes17 = (dirty) => ({ builder: dirty & /*builder*/
4 });
var get_default_slot_context17 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block13(ctx) {
  let img;
  let builder_action_action;
  let mounted;
  let dispose;
  let img_levels = [
    /*builder*/
    ctx[2],
    { alt: (
      /*alt*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { alt: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      add_location(img, file17, 15, 1, 335);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[2].action(img));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*builder*/
        4 && /*builder*/
        ctx2[2],
        dirty & /*alt*/
        1 && { alt: (
          /*alt*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block13.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context17
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes17
            ),
            get_default_slot_context17
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(13:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block16, create_else_block13];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let image;
  let builder2;
  const omit_props_names = ["src", "alt", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $image, $$unsubscribe_image = noop, $$subscribe_image = () => ($$unsubscribe_image(), $$unsubscribe_image = subscribe(image, ($$value) => $$invalidate(7, $image = $$value)), image);
  $$self.$$.on_destroy.push(() => $$unsubscribe_image());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AvatarImage", slots, ["default"]);
  let { src = void 0 } = $$props;
  let { alt = void 0 } = $$props;
  let { asChild = false } = $$props;
  const attrs = getAttrs3("image");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("src" in $$new_props) $$invalidate(6, src = $$new_props.src);
    if ("alt" in $$new_props) $$invalidate(0, alt = $$new_props.alt);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getImage,
    getAttrs: getAttrs3,
    src,
    alt,
    asChild,
    attrs,
    builder: builder2,
    image,
    $image
  });
  $$self.$inject_state = ($$new_props) => {
    if ("src" in $$props) $$invalidate(6, src = $$new_props.src);
    if ("alt" in $$props) $$invalidate(0, alt = $$new_props.alt);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
    if ("image" in $$props) $$subscribe_image($$invalidate(3, image = $$new_props.image));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*src*/
    64) {
      $: $$subscribe_image($$invalidate(3, image = getImage(src).elements.image));
    }
    if ($$self.$$.dirty & /*$image*/
    128) {
      $: $$invalidate(2, builder2 = $image);
    }
  };
  return [alt, asChild, builder2, image, attrs, $$restProps, src, $image, $$scope, slots];
}
var AvatarImage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { src: 6, alt: 0, asChild: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AvatarImage",
      options,
      id: create_fragment18.name
    });
  }
  get src() {
    throw new Error("<AvatarImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<AvatarImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<AvatarImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<AvatarImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<AvatarImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AvatarImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AvatarImage_default = AvatarImage;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/avatar/components/AvatarFallback.svelte
var file18 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/avatar/components/AvatarFallback.svelte";
var get_default_slot_changes_115 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_115 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes18 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context18 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block14(ctx) {
  let span;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context_115
  );
  let span_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot) default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file18, 14, 1, 293);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(span));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes_115
            ),
            get_default_slot_context_115
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block14.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context18
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes18
            ),
            get_default_slot_context18
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block17, create_else_block14];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $fallback;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AvatarFallback", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { fallback } } = getCtx4();
  validate_store(fallback, "fallback");
  component_subscribe($$self, fallback, (value) => $$invalidate(5, $fallback = value));
  const attrs = getAttrs3("fallback");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx4,
    getAttrs: getAttrs3,
    asChild,
    fallback,
    attrs,
    builder: builder2,
    $fallback
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$fallback*/
    32) {
      $: $$invalidate(1, builder2 = $fallback);
    }
  };
  return [asChild, builder2, fallback, attrs, $$restProps, $fallback, $$scope, slots];
}
var AvatarFallback = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AvatarFallback",
      options,
      id: create_fragment19.name
    });
  }
  get asChild() {
    throw new Error("<AvatarFallback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<AvatarFallback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AvatarFallback_default = AvatarFallback;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/button/index.js
var button_exports = {};
__export(button_exports, {
  Button: () => Button_default,
  Root: () => Button_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/helpers/builders.js
function builderActions(node, params) {
  const unsubs = [];
  params.builders.forEach((builder2) => {
    const act = builder2.action(node);
    if (act) {
      unsubs.push(act);
    }
  });
  return {
    destroy: () => {
      unsubs.forEach((unsub) => {
        if (unsub.destroy) {
          unsub.destroy();
        }
      });
    }
  };
}
function getAttrs4(builders) {
  const attrs = {};
  builders.forEach((builder2) => {
    Object.keys(builder2).forEach((key) => {
      if (key !== "action") {
        attrs[key] = builder2[key];
      }
    });
  });
  return attrs;
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/button/components/Button.svelte
var file19 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/button/components/Button.svelte";
function create_else_block15(ctx) {
  let previous_tag = (
    /*href*/
    ctx[0] ? "a" : "button"
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*href*/
    ctx[0] ? "a" : "button"
  );
  validate_void_dynamic_element(
    /*href*/
    ctx[0] ? "a" : "button"
  );
  let svelte_element = (
    /*href*/
    (ctx[0] ? "a" : "button") && create_dynamic_element_1(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element) svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*href*/
        ctx2[0] ? "a" : "button"
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element_1(ctx2);
          previous_tag = /*href*/
          ctx2[0] ? "a" : "button";
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*href*/
          ctx2[0] ? "a" : "button"
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*href*/
            ctx2[0] ? "a" : "button"
          );
          validate_void_dynamic_element(
            /*href*/
            ctx2[0] ? "a" : "button"
          );
          svelte_element = create_dynamic_element_1(ctx2);
          previous_tag = /*href*/
          ctx2[0] ? "a" : "button";
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*href*/
        ctx2[0] ? "a" : "button";
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block15.name,
    type: "else",
    source: "(30:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block18(ctx) {
  let previous_tag = (
    /*href*/
    ctx[0] ? "a" : "button"
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*href*/
    ctx[0] ? "a" : "button"
  );
  validate_void_dynamic_element(
    /*href*/
    ctx[0] ? "a" : "button"
  );
  let svelte_element = (
    /*href*/
    (ctx[0] ? "a" : "button") && create_dynamic_element2(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element) svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*href*/
        ctx2[0] ? "a" : "button"
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element2(ctx2);
          previous_tag = /*href*/
          ctx2[0] ? "a" : "button";
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*href*/
          ctx2[0] ? "a" : "button"
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*href*/
            ctx2[0] ? "a" : "button"
          );
          validate_void_dynamic_element(
            /*href*/
            ctx2[0] ? "a" : "button"
          );
          svelte_element = create_dynamic_element2(ctx2);
          previous_tag = /*href*/
          ctx2[0] ? "a" : "button";
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*href*/
        ctx2[0] ? "a" : "button";
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(10:0) {#if builders && builders.length}",
    ctx
  });
  return block;
}
function create_dynamic_element_1(ctx) {
  let svelte_element;
  let svelte_element_type_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let svelte_element_levels = [
    {
      type: svelte_element_type_value = /*href*/
      ctx[0] ? void 0 : (
        /*type*/
        ctx[1]
      )
    },
    { href: (
      /*href*/
      ctx[0]
    ) },
    { tabindex: "0" },
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*href*/
        ctx[0] ? "a" : "button"
      );
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*href*/
        ((ctx[0] ? "a" : "button") || "null").toUpperCase(),
        { type: true, href: true, tabindex: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot) default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*href*/
        ctx[0] ? "a" : "button"
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file19, 31, 1, 690);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            svelte_element,
            "click",
            /*click_handler_1*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "change",
            /*change_handler_1*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "keydown",
            /*keydown_handler_1*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "keyup",
            /*keyup_handler_1*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*href*/
        ctx2[0] ? "a" : "button"
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*href, type*/
        3 && svelte_element_type_value !== (svelte_element_type_value = /*href*/
        ctx2[0] ? void 0 : (
          /*type*/
          ctx2[1]
        ))) && { type: svelte_element_type_value },
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx2[0]
        ) },
        { tabindex: "0" },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element_1.name,
    type: "child_dynamic_element",
    source: '(32:1) <svelte:element   this={href ? \\"a\\" : \\"button\\"}   type={href ? undefined : type}   {href}   on:click   on:change   on:keydown   on:keyup   on:mouseenter   on:mouseleave   tabindex=\\"0\\"   {...$$restProps}   {...attrs}  >',
    ctx
  });
  return block;
}
function create_dynamic_element2(ctx) {
  let svelte_element;
  let svelte_element_type_value;
  let builderActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let svelte_element_levels = [
    {
      type: svelte_element_type_value = /*href*/
      ctx[0] ? void 0 : (
        /*type*/
        ctx[1]
      )
    },
    { href: (
      /*href*/
      ctx[0]
    ) },
    { tabindex: "0" },
    getAttrs4(
      /*builders*/
      ctx[2]
    ),
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*href*/
        ctx[0] ? "a" : "button"
      );
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*href*/
        ((ctx[0] ? "a" : "button") || "null").toUpperCase(),
        { type: true, href: true, tabindex: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot) default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*href*/
        ctx[0] ? "a" : "button"
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file19, 11, 1, 311);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            svelte_element,
            "click",
            /*click_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "change",
            /*change_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "keydown",
            /*keydown_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "keyup",
            /*keyup_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          action_destroyer(builderActions_action = builderActions.call(null, svelte_element, { builders: (
            /*builders*/
            ctx[2]
          ) }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*href*/
        ctx2[0] ? "a" : "button"
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*href, type*/
        3 && svelte_element_type_value !== (svelte_element_type_value = /*href*/
        ctx2[0] ? void 0 : (
          /*type*/
          ctx2[1]
        ))) && { type: svelte_element_type_value },
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx2[0]
        ) },
        { tabindex: "0" },
        dirty & /*builders*/
        4 && getAttrs4(
          /*builders*/
          ctx2[2]
        ),
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
      if (builderActions_action && is_function(builderActions_action.update) && dirty & /*builders*/
      4) builderActions_action.update.call(null, { builders: (
        /*builders*/
        ctx2[2]
      ) });
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element2.name,
    type: "child_dynamic_element",
    source: '(12:1) <svelte:element   this={href ? \\"a\\" : \\"button\\"}   type={href ? undefined : type}   {href}   on:click   on:change   on:keydown   on:keyup   on:mouseenter   on:mouseleave   tabindex=\\"0\\"   use:builderActions={{ builders }}   {...getAttrs(builders)}   {...$$restProps}   {...attrs}  >',
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block18, create_else_block15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*builders*/
      ctx2[2] && /*builders*/
      ctx2[2].length
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "type", "builders"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  let { href = void 0 } = $$props;
  let { type = void 0 } = $$props;
  let { builders = [] } = $$props;
  const attrs = { "data-bits-button-root": "" };
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function mouseenter_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props) $$invalidate(0, href = $$new_props.href);
    if ("type" in $$new_props) $$invalidate(1, type = $$new_props.type);
    if ("builders" in $$new_props) $$invalidate(2, builders = $$new_props.builders);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    builderActions,
    getAttrs: getAttrs4,
    href,
    type,
    builders,
    attrs
  });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
    if ("type" in $$props) $$invalidate(1, type = $$new_props.type);
    if ("builders" in $$props) $$invalidate(2, builders = $$new_props.builders);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    href,
    type,
    builders,
    attrs,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    change_handler,
    keydown_handler,
    keyup_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_1,
    change_handler_1,
    keydown_handler_1,
    keyup_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { href: 0, type: 1, builders: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment20.name
    });
  }
  get href() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get builders() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set builders(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/checkbox/index.js
var checkbox_exports = {};
__export(checkbox_exports, {
  Checkbox: () => Checkbox_default,
  CheckboxIndicator: () => CheckboxIndicator_default,
  CheckboxInput: () => CheckboxInput_default,
  Indicator: () => CheckboxIndicator_default,
  Input: () => CheckboxInput_default,
  Root: () => Checkbox_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/checkbox/ctx.js
var NAME5 = "checkbox";
var PARTS4 = ["root", "input", "indicator"];
var getAttrs5 = createBitAttrs(NAME5, PARTS4);
function setCtx4(props) {
  const checkbox = createCheckbox(removeUndefined2(props));
  setContext(NAME5, { ...checkbox });
  return {
    ...checkbox,
    updateOption: getOptionUpdater(checkbox.options)
  };
}
function getCtx5() {
  return getContext(NAME5);
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/checkbox/components/Checkbox.svelte
var file20 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/checkbox/components/Checkbox.svelte";
var get_default_slot_changes_116 = (dirty) => ({ builder: dirty & /*builder*/
4 });
var get_default_slot_context_116 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[5]
  )
});
var get_default_slot_changes19 = (dirty) => ({ builder: dirty & /*builder*/
4 });
var get_default_slot_context19 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[5]
  )
});
function create_else_block16(ctx) {
  let button;
  let button_disabled_value;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context_116
  );
  let button_levels = [
    /*builder*/
    ctx[2],
    { type: "button" },
    /*$$restProps*/
    ctx[6],
    /*attrs*/
    ctx[5],
    {
      disabled: button_disabled_value = /*disabled*/
      ctx[0] ? true : void 0
    }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file20, 47, 1, 1031);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[2].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        8196)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes_116
            ),
            get_default_slot_context_116
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        4 && /*builder*/
        ctx2[2],
        { type: "button" },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        /*attrs*/
        ctx2[5],
        (!current || dirty & /*disabled*/
        1 && button_disabled_value !== (button_disabled_value = /*disabled*/
        ctx2[0] ? true : void 0)) && { disabled: button_disabled_value }
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block16.name,
    type: "else",
    source: "(47:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context19
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        8196)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes19
            ),
            get_default_slot_context19
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(45:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block19, create_else_block16];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["checked", "disabled", "name", "required", "value", "onCheckedChange", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $root;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkbox", slots, ["default"]);
  let { checked = false } = $$props;
  let { disabled = void 0 } = $$props;
  let { name: name27 = void 0 } = $$props;
  let { required = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { onCheckedChange = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { root }, states: { checked: localChecked }, updateOption } = setCtx4({
    defaultChecked: checked,
    disabled,
    name: name27,
    required,
    value,
    onCheckedChange: ({ next: next2 }) => {
      if (checked !== next2) {
        onCheckedChange == null ? void 0 : onCheckedChange(next2);
        $$invalidate(7, checked = next2);
      }
      return next2;
    }
  });
  validate_store(root, "root");
  component_subscribe($$self, root, (value2) => $$invalidate(12, $root = value2));
  const dispatch = createDispatcher();
  const attrs = getAttrs5("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props) $$invalidate(7, checked = $$new_props.checked);
    if ("disabled" in $$new_props) $$invalidate(0, disabled = $$new_props.disabled);
    if ("name" in $$new_props) $$invalidate(8, name27 = $$new_props.name);
    if ("required" in $$new_props) $$invalidate(9, required = $$new_props.required);
    if ("value" in $$new_props) $$invalidate(10, value = $$new_props.value);
    if ("onCheckedChange" in $$new_props) $$invalidate(11, onCheckedChange = $$new_props.onCheckedChange);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCtx: setCtx4,
    getAttrs: getAttrs5,
    createDispatcher,
    checked,
    disabled,
    name: name27,
    required,
    value,
    onCheckedChange,
    asChild,
    root,
    localChecked,
    updateOption,
    dispatch,
    attrs,
    builder: builder2,
    $root
  });
  $$self.$inject_state = ($$new_props) => {
    if ("checked" in $$props) $$invalidate(7, checked = $$new_props.checked);
    if ("disabled" in $$props) $$invalidate(0, disabled = $$new_props.disabled);
    if ("name" in $$props) $$invalidate(8, name27 = $$new_props.name);
    if ("required" in $$props) $$invalidate(9, required = $$new_props.required);
    if ("value" in $$props) $$invalidate(10, value = $$new_props.value);
    if ("onCheckedChange" in $$props) $$invalidate(11, onCheckedChange = $$new_props.onCheckedChange);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checked*/
    128) {
      $: checked !== void 0 && localChecked.set(checked);
    }
    if ($$self.$$.dirty & /*disabled*/
    1) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*name*/
    256) {
      $: updateOption("name", name27);
    }
    if ($$self.$$.dirty & /*required*/
    512) {
      $: updateOption("required", required);
    }
    if ($$self.$$.dirty & /*value*/
    1024) {
      $: updateOption("value", value);
    }
    if ($$self.$$.dirty & /*$root*/
    4096) {
      $: $$invalidate(2, builder2 = $root);
    }
  };
  return [
    disabled,
    asChild,
    builder2,
    root,
    dispatch,
    attrs,
    $$restProps,
    checked,
    name27,
    required,
    value,
    onCheckedChange,
    $root,
    $$scope,
    slots
  ];
}
var Checkbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      checked: 7,
      disabled: 0,
      name: 8,
      required: 9,
      value: 10,
      onCheckedChange: 11,
      asChild: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkbox",
      options,
      id: create_fragment21.name
    });
  }
  get checked() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCheckedChange() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCheckedChange(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkbox_default = Checkbox;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/checkbox/components/CheckboxIndicator.svelte
var file21 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/checkbox/components/CheckboxIndicator.svelte";
var get_default_slot_changes20 = (dirty) => ({
  isChecked: dirty & /*$isChecked*/
  1,
  isIndeterminate: dirty & /*$isIndeterminate*/
  2
});
var get_default_slot_context20 = (ctx) => ({
  isChecked: (
    /*$isChecked*/
    ctx[0]
  ),
  isIndeterminate: (
    /*$isIndeterminate*/
    ctx[1]
  )
});
function create_fragment22(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context20
  );
  let div_levels = [
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file21, 7, 0, 166);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $isChecked, $isIndeterminate*/
        67)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes20
            ),
            get_default_slot_context20
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $isChecked;
  let $isIndeterminate;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckboxIndicator", slots, ["default"]);
  const { helpers: { isChecked, isIndeterminate } } = getCtx5();
  validate_store(isChecked, "isChecked");
  component_subscribe($$self, isChecked, (value) => $$invalidate(0, $isChecked = value));
  validate_store(isIndeterminate, "isIndeterminate");
  component_subscribe($$self, isIndeterminate, (value) => $$invalidate(1, $isIndeterminate = value));
  const attrs = getAttrs5("indicator");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getCtx: getCtx5,
    getAttrs: getAttrs5,
    isChecked,
    isIndeterminate,
    attrs,
    $isChecked,
    $isIndeterminate
  });
  return [
    $isChecked,
    $isIndeterminate,
    isChecked,
    isIndeterminate,
    attrs,
    $$restProps,
    $$scope,
    slots
  ];
}
var CheckboxIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckboxIndicator",
      options,
      id: create_fragment22.name
    });
  }
};
var CheckboxIndicator_default = CheckboxIndicator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/checkbox/components/CheckboxInput.svelte
var file22 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/checkbox/components/CheckboxInput.svelte";
function create_fragment23(ctx) {
  let input_1;
  let input_1_value_value;
  let $input_action_action;
  let mounted;
  let dispose;
  let input_1_levels = [
    /*$input*/
    ctx[0],
    {
      value: input_1_value_value = /*$value*/
      ctx[1] ?? "on"
    },
    /*$$restProps*/
    ctx[4]
  ];
  let input_data = {};
  for (let i = 0; i < input_1_levels.length; i += 1) {
    input_data = assign(input_data, input_1_levels[i]);
  }
  const block = {
    c: function create() {
      input_1 = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input_1 = claim_element(nodes, "INPUT", {});
      this.h();
    },
    h: function hydrate() {
      set_attributes(input_1, input_data);
      add_location(input_1, file22, 8, 0, 161);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input_1, anchor);
      if ("value" in input_data) {
        input_1.value = input_data.value;
      }
      if (input_1.autofocus) input_1.focus();
      if (!mounted) {
        dispose = action_destroyer($input_action_action = /*$input*/
        ctx[0].action(input_1));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input_1, input_data = get_spread_update(input_1_levels, [
        dirty & /*$input*/
        1 && /*$input*/
        ctx2[0],
        dirty & /*$value*/
        2 && input_1_value_value !== (input_1_value_value = /*$value*/
        ctx2[1] ?? "on") && input_1.value !== input_1_value_value && { value: input_1_value_value },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      if ("value" in input_data) {
        input_1.value = input_data.value;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input_1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $input;
  let $value;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckboxInput", slots, []);
  const { elements: { input }, options: { value } } = getCtx5();
  validate_store(input, "input");
  component_subscribe($$self, input, (value2) => $$invalidate(0, $input = value2));
  validate_store(value, "value");
  component_subscribe($$self, value, (value2) => $$invalidate(1, $value = value2));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx5,
    input,
    value,
    $input,
    $value
  });
  return [$input, $value, input, value, $$restProps];
}
var CheckboxInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckboxInput",
      options,
      id: create_fragment23.name
    });
  }
};
var CheckboxInput_default = CheckboxInput;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/collapsible/index.js
var collapsible_exports = {};
__export(collapsible_exports, {
  Collapsible: () => Collapsible_default,
  CollapsibleContent: () => CollapsibleContent_default,
  CollapsibleTrigger: () => CollapsibleTrigger_default,
  Content: () => CollapsibleContent_default,
  Root: () => Collapsible_default,
  Trigger: () => CollapsibleTrigger_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/collapsible/ctx.js
var NAME6 = "collapsible";
var PARTS5 = ["root", "content", "trigger"];
var getAttrs6 = createBitAttrs(NAME6, PARTS5);
function setCtx5(props) {
  const collapsible = createCollapsible(removeUndefined2(props));
  setContext(NAME6, collapsible);
  return {
    ...collapsible,
    updateOption: getOptionUpdater(collapsible.options)
  };
}
function getCtx6() {
  return getContext(NAME6);
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/collapsible/components/Collapsible.svelte
var file23 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/collapsible/components/Collapsible.svelte";
var get_default_slot_changes_117 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_117 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes21 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context21 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block17(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context_117
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file23, 37, 1, 769);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1026)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes_117
            ),
            get_default_slot_context_117
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block17.name,
    type: "else",
    source: "(37:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block20(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context21
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1026)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes21
            ),
            get_default_slot_context21
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(35:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block20, create_else_block17];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["forceVisible", "disabled", "open", "onOpenChange", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $root;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Collapsible", slots, ["default"]);
  let { forceVisible = false } = $$props;
  let { disabled = void 0 } = $$props;
  let { open = void 0 } = $$props;
  let { onOpenChange = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { root }, states: { open: localOpen }, updateOption } = setCtx5({
    disabled,
    forceVisible,
    defaultOpen: open,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange == null ? void 0 : onOpenChange(next2);
        $$invalidate(5, open = next2);
      }
      return next2;
    }
  });
  validate_store(root, "root");
  component_subscribe($$self, root, (value) => $$invalidate(9, $root = value));
  const attrs = getAttrs6("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("forceVisible" in $$new_props) $$invalidate(6, forceVisible = $$new_props.forceVisible);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("open" in $$new_props) $$invalidate(5, open = $$new_props.open);
    if ("onOpenChange" in $$new_props) $$invalidate(8, onOpenChange = $$new_props.onOpenChange);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCtx: setCtx5,
    getAttrs: getAttrs6,
    forceVisible,
    disabled,
    open,
    onOpenChange,
    asChild,
    root,
    localOpen,
    updateOption,
    attrs,
    builder: builder2,
    $root
  });
  $$self.$inject_state = ($$new_props) => {
    if ("forceVisible" in $$props) $$invalidate(6, forceVisible = $$new_props.forceVisible);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("open" in $$props) $$invalidate(5, open = $$new_props.open);
    if ("onOpenChange" in $$props) $$invalidate(8, onOpenChange = $$new_props.onOpenChange);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    32) {
      $: open !== void 0 && localOpen.set(open);
    }
    if ($$self.$$.dirty & /*disabled*/
    128) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*forceVisible*/
    64) {
      $: updateOption("forceVisible", forceVisible);
    }
    if ($$self.$$.dirty & /*$root*/
    512) {
      $: $$invalidate(1, builder2 = $root);
    }
  };
  return [
    asChild,
    builder2,
    root,
    attrs,
    $$restProps,
    open,
    forceVisible,
    disabled,
    onOpenChange,
    $root,
    $$scope,
    slots
  ];
}
var Collapsible = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {
      forceVisible: 6,
      disabled: 7,
      open: 5,
      onOpenChange: 8,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Collapsible",
      options,
      id: create_fragment24.name
    });
  }
  get forceVisible() {
    throw new Error("<Collapsible>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forceVisible(value) {
    throw new Error("<Collapsible>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Collapsible>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Collapsible>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Collapsible>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Collapsible>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onOpenChange() {
    throw new Error("<Collapsible>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onOpenChange(value) {
    throw new Error("<Collapsible>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Collapsible>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Collapsible>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Collapsible_default = Collapsible;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/collapsible/components/CollapsibleContent.svelte
var file24 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/collapsible/components/CollapsibleContent.svelte";
var get_default_slot_changes_53 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_53 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_43 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_43 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_33 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_33 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_23 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_23 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_118 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_118 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes22 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context22 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
function create_if_block_54(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context_53
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file24, 43, 1, 1319);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        16512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes_53
            ),
            get_default_slot_context_53
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12],
        /*attrs*/
        ctx2[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_54.name,
    type: "if",
    source: "(43:16) ",
    ctx
  });
  return block;
}
function create_if_block_44(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context_43
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file24, 39, 1, 1158);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        16512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[14],
              dirty,
              get_default_slot_changes_43
            ),
            get_default_slot_context_43
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(39:33) ",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context_33
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file24, 35, 1, 983);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        16512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[14],
              dirty,
              get_default_slot_changes_33
            ),
            get_default_slot_context_33
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(35:32) ",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context_23
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file24, 25, 1, 757);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        16512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[14],
              dirty,
              get_default_slot_changes_23
            ),
            get_default_slot_context_23
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(25:49) ",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context_118
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file24, 21, 1, 562);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        16512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[14],
              dirty,
              get_default_slot_changes_118
            ),
            get_default_slot_context_118
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(21:30) ",
    ctx
  });
  return block;
}
function create_if_block21(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context22
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        16512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes22
            ),
            get_default_slot_context22
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(19:0) {#if asChild && $open}",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block21,
    create_if_block_14,
    create_if_block_24,
    create_if_block_34,
    create_if_block_44,
    create_if_block_54
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$open*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$open*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$open*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 4;
    if (
      /*$open*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $content;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CollapsibleContent", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { content }, states: { open } } = getCtx6();
  validate_store(content, "content");
  component_subscribe($$self, content, (value) => $$invalidate(13, $content = value));
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  const attrs = getAttrs6("content");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx6,
    getAttrs: getAttrs6,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    content,
    open,
    attrs,
    builder: builder2,
    $content,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$content*/
    8192) {
      $: $$invalidate(7, builder2 = $content);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $open,
    content,
    open,
    attrs,
    $$restProps,
    $content,
    $$scope,
    slots
  ];
}
var CollapsibleContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CollapsibleContent",
      options,
      id: create_fragment25.name
    });
  }
  get transition() {
    throw new Error("<CollapsibleContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<CollapsibleContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<CollapsibleContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<CollapsibleContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<CollapsibleContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<CollapsibleContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<CollapsibleContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<CollapsibleContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<CollapsibleContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<CollapsibleContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<CollapsibleContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<CollapsibleContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<CollapsibleContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<CollapsibleContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CollapsibleContent_default = CollapsibleContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/collapsible/components/CollapsibleTrigger.svelte
var file25 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/collapsible/components/CollapsibleTrigger.svelte";
var get_default_slot_changes_119 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_119 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes23 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context23 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block18(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_119
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file25, 16, 1, 391);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_119
            ),
            get_default_slot_context_119
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block18.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context23
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes23
            ),
            get_default_slot_context23
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(14:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block22, create_else_block18];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $trigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CollapsibleTrigger", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { trigger } } = getCtx6();
  validate_store(trigger, "trigger");
  component_subscribe($$self, trigger, (value) => $$invalidate(6, $trigger = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs6("trigger");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    createDispatcher,
    getCtx: getCtx6,
    getAttrs: getAttrs6,
    asChild,
    trigger,
    dispatch,
    attrs,
    builder: builder2,
    $trigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$trigger*/
    64) {
      $: $$invalidate(1, builder2 = $trigger);
    }
  };
  return [
    asChild,
    builder2,
    trigger,
    dispatch,
    attrs,
    $$restProps,
    $trigger,
    $$scope,
    slots
  ];
}
var CollapsibleTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CollapsibleTrigger",
      options,
      id: create_fragment26.name
    });
  }
  get asChild() {
    throw new Error("<CollapsibleTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<CollapsibleTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CollapsibleTrigger_default = CollapsibleTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/index.js
var context_menu_exports = {};
__export(context_menu_exports, {
  Arrow: () => ContextMenuArrow_default,
  CheckboxIndicator: () => ContextMenuCheckboxIndicator_default,
  CheckboxItem: () => ContextMenuCheckboxItem_default,
  Content: () => ContextMenuContent_default,
  ContextMenu: () => ContextMenu_default,
  ContextMenuArrow: () => ContextMenuArrow_default,
  ContextMenuCheckboxIndicator: () => ContextMenuCheckboxIndicator_default,
  ContextMenuCheckboxItem: () => ContextMenuCheckboxItem_default,
  ContextMenuContent: () => ContextMenuContent_default,
  ContextMenuGroup: () => ContextMenuGroup_default,
  ContextMenuItem: () => ContextMenuItem_default,
  ContextMenuLabel: () => ContextMenuLabel_default,
  ContextMenuRadioGroup: () => ContextMenuRadioGroup_default,
  ContextMenuRadioIndicator: () => ContextMenuRadioIndicator_default,
  ContextMenuRadioItem: () => ContextMenuRadioItem_default,
  ContextMenuSeparator: () => ContextMenuSeparator_default,
  ContextMenuSub: () => ContextMenuSub_default,
  ContextMenuSubContent: () => ContextMenuSubContent_default,
  ContextMenuSubTrigger: () => ContextMenuSubTrigger_default,
  ContextMenuTrigger: () => ContextMenuTrigger_default,
  Group: () => ContextMenuGroup_default,
  Item: () => ContextMenuItem_default,
  Label: () => ContextMenuLabel_default,
  RadioGroup: () => ContextMenuRadioGroup_default,
  RadioIndicator: () => ContextMenuRadioIndicator_default,
  RadioItem: () => ContextMenuRadioItem_default,
  Root: () => ContextMenu_default,
  Separator: () => ContextMenuSeparator_default,
  Sub: () => ContextMenuSub_default,
  SubContent: () => ContextMenuSubContent_default,
  SubTrigger: () => ContextMenuSubTrigger_default,
  Trigger: () => ContextMenuTrigger_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/ctx.js
var NAME7 = "context-menu";
var SUB_NAME = "context-menu-submenu";
var RADIO_GROUP_NAME = "context-menu-radiogroup";
var CHECKBOX_ITEM_NAME = "context-menu-checkboxitem";
var RADIO_ITEM_NAME = "context-menu-radioitem";
var GROUP_NAME2 = "context-menu-group";
var PARTS6 = [
  "arrow",
  "checkbox-indicator",
  "checkbox-item",
  "content",
  "group",
  "item",
  "label",
  "radio-group",
  "radio-item",
  "separator",
  "sub-content",
  "sub-trigger",
  "trigger"
];
var getAttrs7 = createBitAttrs(NAME7, PARTS6);
function setCtx6(props) {
  const contextMenu = createContextMenu(removeUndefined2(props));
  setContext(NAME7, contextMenu);
  return {
    ...contextMenu,
    updateOption: getOptionUpdater(contextMenu.options)
  };
}
function getCtx7() {
  return getContext(NAME7);
}
function setSubMenuCtx(props) {
  const { builders: { createSubmenu } } = getCtx7();
  const sub = createSubmenu(removeUndefined2(props));
  setContext(SUB_NAME, sub);
  return {
    ...sub,
    updateOption: getOptionUpdater(sub.options)
  };
}
function getSubMenuCtx() {
  return getContext(SUB_NAME);
}
function setRadioGroupCtx(props) {
  const { builders: { createMenuRadioGroup } } = getCtx7();
  const radioGroup = createMenuRadioGroup(removeUndefined2(props));
  setContext(RADIO_GROUP_NAME, radioGroup);
  return radioGroup;
}
function getRadioGroupCtx() {
  return getContext(RADIO_GROUP_NAME);
}
function setRadioItem(value) {
  const radioGroup = getRadioGroupCtx();
  setContext(RADIO_ITEM_NAME, {
    isChecked: radioGroup.helpers.isChecked,
    value
  });
  return radioGroup;
}
function getRadioIndicator() {
  return getContext(RADIO_ITEM_NAME);
}
function getContent2(sideoffset = 5) {
  const menu = getCtx7();
  menu.options.positioning.update((prev2) => ({ ...prev2, gutter: sideoffset }));
  return menu;
}
function getSubContent(sideOffset = -1) {
  const submenu = getSubMenuCtx();
  const { options: { positioning } } = submenu;
  positioning.update((prev2) => ({ ...prev2, gutter: sideOffset }));
  return submenu;
}
function setCheckboxItem(props) {
  const { builders: { createCheckboxItem } } = getCtx7();
  const checkboxItem = createCheckboxItem(removeUndefined2(props));
  setContext(CHECKBOX_ITEM_NAME, checkboxItem.states.checked);
  return {
    ...checkboxItem,
    updateOption: getOptionUpdater(checkboxItem.options)
  };
}
function getCheckboxIndicator() {
  return getContext(CHECKBOX_ITEM_NAME);
}
function setGroup() {
  const { elements: { group } } = getCtx7();
  const id = generateId3();
  setContext(GROUP_NAME2, id);
  return { group, id };
}
function getGroupLabel() {
  const id = getContext(GROUP_NAME2) ?? generateId3();
  const { elements: { groupLabel } } = getCtx7();
  return { groupLabel, id };
}
function setArrow(size2 = 8) {
  const menu = getCtx7();
  menu.options.arrowSize.set(size2);
  return menu;
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenu.svelte
var get_default_slot_changes24 = (dirty) => ({});
var get_default_slot_context24 = (ctx) => ({ ids: (
  /*ids*/
  ctx[0]
) });
function create_fragment27(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context24
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes24
            ),
            get_default_slot_context24
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenu", slots, ["default"]);
  let { closeOnOutsideClick = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { portal = void 0 } = $$props;
  let { forceVisible = true } = $$props;
  let { open = void 0 } = $$props;
  let { onOpenChange = void 0 } = $$props;
  let { preventScroll = void 0 } = $$props;
  let { arrowSize = void 0 } = $$props;
  let { positioning = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { dir = void 0 } = $$props;
  let { typeahead = void 0 } = $$props;
  let { closeFocus = void 0 } = $$props;
  let { disableFocusFirstItem = void 0 } = $$props;
  const { states: { open: localOpen }, updateOption, ids } = setCtx6({
    closeOnOutsideClick,
    closeOnEscape,
    portal,
    forceVisible,
    defaultOpen: open,
    preventScroll,
    arrowSize,
    positioning,
    loop,
    dir,
    typeahead,
    disableFocusFirstItem,
    closeFocus,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange == null ? void 0 : onOpenChange(next2);
        $$invalidate(1, open = next2);
      }
      return next2;
    }
  });
  const writable_props = [
    "closeOnOutsideClick",
    "closeOnEscape",
    "portal",
    "forceVisible",
    "open",
    "onOpenChange",
    "preventScroll",
    "arrowSize",
    "positioning",
    "loop",
    "dir",
    "typeahead",
    "closeFocus",
    "disableFocusFirstItem"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ContextMenu> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("closeOnOutsideClick" in $$props2) $$invalidate(2, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("closeOnEscape" in $$props2) $$invalidate(3, closeOnEscape = $$props2.closeOnEscape);
    if ("portal" in $$props2) $$invalidate(4, portal = $$props2.portal);
    if ("forceVisible" in $$props2) $$invalidate(5, forceVisible = $$props2.forceVisible);
    if ("open" in $$props2) $$invalidate(1, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(6, onOpenChange = $$props2.onOpenChange);
    if ("preventScroll" in $$props2) $$invalidate(7, preventScroll = $$props2.preventScroll);
    if ("arrowSize" in $$props2) $$invalidate(8, arrowSize = $$props2.arrowSize);
    if ("positioning" in $$props2) $$invalidate(9, positioning = $$props2.positioning);
    if ("loop" in $$props2) $$invalidate(10, loop = $$props2.loop);
    if ("dir" in $$props2) $$invalidate(11, dir = $$props2.dir);
    if ("typeahead" in $$props2) $$invalidate(12, typeahead = $$props2.typeahead);
    if ("closeFocus" in $$props2) $$invalidate(13, closeFocus = $$props2.closeFocus);
    if ("disableFocusFirstItem" in $$props2) $$invalidate(14, disableFocusFirstItem = $$props2.disableFocusFirstItem);
    if ("$$scope" in $$props2) $$invalidate(15, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setCtx: setCtx6,
    closeOnOutsideClick,
    closeOnEscape,
    portal,
    forceVisible,
    open,
    onOpenChange,
    preventScroll,
    arrowSize,
    positioning,
    loop,
    dir,
    typeahead,
    closeFocus,
    disableFocusFirstItem,
    localOpen,
    updateOption,
    ids
  });
  $$self.$inject_state = ($$props2) => {
    if ("closeOnOutsideClick" in $$props2) $$invalidate(2, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("closeOnEscape" in $$props2) $$invalidate(3, closeOnEscape = $$props2.closeOnEscape);
    if ("portal" in $$props2) $$invalidate(4, portal = $$props2.portal);
    if ("forceVisible" in $$props2) $$invalidate(5, forceVisible = $$props2.forceVisible);
    if ("open" in $$props2) $$invalidate(1, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(6, onOpenChange = $$props2.onOpenChange);
    if ("preventScroll" in $$props2) $$invalidate(7, preventScroll = $$props2.preventScroll);
    if ("arrowSize" in $$props2) $$invalidate(8, arrowSize = $$props2.arrowSize);
    if ("positioning" in $$props2) $$invalidate(9, positioning = $$props2.positioning);
    if ("loop" in $$props2) $$invalidate(10, loop = $$props2.loop);
    if ("dir" in $$props2) $$invalidate(11, dir = $$props2.dir);
    if ("typeahead" in $$props2) $$invalidate(12, typeahead = $$props2.typeahead);
    if ("closeFocus" in $$props2) $$invalidate(13, closeFocus = $$props2.closeFocus);
    if ("disableFocusFirstItem" in $$props2) $$invalidate(14, disableFocusFirstItem = $$props2.disableFocusFirstItem);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    2) {
      $: open !== void 0 && localOpen.set(open);
    }
    if ($$self.$$.dirty & /*closeOnOutsideClick*/
    4) {
      $: updateOption("closeOnOutsideClick", closeOnOutsideClick);
    }
    if ($$self.$$.dirty & /*closeOnEscape*/
    8) {
      $: updateOption("closeOnEscape", closeOnEscape);
    }
    if ($$self.$$.dirty & /*portal*/
    16) {
      $: updateOption("portal", portal);
    }
    if ($$self.$$.dirty & /*forceVisible*/
    32) {
      $: updateOption("forceVisible", forceVisible);
    }
    if ($$self.$$.dirty & /*preventScroll*/
    128) {
      $: updateOption("preventScroll", preventScroll);
    }
    if ($$self.$$.dirty & /*arrowSize*/
    256) {
      $: updateOption("arrowSize", arrowSize);
    }
    if ($$self.$$.dirty & /*positioning*/
    512) {
      $: updateOption("positioning", positioning);
    }
    if ($$self.$$.dirty & /*loop*/
    1024) {
      $: updateOption("loop", loop);
    }
    if ($$self.$$.dirty & /*dir*/
    2048) {
      $: updateOption("dir", dir);
    }
    if ($$self.$$.dirty & /*closeFocus*/
    8192) {
      $: updateOption("closeFocus", closeFocus);
    }
    if ($$self.$$.dirty & /*disableFocusFirstItem*/
    16384) {
      $: updateOption("disableFocusFirstItem", disableFocusFirstItem);
    }
    if ($$self.$$.dirty & /*typeahead*/
    4096) {
      $: updateOption("typeahead", typeahead);
    }
  };
  return [
    ids,
    open,
    closeOnOutsideClick,
    closeOnEscape,
    portal,
    forceVisible,
    onOpenChange,
    preventScroll,
    arrowSize,
    positioning,
    loop,
    dir,
    typeahead,
    closeFocus,
    disableFocusFirstItem,
    $$scope,
    slots
  ];
}
var ContextMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {
      closeOnOutsideClick: 2,
      closeOnEscape: 3,
      portal: 4,
      forceVisible: 5,
      open: 1,
      onOpenChange: 6,
      preventScroll: 7,
      arrowSize: 8,
      positioning: 9,
      loop: 10,
      dir: 11,
      typeahead: 12,
      closeFocus: 13,
      disableFocusFirstItem: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenu",
      options,
      id: create_fragment27.name
    });
  }
  get closeOnOutsideClick() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnOutsideClick(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get portal() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portal(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forceVisible() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forceVisible(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onOpenChange() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onOpenChange(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventScroll() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScroll(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowSize() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowSize(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positioning() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioning(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dir() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dir(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get typeahead() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set typeahead(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeFocus() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeFocus(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableFocusFirstItem() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableFocusFirstItem(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenu_default = ContextMenu;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuSub.svelte
var get_default_slot_changes25 = (dirty) => ({});
var get_default_slot_context25 = (ctx) => ({ subIds: (
  /*ids*/
  ctx[0]
) });
function create_fragment28(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_default_slot_context25
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_default_slot_changes25
            ),
            get_default_slot_context25
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuSub", slots, ["default"]);
  let { positioning = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { arrowSize = void 0 } = $$props;
  const { updateOption, ids } = setSubMenuCtx({ positioning, disabled, arrowSize });
  const writable_props = ["positioning", "disabled", "arrowSize"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ContextMenuSub> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("positioning" in $$props2) $$invalidate(1, positioning = $$props2.positioning);
    if ("disabled" in $$props2) $$invalidate(2, disabled = $$props2.disabled);
    if ("arrowSize" in $$props2) $$invalidate(3, arrowSize = $$props2.arrowSize);
    if ("$$scope" in $$props2) $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setSubMenuCtx,
    positioning,
    disabled,
    arrowSize,
    updateOption,
    ids
  });
  $$self.$inject_state = ($$props2) => {
    if ("positioning" in $$props2) $$invalidate(1, positioning = $$props2.positioning);
    if ("disabled" in $$props2) $$invalidate(2, disabled = $$props2.disabled);
    if ("arrowSize" in $$props2) $$invalidate(3, arrowSize = $$props2.arrowSize);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*positioning*/
    2) {
      $: updateOption("positioning", positioning);
    }
    if ($$self.$$.dirty & /*disabled*/
    4) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*arrowSize*/
    8) {
      $: updateOption("arrowSize", arrowSize);
    }
  };
  return [ids, positioning, disabled, arrowSize, $$scope, slots];
}
var ContextMenuSub = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      positioning: 1,
      disabled: 2,
      arrowSize: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuSub",
      options,
      id: create_fragment28.name
    });
  }
  get positioning() {
    throw new Error("<ContextMenuSub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioning(value) {
    throw new Error("<ContextMenuSub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ContextMenuSub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ContextMenuSub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowSize() {
    throw new Error("<ContextMenuSub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowSize(value) {
    throw new Error("<ContextMenuSub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuSub_default = ContextMenuSub;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuItem.svelte
var file26 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuItem.svelte";
var get_default_slot_changes_120 = (dirty) => ({
  builder: dirty & /*builder*/
  4,
  attrs: dirty & /*attrs*/
  2
});
var get_default_slot_context_120 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[1]
  )
});
var get_default_slot_changes26 = (dirty) => ({
  builder: dirty & /*builder*/
  4,
  attrs: dirty & /*attrs*/
  2
});
var get_default_slot_context26 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[1]
  )
});
function create_else_block19(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_120
  );
  let div_levels = [
    /*builder*/
    ctx[2],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file26, 19, 1, 505);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[2].action(div)),
          listen_dev(
            div,
            "m-click",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusin",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        262)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_120
            ),
            get_default_slot_context_120
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        4 && /*builder*/
        ctx2[2],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        dirty & /*attrs*/
        2 && /*attrs*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block19.name,
    type: "else",
    source: "(19:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block23(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context26
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        262)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes26
            ),
            get_default_slot_context26
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(17:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block23, create_else_block19];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  let builder2;
  let attrs;
  const omit_props_names = ["asChild", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $item;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuItem", slots, ["default"]);
  let { asChild = false } = $$props;
  let { disabled = false } = $$props;
  const { elements: { item } } = getCtx7();
  validate_store(item, "item");
  component_subscribe($$self, item, (value) => $$invalidate(7, $item = value));
  const dispatch = createDispatcher();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("disabled" in $$new_props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx7,
    getAttrs: getAttrs7,
    disabledAttrs,
    createDispatcher,
    asChild,
    disabled,
    item,
    dispatch,
    attrs,
    builder: builder2,
    $item
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("disabled" in $$props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("attrs" in $$props) $$invalidate(1, attrs = $$new_props.attrs);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$item*/
    128) {
      $: $$invalidate(2, builder2 = $item);
    }
    if ($$self.$$.dirty & /*disabled*/
    64) {
      $: $$invalidate(1, attrs = {
        ...getAttrs7("item"),
        ...disabledAttrs(disabled)
      });
    }
  };
  return [
    asChild,
    attrs,
    builder2,
    item,
    dispatch,
    $$restProps,
    disabled,
    $item,
    $$scope,
    slots
  ];
}
var ContextMenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, { asChild: 0, disabled: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuItem",
      options,
      id: create_fragment29.name
    });
  }
  get asChild() {
    throw new Error("<ContextMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ContextMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ContextMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ContextMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuItem_default = ContextMenuItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuGroup.svelte
var file27 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuGroup.svelte";
var get_default_slot_changes_121 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_121 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes27 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context27 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block20(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context_121
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file27, 12, 1, 280);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes_121
            ),
            get_default_slot_context_121
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block20.name,
    type: "else",
    source: "(12:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block24(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context27
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes27
            ),
            get_default_slot_context27
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(10:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block24, create_else_block20];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $group;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuGroup", slots, ["default"]);
  let { asChild = false } = $$props;
  const { group, id } = setGroup();
  validate_store(group, "group");
  component_subscribe($$self, group, (value) => $$invalidate(5, $group = value));
  const attrs = getAttrs7("group");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setGroup,
    getAttrs: getAttrs7,
    asChild,
    group,
    id,
    attrs,
    builder: builder2,
    $group
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$group*/
    32) {
      $: $$invalidate(1, builder2 = $group(id));
    }
  };
  return [asChild, builder2, group, attrs, $$restProps, $group, $$scope, slots];
}
var ContextMenuGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuGroup",
      options,
      id: create_fragment30.name
    });
  }
  get asChild() {
    throw new Error("<ContextMenuGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ContextMenuGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuGroup_default = ContextMenuGroup;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuLabel.svelte
var file28 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuLabel.svelte";
var get_default_slot_changes_122 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_122 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes28 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context28 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block21(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context_122
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file28, 12, 1, 300);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes_122
            ),
            get_default_slot_context_122
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block21.name,
    type: "else",
    source: "(12:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block25(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context28
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes28
            ),
            get_default_slot_context28
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: "(10:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block25, create_else_block21];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $groupLabel;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuLabel", slots, ["default"]);
  let { asChild = false } = $$props;
  const { groupLabel, id } = getGroupLabel();
  validate_store(groupLabel, "groupLabel");
  component_subscribe($$self, groupLabel, (value) => $$invalidate(5, $groupLabel = value));
  const attrs = getAttrs7("label");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getGroupLabel,
    getAttrs: getAttrs7,
    asChild,
    groupLabel,
    id,
    attrs,
    builder: builder2,
    $groupLabel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$groupLabel*/
    32) {
      $: $$invalidate(1, builder2 = $groupLabel(id));
    }
  };
  return [asChild, builder2, groupLabel, attrs, $$restProps, $groupLabel, $$scope, slots];
}
var ContextMenuLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuLabel",
      options,
      id: create_fragment31.name
    });
  }
  get asChild() {
    throw new Error("<ContextMenuLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ContextMenuLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuLabel_default = ContextMenuLabel;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuArrow.svelte
var file29 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuArrow.svelte";
var get_default_slot_changes29 = (dirty) => ({ builder: dirty & /*builder*/
4 });
var get_default_slot_context29 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block22(ctx) {
  let div;
  let $arrow_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*$arrow*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file29, 15, 1, 313);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer($arrow_action_action = /*$arrow*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$arrow*/
        2 && /*$arrow*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block22.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block26(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context29
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        132)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes29
            ),
            get_default_slot_context29
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(13:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block26, create_else_block22];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["size", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $arrow;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuArrow", slots, ["default"]);
  let { size: size2 = 8 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { arrow: arrow2 } } = setArrow(size2);
  validate_store(arrow2, "arrow");
  component_subscribe($$self, arrow2, (value) => $$invalidate(1, $arrow = value));
  const attrs = getAttrs7("arrow");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(6, size2 = $$new_props.size);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setArrow,
    getAttrs: getAttrs7,
    size: size2,
    asChild,
    arrow: arrow2,
    attrs,
    builder: builder2,
    $arrow
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props) $$invalidate(6, size2 = $$new_props.size);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$arrow*/
    2) {
      $: $$invalidate(2, builder2 = $arrow);
    }
  };
  return [asChild, $arrow, builder2, arrow2, attrs, $$restProps, size2, $$scope, slots];
}
var ContextMenuArrow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, { size: 6, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuArrow",
      options,
      id: create_fragment32.name
    });
  }
  get size() {
    throw new Error("<ContextMenuArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ContextMenuArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<ContextMenuArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ContextMenuArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuArrow_default = ContextMenuArrow;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuContent.svelte
var file30 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuContent.svelte";
var get_default_slot_changes_54 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_54 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_44 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_44 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_34 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_34 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_24 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_24 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_123 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_123 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes30 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context30 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
function create_if_block_55(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_54
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file30, 71, 1, 1665);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes_54
            ),
            get_default_slot_context_54
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13],
        /*attrs*/
        ctx2[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_55.name,
    type: "if",
    source: "(71:16) ",
    ctx
  });
  return block;
}
function create_if_block_45(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_44
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file30, 61, 1, 1468);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_44
            ),
            get_default_slot_context_44
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_45.name,
    type: "if",
    source: "(61:33) ",
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_34
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file30, 51, 1, 1257);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_34
            ),
            get_default_slot_context_34
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(51:32) ",
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_24
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file30, 40, 1, 1005);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_24
            ),
            get_default_slot_context_24
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(40:49) ",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_123
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file30, 30, 1, 774);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_123
            ),
            get_default_slot_context_123
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(30:30) ",
    ctx
  });
  return block;
}
function create_if_block27(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context30
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes30
            ),
            get_default_slot_context30
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(28:0) {#if asChild && $open}",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block27,
    create_if_block_15,
    create_if_block_25,
    create_if_block_35,
    create_if_block_45,
    create_if_block_55
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$open*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$open*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$open*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 4;
    if (
      /*$open*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "sideOffset",
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $menu;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuContent", slots, ["default"]);
  let { sideOffset = 5 } = $$props;
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { menu }, states: { open }, ids } = getContent2(sideOffset);
  validate_store(menu, "menu");
  component_subscribe($$self, menu, (value) => $$invalidate(16, $menu = value));
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs7("content");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("sideOffset" in $$new_props) $$invalidate(14, sideOffset = $$new_props.sideOffset);
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(15, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createDispatcher,
    melt,
    getContent: getContent2,
    getAttrs: getAttrs7,
    sideOffset,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    menu,
    open,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $menu,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("sideOffset" in $$props) $$invalidate(14, sideOffset = $$new_props.sideOffset);
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(15, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    32768) {
      $: if (id) {
        ids.menu.set(id);
      }
    }
    if ($$self.$$.dirty & /*$menu*/
    65536) {
      $: $$invalidate(7, builder2 = $menu);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $open,
    menu,
    open,
    dispatch,
    attrs,
    $$restProps,
    sideOffset,
    id,
    $menu,
    $$scope,
    slots
  ];
}
var ContextMenuContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, {
      sideOffset: 14,
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6,
      id: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuContent",
      options,
      id: create_fragment33.name
    });
  }
  get sideOffset() {
    throw new Error("<ContextMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sideOffset(value) {
    throw new Error("<ContextMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<ContextMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<ContextMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<ContextMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<ContextMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<ContextMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<ContextMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<ContextMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<ContextMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<ContextMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<ContextMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<ContextMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<ContextMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<ContextMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ContextMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ContextMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ContextMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuContent_default = ContextMenuContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuTrigger.svelte
var file31 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuTrigger.svelte";
var get_default_slot_changes_124 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_124 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes31 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context31 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block23(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_124
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file31, 23, 1, 556);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(div)),
          listen_dev(
            div,
            "m-contextmenu",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointercancel",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerup",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_124
            ),
            get_default_slot_context_124
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block23.name,
    type: "else",
    source: "(23:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block28(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context31
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes31
            ),
            get_default_slot_context31
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(21:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block28, create_else_block23];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $trigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuTrigger", slots, ["default"]);
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { trigger }, ids } = getCtx7();
  validate_store(trigger, "trigger");
  component_subscribe($$self, trigger, (value) => $$invalidate(7, $trigger = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs7("trigger");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(6, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx7,
    getAttrs: getAttrs7,
    createDispatcher,
    asChild,
    id,
    trigger,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $trigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(6, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    64) {
      $: if (id) {
        ids.trigger.set(id);
      }
    }
    if ($$self.$$.dirty & /*$trigger*/
    128) {
      $: $$invalidate(1, builder2 = $trigger);
    }
  };
  return [
    asChild,
    builder2,
    trigger,
    dispatch,
    attrs,
    $$restProps,
    id,
    $trigger,
    $$scope,
    slots
  ];
}
var ContextMenuTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, { asChild: 0, id: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuTrigger",
      options,
      id: create_fragment34.name
    });
  }
  get asChild() {
    throw new Error("<ContextMenuTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ContextMenuTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ContextMenuTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ContextMenuTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuTrigger_default = ContextMenuTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuRadioItem.svelte
var file32 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuRadioItem.svelte";
var get_default_slot_changes_125 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_125 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes32 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context32 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block24(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context_125
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file32, 18, 1, 483);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(div)),
          listen_dev(
            div,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusin",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes_125
            ),
            get_default_slot_context_125
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block24.name,
    type: "else",
    source: "(18:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block29(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context32
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes32
            ),
            get_default_slot_context32
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(16:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block29, create_else_block24];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["value", "disabled", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $radioItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuRadioItem", slots, ["default"]);
  let { value } = $$props;
  let { disabled = false } = $$props;
  let { asChild = false } = $$props;
  const { elements: { radioItem } } = setRadioItem(value);
  validate_store(radioItem, "radioItem");
  component_subscribe($$self, radioItem, (value2) => $$invalidate(8, $radioItem = value2));
  const dispatch = createDispatcher();
  const attrs = getAttrs7("radio-item");
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<ContextMenuRadioItem> was created without expected prop 'value'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setRadioItem,
    getAttrs: getAttrs7,
    createDispatcher,
    value,
    disabled,
    asChild,
    radioItem,
    dispatch,
    attrs,
    builder: builder2,
    $radioItem
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$radioItem, value, disabled*/
    448) {
      $: $$invalidate(1, builder2 = $radioItem({ value, disabled }));
    }
  };
  return [
    asChild,
    builder2,
    radioItem,
    dispatch,
    attrs,
    $$restProps,
    value,
    disabled,
    $radioItem,
    $$scope,
    slots
  ];
}
var ContextMenuRadioItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, { value: 6, disabled: 7, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuRadioItem",
      options,
      id: create_fragment35.name
    });
  }
  get value() {
    throw new Error("<ContextMenuRadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ContextMenuRadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ContextMenuRadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ContextMenuRadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<ContextMenuRadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ContextMenuRadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuRadioItem_default = ContextMenuRadioItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuSeparator.svelte
var file33 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuSeparator.svelte";
var get_default_slot_changes33 = (dirty) => ({ builder: dirty & /*builder*/
4 });
var get_default_slot_context33 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block25(ctx) {
  let div;
  let $separator_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*$separator*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file33, 14, 1, 296);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer($separator_action_action = /*$separator*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$separator*/
        2 && /*$separator*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block25.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block30(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context33
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        68)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes33
            ),
            get_default_slot_context33
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block30.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block30, create_else_block25];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $separator;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuSeparator", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { separator } } = getCtx7();
  validate_store(separator, "separator");
  component_subscribe($$self, separator, (value) => $$invalidate(1, $separator = value));
  const attrs = getAttrs7("separator");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx7,
    getAttrs: getAttrs7,
    asChild,
    separator,
    attrs,
    builder: builder2,
    $separator
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$separator*/
    2) {
      $: $$invalidate(2, builder2 = $separator);
    }
  };
  return [asChild, $separator, builder2, separator, attrs, $$restProps, $$scope, slots];
}
var ContextMenuSeparator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuSeparator",
      options,
      id: create_fragment36.name
    });
  }
  get asChild() {
    throw new Error("<ContextMenuSeparator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ContextMenuSeparator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuSeparator_default = ContextMenuSeparator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuRadioGroup.svelte
var file34 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuRadioGroup.svelte";
var get_default_slot_changes_126 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_126 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes34 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context34 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block26(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_126
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file34, 28, 1, 632);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_126
            ),
            get_default_slot_context_126
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block26.name,
    type: "else",
    source: "(28:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block31(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context34
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes34
            ),
            get_default_slot_context34
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block31.name,
    type: "if",
    source: "(26:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block31, create_else_block26];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["value", "onValueChange", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $radioGroup;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuRadioGroup", slots, ["default"]);
  let { value = void 0 } = $$props;
  let { onValueChange = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { radioGroup }, states: { value: localValue } } = setRadioGroupCtx({
    defaultValue: value,
    onValueChange: ({ next: next2 }) => {
      if (next2 && value !== next2) {
        onValueChange == null ? void 0 : onValueChange(next2);
        $$invalidate(5, value = next2);
      }
      return next2;
    }
  });
  validate_store(radioGroup, "radioGroup");
  component_subscribe($$self, radioGroup, (value2) => $$invalidate(7, $radioGroup = value2));
  const attrs = getAttrs7("radio-group");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$new_props) $$invalidate(6, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setRadioGroupCtx,
    getAttrs: getAttrs7,
    value,
    onValueChange,
    asChild,
    radioGroup,
    localValue,
    attrs,
    builder: builder2,
    $radioGroup
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$props) $$invalidate(6, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    32) {
      $: value !== void 0 && localValue.set(value);
    }
    if ($$self.$$.dirty & /*$radioGroup*/
    128) {
      $: $$invalidate(1, builder2 = $radioGroup);
    }
  };
  return [
    asChild,
    builder2,
    radioGroup,
    attrs,
    $$restProps,
    value,
    onValueChange,
    $radioGroup,
    $$scope,
    slots
  ];
}
var ContextMenuRadioGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { value: 5, onValueChange: 6, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuRadioGroup",
      options,
      id: create_fragment37.name
    });
  }
  get value() {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValueChange() {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValueChange(value) {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuRadioGroup_default = ContextMenuRadioGroup;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuSubContent.svelte
var file35 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuSubContent.svelte";
var get_default_slot_changes_55 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_55 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_45 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_45 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_35 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_35 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_25 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_25 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_127 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_127 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes35 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context35 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
function create_if_block_56(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_55
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file35, 79, 1, 1975);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes_55
            ),
            get_default_slot_context_55
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13],
        /*attrs*/
        ctx2[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_56.name,
    type: "if",
    source: "(79:19) ",
    ctx
  });
  return block;
}
function create_if_block_46(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_45
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file35, 67, 1, 1718);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_45
            ),
            get_default_slot_context_45
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_46.name,
    type: "if",
    source: "(67:36) ",
    ctx
  });
  return block;
}
function create_if_block_36(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_35
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file35, 55, 1, 1447);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_35
            ),
            get_default_slot_context_35
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_36.name,
    type: "if",
    source: "(55:35) ",
    ctx
  });
  return block;
}
function create_if_block_26(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_25
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file35, 42, 1, 1135);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_25
            ),
            get_default_slot_context_25
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(42:52) ",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_127
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file35, 30, 1, 844);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_127
            ),
            get_default_slot_context_127
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(30:33) ",
    ctx
  });
  return block;
}
function create_if_block32(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context35
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes35
            ),
            get_default_slot_context35
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block32.name,
    type: "if",
    source: "(28:0) {#if asChild && $subOpen}",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block32,
    create_if_block_16,
    create_if_block_26,
    create_if_block_36,
    create_if_block_46,
    create_if_block_56
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$subOpen*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$subOpen*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$subOpen*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$subOpen*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$subOpen*/
      ctx2[8]
    ) return 4;
    if (
      /*$subOpen*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $subMenu;
  let $subOpen;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuSubContent", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { subMenu }, states: { subOpen }, ids } = getSubContent();
  validate_store(subMenu, "subMenu");
  component_subscribe($$self, subMenu, (value) => $$invalidate(15, $subMenu = value));
  validate_store(subOpen, "subOpen");
  component_subscribe($$self, subOpen, (value) => $$invalidate(8, $subOpen = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs7("sub-content");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(14, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createDispatcher,
    melt,
    getSubContent,
    getAttrs: getAttrs7,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    subMenu,
    subOpen,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $subMenu,
    $subOpen
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(14, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$subMenu*/
    32768) {
      $: $$invalidate(7, builder2 = $subMenu);
    }
    if ($$self.$$.dirty & /*id*/
    16384) {
      $: if (id) {
        ids.menu.set(id);
      }
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $subOpen,
    subMenu,
    subOpen,
    dispatch,
    attrs,
    $$restProps,
    id,
    $subMenu,
    $$scope,
    slots
  ];
}
var ContextMenuSubContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6,
      id: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuSubContent",
      options,
      id: create_fragment38.name
    });
  }
  get transition() {
    throw new Error("<ContextMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<ContextMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<ContextMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<ContextMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<ContextMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<ContextMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<ContextMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<ContextMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<ContextMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<ContextMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<ContextMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<ContextMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<ContextMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ContextMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ContextMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ContextMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuSubContent_default = ContextMenuSubContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuSubTrigger.svelte
var file36 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuSubTrigger.svelte";
var get_default_slot_changes_128 = (dirty) => ({
  builder: dirty & /*builder*/
  4,
  attrs: dirty & /*attrs*/
  2
});
var get_default_slot_context_128 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[1]
  )
});
var get_default_slot_changes36 = (dirty) => ({
  builder: dirty & /*builder*/
  4,
  attrs: dirty & /*attrs*/
  2
});
var get_default_slot_context36 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[1]
  )
});
function create_else_block27(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context_128
  );
  let div_levels = [
    /*builder*/
    ctx[2],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file36, 26, 1, 696);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[2].action(div)),
          listen_dev(
            div,
            "m-click",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusin",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        518)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes_128
            ),
            get_default_slot_context_128
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        4 && /*builder*/
        ctx2[2],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        dirty & /*attrs*/
        2 && /*attrs*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block27.name,
    type: "else",
    source: "(26:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block33(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context36
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        518)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes36
            ),
            get_default_slot_context36
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block33.name,
    type: "if",
    source: "(24:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block33, create_else_block27];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let builder2;
  let attrs;
  const omit_props_names = ["disabled", "asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $subTrigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuSubTrigger", slots, ["default"]);
  let { disabled = false } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { subTrigger }, ids } = getSubMenuCtx();
  validate_store(subTrigger, "subTrigger");
  component_subscribe($$self, subTrigger, (value) => $$invalidate(8, $subTrigger = value));
  const dispatch = createDispatcher();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("disabled" in $$new_props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getSubMenuCtx,
    getAttrs: getAttrs7,
    disabledAttrs,
    createDispatcher,
    disabled,
    asChild,
    id,
    subTrigger,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $subTrigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("disabled" in $$props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
    if ("attrs" in $$props) $$invalidate(1, attrs = $$new_props.attrs);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    128) {
      $: if (id) {
        ids.trigger.set(id);
      }
    }
    if ($$self.$$.dirty & /*$subTrigger*/
    256) {
      $: $$invalidate(2, builder2 = $subTrigger);
    }
    if ($$self.$$.dirty & /*disabled*/
    64) {
      $: $$invalidate(1, attrs = {
        ...getAttrs7("sub-trigger"),
        ...disabledAttrs(disabled)
      });
    }
  };
  return [
    asChild,
    attrs,
    builder2,
    subTrigger,
    dispatch,
    $$restProps,
    disabled,
    id,
    $subTrigger,
    $$scope,
    slots
  ];
}
var ContextMenuSubTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, { disabled: 6, asChild: 0, id: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuSubTrigger",
      options,
      id: create_fragment39.name
    });
  }
  get disabled() {
    throw new Error("<ContextMenuSubTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ContextMenuSubTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<ContextMenuSubTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ContextMenuSubTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ContextMenuSubTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ContextMenuSubTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuSubTrigger_default = ContextMenuSubTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuCheckboxItem.svelte
var file37 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuCheckboxItem.svelte";
var get_default_slot_changes_129 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_129 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes37 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context37 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block28(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context_129
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file37, 36, 1, 944);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(div)),
          listen_dev(
            div,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusin",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1026)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes_129
            ),
            get_default_slot_context_129
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block28.name,
    type: "else",
    source: "(36:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block34(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context37
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1026)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes37
            ),
            get_default_slot_context37
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block34.name,
    type: "if",
    source: "(34:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment40(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block34, create_else_block28];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["checked", "disabled", "onCheckedChange", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $checkboxItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuCheckboxItem", slots, ["default"]);
  let { checked = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { onCheckedChange = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { checkboxItem }, states: { checked: localChecked }, updateOption } = setCheckboxItem({
    disabled,
    defaultChecked: checked,
    onCheckedChange: ({ next: next2 }) => {
      if (checked !== next2) {
        onCheckedChange == null ? void 0 : onCheckedChange(next2);
        $$invalidate(6, checked = next2);
      }
      return next2;
    }
  });
  validate_store(checkboxItem, "checkboxItem");
  component_subscribe($$self, checkboxItem, (value) => $$invalidate(9, $checkboxItem = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs7("checkbox-item");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props) $$invalidate(6, checked = $$new_props.checked);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("onCheckedChange" in $$new_props) $$invalidate(8, onCheckedChange = $$new_props.onCheckedChange);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCheckboxItem,
    getAttrs: getAttrs7,
    createDispatcher,
    checked,
    disabled,
    onCheckedChange,
    asChild,
    checkboxItem,
    localChecked,
    updateOption,
    dispatch,
    attrs,
    builder: builder2,
    $checkboxItem
  });
  $$self.$inject_state = ($$new_props) => {
    if ("checked" in $$props) $$invalidate(6, checked = $$new_props.checked);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("onCheckedChange" in $$props) $$invalidate(8, onCheckedChange = $$new_props.onCheckedChange);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checked*/
    64) {
      $: checked !== void 0 && localChecked.set(checked);
    }
    if ($$self.$$.dirty & /*disabled*/
    128) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*$checkboxItem*/
    512) {
      $: $$invalidate(1, builder2 = $checkboxItem);
    }
  };
  return [
    asChild,
    builder2,
    checkboxItem,
    dispatch,
    attrs,
    $$restProps,
    checked,
    disabled,
    onCheckedChange,
    $checkboxItem,
    $$scope,
    slots
  ];
}
var ContextMenuCheckboxItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {
      checked: 6,
      disabled: 7,
      onCheckedChange: 8,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuCheckboxItem",
      options,
      id: create_fragment40.name
    });
  }
  get checked() {
    throw new Error("<ContextMenuCheckboxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<ContextMenuCheckboxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ContextMenuCheckboxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ContextMenuCheckboxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCheckedChange() {
    throw new Error("<ContextMenuCheckboxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCheckedChange(value) {
    throw new Error("<ContextMenuCheckboxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<ContextMenuCheckboxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ContextMenuCheckboxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuCheckboxItem_default = ContextMenuCheckboxItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuRadioIndicator.svelte
function create_if_block35(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block35.name,
    type: "if",
    source: "(5:0) {#if $isChecked(value)}",
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let show_if = (
    /*$isChecked*/
    ctx[0](
      /*value*/
      ctx[2]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block35(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$isChecked*/
      1) show_if = /*$isChecked*/
      ctx2[0](
        /*value*/
        ctx2[2]
      );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$isChecked*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block35(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  let $isChecked;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuRadioIndicator", slots, ["default"]);
  const { isChecked, value } = getRadioIndicator();
  validate_store(isChecked, "isChecked");
  component_subscribe($$self, isChecked, (value2) => $$invalidate(0, $isChecked = value2));
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ContextMenuRadioIndicator> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getRadioIndicator,
    isChecked,
    value,
    $isChecked
  });
  return [$isChecked, isChecked, value, $$scope, slots];
}
var ContextMenuRadioIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuRadioIndicator",
      options,
      id: create_fragment41.name
    });
  }
};
var ContextMenuRadioIndicator_default = ContextMenuRadioIndicator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuCheckboxIndicator.svelte
var file38 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/context-menu/components/ContextMenuCheckboxIndicator.svelte";
var get_default_slot_changes38 = (dirty) => ({ checked: dirty & /*$checked*/
1 });
var get_default_slot_context38 = (ctx) => ({ checked: (
  /*$checked*/
  ctx[0]
) });
function create_if_block36(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_default_slot_context38
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $checked*/
        17)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_default_slot_changes38
            ),
            get_default_slot_context38
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block36.name,
    type: "if",
    source: "(7:1) {#if $checked}",
    ctx
  });
  return block;
}
function create_fragment42(ctx) {
  let div;
  let current;
  let if_block = (
    /*$checked*/
    ctx[0] && create_if_block36(ctx)
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    /*attrs*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block) if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file38, 5, 0, 165);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block) if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$checked*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$checked*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block36(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        /*attrs*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $checked;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuCheckboxIndicator", slots, ["default"]);
  const checked = getCheckboxIndicator();
  validate_store(checked, "checked");
  component_subscribe($$self, checked, (value) => $$invalidate(0, $checked = value));
  const attrs = getAttrs7("checkbox-indicator");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getCheckboxIndicator,
    getAttrs: getAttrs7,
    checked,
    attrs,
    $checked
  });
  return [$checked, checked, attrs, $$restProps, $$scope, slots];
}
var ContextMenuCheckboxIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuCheckboxIndicator",
      options,
      id: create_fragment42.name
    });
  }
};
var ContextMenuCheckboxIndicator_default = ContextMenuCheckboxIndicator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/index.js
var dialog_exports = {};
__export(dialog_exports, {
  Close: () => DialogClose_default,
  Content: () => DialogContent_default,
  Description: () => DialogDescription_default,
  Dialog: () => Dialog_default,
  DialogClose: () => DialogClose_default,
  DialogContent: () => DialogContent_default,
  DialogDescription: () => DialogDescription_default,
  DialogOverlay: () => DialogOverlay_default,
  DialogPortal: () => DialogPortal_default,
  DialogTitle: () => DialogTitle_default,
  DialogTrigger: () => DialogTrigger_default,
  Overlay: () => DialogOverlay_default,
  Portal: () => DialogPortal_default,
  Root: () => Dialog_default,
  Title: () => DialogTitle_default,
  Trigger: () => DialogTrigger_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/ctx.js
var NAME8 = "dialog";
var PARTS7 = ["close", "content", "description", "overlay", "portal", "title", "trigger"];
var getAttrs8 = createBitAttrs(NAME8, PARTS7);
function setCtx7(props) {
  const dialog = createDialog({ ...removeUndefined2(props), role: "dialog" });
  setContext(NAME8, dialog);
  return {
    ...dialog,
    updateOption: getOptionUpdater(dialog.options)
  };
}
function getCtx8() {
  return getContext(NAME8);
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/Dialog.svelte
var get_default_slot_changes39 = (dirty) => ({ ids: dirty & /*$idValues*/
1 });
var get_default_slot_context39 = (ctx) => ({ ids: (
  /*$idValues*/
  ctx[0]
) });
function create_fragment43(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context39
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $idValues*/
        2049)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes39
            ),
            get_default_slot_context39
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  let $idValues;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dialog", slots, ["default"]);
  let { preventScroll = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { closeOnOutsideClick = void 0 } = $$props;
  let { portal = void 0 } = $$props;
  let { forceVisible = true } = $$props;
  let { open = void 0 } = $$props;
  let { onOpenChange = void 0 } = $$props;
  let { openFocus = void 0 } = $$props;
  let { closeFocus = void 0 } = $$props;
  const { states: { open: localOpen }, updateOption, ids } = setCtx7({
    closeOnEscape,
    preventScroll,
    closeOnOutsideClick,
    portal,
    forceVisible,
    defaultOpen: open,
    openFocus,
    closeFocus,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange == null ? void 0 : onOpenChange(next2);
        $$invalidate(2, open = next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.content, ids.description, ids.title], ([$contentId, $descriptionId, $titleId]) => ({
    content: $contentId,
    description: $descriptionId,
    title: $titleId
  }));
  validate_store(idValues, "idValues");
  component_subscribe($$self, idValues, (value) => $$invalidate(0, $idValues = value));
  const writable_props = [
    "preventScroll",
    "closeOnEscape",
    "closeOnOutsideClick",
    "portal",
    "forceVisible",
    "open",
    "onOpenChange",
    "openFocus",
    "closeFocus"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Dialog> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("preventScroll" in $$props2) $$invalidate(3, preventScroll = $$props2.preventScroll);
    if ("closeOnEscape" in $$props2) $$invalidate(4, closeOnEscape = $$props2.closeOnEscape);
    if ("closeOnOutsideClick" in $$props2) $$invalidate(5, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("portal" in $$props2) $$invalidate(6, portal = $$props2.portal);
    if ("forceVisible" in $$props2) $$invalidate(7, forceVisible = $$props2.forceVisible);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(8, onOpenChange = $$props2.onOpenChange);
    if ("openFocus" in $$props2) $$invalidate(9, openFocus = $$props2.openFocus);
    if ("closeFocus" in $$props2) $$invalidate(10, closeFocus = $$props2.closeFocus);
    if ("$$scope" in $$props2) $$invalidate(11, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    derived,
    setCtx: setCtx7,
    preventScroll,
    closeOnEscape,
    closeOnOutsideClick,
    portal,
    forceVisible,
    open,
    onOpenChange,
    openFocus,
    closeFocus,
    localOpen,
    updateOption,
    ids,
    idValues,
    $idValues
  });
  $$self.$inject_state = ($$props2) => {
    if ("preventScroll" in $$props2) $$invalidate(3, preventScroll = $$props2.preventScroll);
    if ("closeOnEscape" in $$props2) $$invalidate(4, closeOnEscape = $$props2.closeOnEscape);
    if ("closeOnOutsideClick" in $$props2) $$invalidate(5, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("portal" in $$props2) $$invalidate(6, portal = $$props2.portal);
    if ("forceVisible" in $$props2) $$invalidate(7, forceVisible = $$props2.forceVisible);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(8, onOpenChange = $$props2.onOpenChange);
    if ("openFocus" in $$props2) $$invalidate(9, openFocus = $$props2.openFocus);
    if ("closeFocus" in $$props2) $$invalidate(10, closeFocus = $$props2.closeFocus);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    4) {
      $: open !== void 0 && localOpen.set(open);
    }
    if ($$self.$$.dirty & /*preventScroll*/
    8) {
      $: updateOption("preventScroll", preventScroll);
    }
    if ($$self.$$.dirty & /*closeOnEscape*/
    16) {
      $: updateOption("closeOnEscape", closeOnEscape);
    }
    if ($$self.$$.dirty & /*closeOnOutsideClick*/
    32) {
      $: updateOption("closeOnOutsideClick", closeOnOutsideClick);
    }
    if ($$self.$$.dirty & /*portal*/
    64) {
      $: updateOption("portal", portal);
    }
    if ($$self.$$.dirty & /*forceVisible*/
    128) {
      $: updateOption("forceVisible", forceVisible);
    }
    if ($$self.$$.dirty & /*openFocus*/
    512) {
      $: updateOption("openFocus", openFocus);
    }
    if ($$self.$$.dirty & /*closeFocus*/
    1024) {
      $: updateOption("closeFocus", closeFocus);
    }
  };
  return [
    $idValues,
    idValues,
    open,
    preventScroll,
    closeOnEscape,
    closeOnOutsideClick,
    portal,
    forceVisible,
    onOpenChange,
    openFocus,
    closeFocus,
    $$scope,
    slots
  ];
}
var Dialog = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {
      preventScroll: 3,
      closeOnEscape: 4,
      closeOnOutsideClick: 5,
      portal: 6,
      forceVisible: 7,
      open: 2,
      onOpenChange: 8,
      openFocus: 9,
      closeFocus: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dialog",
      options,
      id: create_fragment43.name
    });
  }
  get preventScroll() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScroll(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnOutsideClick() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnOutsideClick(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get portal() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portal(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forceVisible() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forceVisible(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onOpenChange() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onOpenChange(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openFocus() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openFocus(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeFocus() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeFocus(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dialog_default = Dialog;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogTitle.svelte
var file39 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogTitle.svelte";
var get_default_slot_changes_130 = (dirty) => ({ builder: dirty & /*builder*/
4 });
var get_default_slot_context_130 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes40 = (dirty) => ({ builder: dirty & /*builder*/
4 });
var get_default_slot_context40 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block29(ctx) {
  let previous_tag = (
    /*level*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*level*/
    ctx[0]
  );
  validate_void_dynamic_element(
    /*level*/
    ctx[0]
  );
  let svelte_element = (
    /*level*/
    ctx[0] && create_dynamic_element3(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element) svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*level*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element3(ctx2);
          previous_tag = /*level*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*level*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*level*/
            ctx2[0]
          );
          validate_void_dynamic_element(
            /*level*/
            ctx2[0]
          );
          svelte_element = create_dynamic_element3(ctx2);
          previous_tag = /*level*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*level*/
        ctx2[0];
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block29.name,
    type: "else",
    source: "(21:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block37(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context40
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes40
            ),
            get_default_slot_context40
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block37.name,
    type: "if",
    source: "(19:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_dynamic_element3(ctx) {
  let svelte_element;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_130
  );
  let svelte_element_levels = [
    /*builder*/
    ctx[2],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*level*/
        ctx[0]
      );
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*level*/
        (ctx[0] || "null").toUpperCase(),
        {}
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot) default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*level*/
        ctx[0]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file39, 21, 1, 382);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[2].action(svelte_element));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_130
            ),
            get_default_slot_context_130
          );
        }
      }
      set_dynamic_element_data(
        /*level*/
        ctx2[0]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        dirty & /*builder*/
        4 && /*builder*/
        ctx2[2],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element3.name,
    type: "child_dynamic_element",
    source: "(22:1) <svelte:element this={level} {...builder} use:builder.action {...$$restProps} {...attrs}>",
    ctx
  });
  return block;
}
function create_fragment44(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block37, create_else_block29];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["level", "asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $title;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DialogTitle", slots, ["default"]);
  let { level = "h2" } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { title }, ids } = getCtx8();
  validate_store(title, "title");
  component_subscribe($$self, title, (value) => $$invalidate(7, $title = value));
  const attrs = getAttrs8("title");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("level" in $$new_props) $$invalidate(0, level = $$new_props.level);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(6, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx8,
    getAttrs: getAttrs8,
    level,
    asChild,
    id,
    title,
    ids,
    attrs,
    builder: builder2,
    $title
  });
  $$self.$inject_state = ($$new_props) => {
    if ("level" in $$props) $$invalidate(0, level = $$new_props.level);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(6, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    64) {
      $: if (id) {
        ids.title.set(id);
      }
    }
    if ($$self.$$.dirty & /*$title*/
    128) {
      $: $$invalidate(2, builder2 = $title);
    }
  };
  return [level, asChild, builder2, title, attrs, $$restProps, id, $title, $$scope, slots];
}
var DialogTitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, { level: 0, asChild: 1, id: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DialogTitle",
      options,
      id: create_fragment44.name
    });
  }
  get level() {
    throw new Error("<DialogTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set level(value) {
    throw new Error("<DialogTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<DialogTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DialogTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DialogTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DialogTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DialogTitle_default = DialogTitle;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogClose.svelte
var file40 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogClose.svelte";
var get_default_slot_changes_131 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_131 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes41 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context41 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block30(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_131
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file40, 16, 1, 385);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_131
            ),
            get_default_slot_context_131
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block30.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block38(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context41
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes41
            ),
            get_default_slot_context41
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block38.name,
    type: "if",
    source: "(14:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment45(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block38, create_else_block30];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $close;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DialogClose", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { close } } = getCtx8();
  validate_store(close, "close");
  component_subscribe($$self, close, (value) => $$invalidate(6, $close = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs8("close");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx8,
    getAttrs: getAttrs8,
    createDispatcher,
    asChild,
    close,
    dispatch,
    attrs,
    builder: builder2,
    $close
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$close*/
    64) {
      $: $$invalidate(1, builder2 = $close);
    }
  };
  return [asChild, builder2, close, dispatch, attrs, $$restProps, $close, $$scope, slots];
}
var DialogClose = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DialogClose",
      options,
      id: create_fragment45.name
    });
  }
  get asChild() {
    throw new Error("<DialogClose>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DialogClose>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DialogClose_default = DialogClose;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogPortal.svelte
var file41 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogPortal.svelte";
var get_default_slot_changes_132 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_132 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes42 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context42 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block31(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context_132
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file41, 14, 1, 293);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes_132
            ),
            get_default_slot_context_132
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block31.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block39(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context42
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes42
            ),
            get_default_slot_context42
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block39.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment46(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block39, create_else_block31];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $portalled;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DialogPortal", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { portalled } } = getCtx8();
  validate_store(portalled, "portalled");
  component_subscribe($$self, portalled, (value) => $$invalidate(5, $portalled = value));
  const attrs = getAttrs8("portal");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx8,
    getAttrs: getAttrs8,
    asChild,
    portalled,
    attrs,
    builder: builder2,
    $portalled
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$portalled*/
    32) {
      $: $$invalidate(1, builder2 = $portalled);
    }
  };
  return [asChild, builder2, portalled, attrs, $$restProps, $portalled, $$scope, slots];
}
var DialogPortal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DialogPortal",
      options,
      id: create_fragment46.name
    });
  }
  get asChild() {
    throw new Error("<DialogPortal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DialogPortal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DialogPortal_default = DialogPortal;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogContent.svelte
var file42 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogContent.svelte";
var get_default_slot_changes_56 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_56 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_46 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_46 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_36 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_36 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_26 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_26 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_133 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_133 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes43 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context43 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
function create_if_block_57(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_56
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file42, 49, 1, 1394);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes_56
            ),
            get_default_slot_context_56
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12],
        /*attrs*/
        ctx2[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_57.name,
    type: "if",
    source: "(49:16) ",
    ctx
  });
  return block;
}
function create_if_block_47(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_46
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file42, 45, 1, 1233);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_46
            ),
            get_default_slot_context_46
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_47.name,
    type: "if",
    source: "(45:33) ",
    ctx
  });
  return block;
}
function create_if_block_37(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_36
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file42, 41, 1, 1058);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_36
            ),
            get_default_slot_context_36
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_37.name,
    type: "if",
    source: "(41:32) ",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_26
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file42, 31, 1, 832);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_26
            ),
            get_default_slot_context_26
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(31:49) ",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_133
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file42, 27, 1, 637);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_133
            ),
            get_default_slot_context_133
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(27:30) ",
    ctx
  });
  return block;
}
function create_if_block40(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context43
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes43
            ),
            get_default_slot_context43
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block40.name,
    type: "if",
    source: "(25:0) {#if asChild && $open}",
    ctx
  });
  return block;
}
function create_fragment47(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block40,
    create_if_block_17,
    create_if_block_27,
    create_if_block_37,
    create_if_block_47,
    create_if_block_57
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$open*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$open*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$open*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 4;
    if (
      /*$open*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $content;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DialogContent", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { content }, states: { open }, ids } = getCtx8();
  validate_store(content, "content");
  component_subscribe($$self, content, (value) => $$invalidate(14, $content = value));
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  const attrs = getAttrs8("content");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(13, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx8,
    getAttrs: getAttrs8,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    content,
    open,
    ids,
    attrs,
    builder: builder2,
    $content,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(13, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    8192) {
      $: if (id) {
        ids.content.set(id);
      }
    }
    if ($$self.$$.dirty & /*$content*/
    16384) {
      $: $$invalidate(7, builder2 = $content);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $open,
    content,
    open,
    attrs,
    $$restProps,
    id,
    $content,
    $$scope,
    slots
  ];
}
var DialogContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6,
      id: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DialogContent",
      options,
      id: create_fragment47.name
    });
  }
  get transition() {
    throw new Error("<DialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<DialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<DialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<DialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<DialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<DialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<DialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<DialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<DialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<DialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<DialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<DialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<DialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DialogContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DialogContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DialogContent_default = DialogContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogOverlay.svelte
var file43 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogOverlay.svelte";
var get_default_slot_changes44 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context44 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
function create_if_block_58(ctx) {
  let div;
  let builder_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file43, 35, 1, 1178);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12],
        /*attrs*/
        ctx2[11]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_58.name,
    type: "if",
    source: "(35:16) ",
    ctx
  });
  return block;
}
function create_if_block_48(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file43, 33, 1, 1052);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_48.name,
    type: "if",
    source: "(33:33) ",
    ctx
  });
  return block;
}
function create_if_block_38(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file43, 31, 1, 912);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
    },
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_38.name,
    type: "if",
    source: "(31:32) ",
    ctx
  });
  return block;
}
function create_if_block_28(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file43, 23, 1, 722);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(23:49) ",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file43, 21, 1, 562);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(21:30) ",
    ctx
  });
  return block;
}
function create_if_block41(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context44
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        16512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes44
            ),
            get_default_slot_context44
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block41.name,
    type: "if",
    source: "(19:0) {#if asChild && $open}",
    ctx
  });
  return block;
}
function create_fragment48(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block41,
    create_if_block_18,
    create_if_block_28,
    create_if_block_38,
    create_if_block_48,
    create_if_block_58
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$open*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$open*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$open*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 4;
    if (
      /*$open*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $overlay;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DialogOverlay", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { overlay }, states: { open } } = getCtx8();
  validate_store(overlay, "overlay");
  component_subscribe($$self, overlay, (value) => $$invalidate(13, $overlay = value));
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  const attrs = getAttrs8("overlay");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx8,
    getAttrs: getAttrs8,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    overlay,
    open,
    attrs,
    builder: builder2,
    $overlay,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$overlay*/
    8192) {
      $: $$invalidate(7, builder2 = $overlay);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $open,
    overlay,
    open,
    attrs,
    $$restProps,
    $overlay,
    $$scope,
    slots
  ];
}
var DialogOverlay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment48, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DialogOverlay",
      options,
      id: create_fragment48.name
    });
  }
  get transition() {
    throw new Error("<DialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<DialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<DialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<DialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<DialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<DialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<DialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<DialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<DialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<DialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<DialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<DialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<DialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DialogOverlay_default = DialogOverlay;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogTrigger.svelte
var file44 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogTrigger.svelte";
var get_default_slot_changes_134 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_134 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes45 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context45 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block32(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_134
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file44, 16, 1, 391);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_134
            ),
            get_default_slot_context_134
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block32.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block42(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context45
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes45
            ),
            get_default_slot_context45
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block42.name,
    type: "if",
    source: "(14:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment49(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block42, create_else_block32];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $trigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DialogTrigger", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { trigger } } = getCtx8();
  validate_store(trigger, "trigger");
  component_subscribe($$self, trigger, (value) => $$invalidate(6, $trigger = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs8("trigger");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx8,
    getAttrs: getAttrs8,
    createDispatcher,
    asChild,
    trigger,
    dispatch,
    attrs,
    builder: builder2,
    $trigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$trigger*/
    64) {
      $: $$invalidate(1, builder2 = $trigger);
    }
  };
  return [
    asChild,
    builder2,
    trigger,
    dispatch,
    attrs,
    $$restProps,
    $trigger,
    $$scope,
    slots
  ];
}
var DialogTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DialogTrigger",
      options,
      id: create_fragment49.name
    });
  }
  get asChild() {
    throw new Error("<DialogTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DialogTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DialogTrigger_default = DialogTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogDescription.svelte
var file45 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dialog/components/DialogDescription.svelte";
var get_default_slot_changes_135 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_135 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes46 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context46 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block33(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_135
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file45, 20, 1, 381);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_135
            ),
            get_default_slot_context_135
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block33.name,
    type: "else",
    source: "(20:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block43(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context46
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes46
            ),
            get_default_slot_context46
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block43.name,
    type: "if",
    source: "(18:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment50(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block43, create_else_block33];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $description;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DialogDescription", slots, ["default"]);
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { description }, ids } = getCtx8();
  validate_store(description, "description");
  component_subscribe($$self, description, (value) => $$invalidate(6, $description = value));
  const attrs = getAttrs8("description");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx8,
    getAttrs: getAttrs8,
    asChild,
    id,
    description,
    ids,
    attrs,
    builder: builder2,
    $description
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    32) {
      $: if (id) {
        ids.description.set(id);
      }
    }
    if ($$self.$$.dirty & /*$description*/
    64) {
      $: $$invalidate(1, builder2 = $description);
    }
  };
  return [
    asChild,
    builder2,
    description,
    attrs,
    $$restProps,
    id,
    $description,
    $$scope,
    slots
  ];
}
var DialogDescription = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, { asChild: 0, id: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DialogDescription",
      options,
      id: create_fragment50.name
    });
  }
  get asChild() {
    throw new Error("<DialogDescription>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DialogDescription>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DialogDescription>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DialogDescription>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DialogDescription_default = DialogDescription;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/index.js
var dropdown_menu_exports = {};
__export(dropdown_menu_exports, {
  Arrow: () => DropdownMenuArrow_default,
  CheckboxIndicator: () => DropdownMenuCheckboxIndicator_default,
  CheckboxItem: () => DropdownMenuCheckboxItem_default,
  Content: () => DropdownMenuContent_default,
  DropdownMenu: () => DropdownMenu_default,
  DropdownMenuArrow: () => DropdownMenuArrow_default,
  DropdownMenuCheckboxIndicator: () => DropdownMenuCheckboxIndicator_default,
  DropdownMenuCheckboxItem: () => DropdownMenuCheckboxItem_default,
  DropdownMenuContent: () => DropdownMenuContent_default,
  DropdownMenuGroup: () => DropdownMenuGroup_default,
  DropdownMenuItem: () => DropdownMenuItem_default,
  DropdownMenuLabel: () => DropdownMenuLabel_default,
  DropdownMenuRadioGroup: () => DropdownMenuRadioGroup_default,
  DropdownMenuRadioIndicator: () => DropdownMenuRadioIndicator_default,
  DropdownMenuRadioItem: () => DropdownMenuRadioItem_default,
  DropdownMenuSeparator: () => DropdownMenuSeparator_default,
  DropdownMenuSub: () => DropdownMenuSub_default,
  DropdownMenuSubContent: () => DropdownMenuSubContent_default,
  DropdownMenuSubTrigger: () => DropdownMenuSubTrigger_default,
  DropdownMenuTrigger: () => DropdownMenuTrigger_default,
  Group: () => DropdownMenuGroup_default,
  Item: () => DropdownMenuItem_default,
  Label: () => DropdownMenuLabel_default,
  RadioGroup: () => DropdownMenuRadioGroup_default,
  RadioIndicator: () => DropdownMenuRadioIndicator_default,
  RadioItem: () => DropdownMenuRadioItem_default,
  Root: () => DropdownMenu_default,
  Separator: () => DropdownMenuSeparator_default,
  Sub: () => DropdownMenuSub_default,
  SubContent: () => DropdownMenuSubContent_default,
  SubTrigger: () => DropdownMenuSubTrigger_default,
  Trigger: () => DropdownMenuTrigger_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/ctx.js
var NAME9 = "dropdown-menu";
var SUB_NAME2 = "dropdown-menu-submenu";
var RADIO_GROUP_NAME2 = "dropdown-menu-radiogroup";
var CHECKBOX_ITEM_NAME2 = "dropdown-menu-checkboxitem";
var RADIO_ITEM_NAME2 = "dropdown-menu-radioitem";
var GROUP_NAME3 = "dropdown-menu-group";
var PARTS8 = [
  "arrow",
  "checkbox-indicator",
  "checkbox-item",
  "content",
  "group",
  "item",
  "label",
  "radio-group",
  "radio-item",
  "separator",
  "sub-content",
  "sub-trigger",
  "trigger"
];
var getAttrs9 = createBitAttrs(NAME9, PARTS8);
function getCtx9() {
  return getContext(NAME9);
}
function setCtx8(props) {
  const dropdownMenu = createDropdownMenu({ ...removeUndefined2(props), forceVisible: true });
  setContext(NAME9, dropdownMenu);
  return {
    ...dropdownMenu,
    updateOption: getOptionUpdater(dropdownMenu.options)
  };
}
function setSubMenuCtx2(props) {
  const { builders: { createSubmenu } } = getCtx9();
  const sub = createSubmenu(removeUndefined2(props));
  setContext(SUB_NAME2, sub);
  return {
    ...sub,
    updateOption: getOptionUpdater(sub.options)
  };
}
function setRadioGroupCtx2(props) {
  const { builders: { createMenuRadioGroup } } = getCtx9();
  const radioGroup = createMenuRadioGroup(props);
  setContext(RADIO_GROUP_NAME2, radioGroup);
  return radioGroup;
}
function setRadioItem2(value) {
  const dropdownMenu = getContext(RADIO_GROUP_NAME2);
  setContext(RADIO_ITEM_NAME2, { isChecked: dropdownMenu.helpers.isChecked, value });
  return dropdownMenu;
}
function getRadioIndicator2() {
  return getContext(RADIO_ITEM_NAME2);
}
function getSubTrigger() {
  const submenu = getContext(SUB_NAME2);
  return submenu;
}
function getContent3(sideoffset = 5) {
  const menu = getCtx9();
  menu.options.positioning.update((prev2) => ({ ...prev2, gutter: sideoffset }));
  return menu;
}
function getSubContent2(sideOffset = -1) {
  const submenu = getContext(SUB_NAME2);
  submenu.options.positioning.update((prev2) => ({ ...prev2, gutter: sideOffset }));
  return submenu;
}
function setCheckboxItem2(props) {
  const { builders: { createCheckboxItem } } = getCtx9();
  const checkboxItem = createCheckboxItem(removeUndefined2(props));
  setContext(CHECKBOX_ITEM_NAME2, checkboxItem.states.checked);
  return {
    ...checkboxItem,
    updateOption: getOptionUpdater(checkboxItem.options)
  };
}
function getCheckboxIndicator2() {
  return getContext(CHECKBOX_ITEM_NAME2);
}
function setGroupCtx() {
  const { elements: { group } } = getCtx9();
  const id = generateId3();
  setContext(GROUP_NAME3, id);
  return { group, id };
}
function getGroupLabel2() {
  const id = getContext(GROUP_NAME3) ?? generateId3();
  const { elements: { groupLabel } } = getCtx9();
  return { groupLabel, id };
}
function setArrow2(size2 = 8) {
  const menu = getCtx9();
  menu.options.arrowSize.set(size2);
  return menu;
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenu.svelte
var get_default_slot_changes47 = (dirty) => ({ ids: dirty & /*$idValues*/
1 });
var get_default_slot_context47 = (ctx) => ({ ids: (
  /*$idValues*/
  ctx[0]
) });
function create_fragment51(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context47
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $idValues*/
        65537)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes47
            ),
            get_default_slot_context47
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  let $idValues;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenu", slots, ["default"]);
  let { closeOnOutsideClick = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { portal = void 0 } = $$props;
  let { forceVisible = void 0 } = $$props;
  let { open = void 0 } = $$props;
  let { onOpenChange = void 0 } = $$props;
  let { preventScroll = void 0 } = $$props;
  let { arrowSize = void 0 } = $$props;
  let { positioning = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { dir = void 0 } = $$props;
  let { typeahead = void 0 } = $$props;
  let { closeFocus = void 0 } = $$props;
  let { disableFocusFirstItem = void 0 } = $$props;
  const { states: { open: localOpen }, updateOption, ids } = setCtx8({
    closeOnOutsideClick,
    closeOnEscape,
    portal,
    forceVisible,
    defaultOpen: open,
    preventScroll,
    arrowSize,
    positioning,
    loop,
    dir,
    typeahead,
    closeFocus,
    disableFocusFirstItem,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange == null ? void 0 : onOpenChange(next2);
        $$invalidate(2, open = next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({ menu: $menuId, trigger: $triggerId }));
  validate_store(idValues, "idValues");
  component_subscribe($$self, idValues, (value) => $$invalidate(0, $idValues = value));
  const writable_props = [
    "closeOnOutsideClick",
    "closeOnEscape",
    "portal",
    "forceVisible",
    "open",
    "onOpenChange",
    "preventScroll",
    "arrowSize",
    "positioning",
    "loop",
    "dir",
    "typeahead",
    "closeFocus",
    "disableFocusFirstItem"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DropdownMenu> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("closeOnOutsideClick" in $$props2) $$invalidate(3, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("closeOnEscape" in $$props2) $$invalidate(4, closeOnEscape = $$props2.closeOnEscape);
    if ("portal" in $$props2) $$invalidate(5, portal = $$props2.portal);
    if ("forceVisible" in $$props2) $$invalidate(6, forceVisible = $$props2.forceVisible);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(7, onOpenChange = $$props2.onOpenChange);
    if ("preventScroll" in $$props2) $$invalidate(8, preventScroll = $$props2.preventScroll);
    if ("arrowSize" in $$props2) $$invalidate(9, arrowSize = $$props2.arrowSize);
    if ("positioning" in $$props2) $$invalidate(10, positioning = $$props2.positioning);
    if ("loop" in $$props2) $$invalidate(11, loop = $$props2.loop);
    if ("dir" in $$props2) $$invalidate(12, dir = $$props2.dir);
    if ("typeahead" in $$props2) $$invalidate(13, typeahead = $$props2.typeahead);
    if ("closeFocus" in $$props2) $$invalidate(14, closeFocus = $$props2.closeFocus);
    if ("disableFocusFirstItem" in $$props2) $$invalidate(15, disableFocusFirstItem = $$props2.disableFocusFirstItem);
    if ("$$scope" in $$props2) $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setCtx: setCtx8,
    derived,
    closeOnOutsideClick,
    closeOnEscape,
    portal,
    forceVisible,
    open,
    onOpenChange,
    preventScroll,
    arrowSize,
    positioning,
    loop,
    dir,
    typeahead,
    closeFocus,
    disableFocusFirstItem,
    localOpen,
    updateOption,
    ids,
    idValues,
    $idValues
  });
  $$self.$inject_state = ($$props2) => {
    if ("closeOnOutsideClick" in $$props2) $$invalidate(3, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("closeOnEscape" in $$props2) $$invalidate(4, closeOnEscape = $$props2.closeOnEscape);
    if ("portal" in $$props2) $$invalidate(5, portal = $$props2.portal);
    if ("forceVisible" in $$props2) $$invalidate(6, forceVisible = $$props2.forceVisible);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(7, onOpenChange = $$props2.onOpenChange);
    if ("preventScroll" in $$props2) $$invalidate(8, preventScroll = $$props2.preventScroll);
    if ("arrowSize" in $$props2) $$invalidate(9, arrowSize = $$props2.arrowSize);
    if ("positioning" in $$props2) $$invalidate(10, positioning = $$props2.positioning);
    if ("loop" in $$props2) $$invalidate(11, loop = $$props2.loop);
    if ("dir" in $$props2) $$invalidate(12, dir = $$props2.dir);
    if ("typeahead" in $$props2) $$invalidate(13, typeahead = $$props2.typeahead);
    if ("closeFocus" in $$props2) $$invalidate(14, closeFocus = $$props2.closeFocus);
    if ("disableFocusFirstItem" in $$props2) $$invalidate(15, disableFocusFirstItem = $$props2.disableFocusFirstItem);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    4) {
      $: open !== void 0 && localOpen.set(open);
    }
    if ($$self.$$.dirty & /*closeOnOutsideClick*/
    8) {
      $: updateOption("closeOnOutsideClick", closeOnOutsideClick);
    }
    if ($$self.$$.dirty & /*closeOnEscape*/
    16) {
      $: updateOption("closeOnEscape", closeOnEscape);
    }
    if ($$self.$$.dirty & /*portal*/
    32) {
      $: updateOption("portal", portal);
    }
    if ($$self.$$.dirty & /*forceVisible*/
    64) {
      $: updateOption("forceVisible", forceVisible);
    }
    if ($$self.$$.dirty & /*preventScroll*/
    256) {
      $: updateOption("preventScroll", preventScroll);
    }
    if ($$self.$$.dirty & /*arrowSize*/
    512) {
      $: updateOption("arrowSize", arrowSize);
    }
    if ($$self.$$.dirty & /*positioning*/
    1024) {
      $: updateOption("positioning", positioning);
    }
    if ($$self.$$.dirty & /*loop*/
    2048) {
      $: updateOption("loop", loop);
    }
    if ($$self.$$.dirty & /*dir*/
    4096) {
      $: updateOption("dir", dir);
    }
    if ($$self.$$.dirty & /*closeFocus*/
    16384) {
      $: updateOption("closeFocus", closeFocus);
    }
    if ($$self.$$.dirty & /*disableFocusFirstItem*/
    32768) {
      $: updateOption("disableFocusFirstItem", disableFocusFirstItem);
    }
    if ($$self.$$.dirty & /*typeahead*/
    8192) {
      $: updateOption("typeahead", typeahead);
    }
  };
  return [
    $idValues,
    idValues,
    open,
    closeOnOutsideClick,
    closeOnEscape,
    portal,
    forceVisible,
    onOpenChange,
    preventScroll,
    arrowSize,
    positioning,
    loop,
    dir,
    typeahead,
    closeFocus,
    disableFocusFirstItem,
    $$scope,
    slots
  ];
}
var DropdownMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, {
      closeOnOutsideClick: 3,
      closeOnEscape: 4,
      portal: 5,
      forceVisible: 6,
      open: 2,
      onOpenChange: 7,
      preventScroll: 8,
      arrowSize: 9,
      positioning: 10,
      loop: 11,
      dir: 12,
      typeahead: 13,
      closeFocus: 14,
      disableFocusFirstItem: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenu",
      options,
      id: create_fragment51.name
    });
  }
  get closeOnOutsideClick() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnOutsideClick(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get portal() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portal(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forceVisible() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forceVisible(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onOpenChange() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onOpenChange(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventScroll() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScroll(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowSize() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowSize(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positioning() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioning(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dir() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dir(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get typeahead() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set typeahead(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeFocus() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeFocus(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableFocusFirstItem() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableFocusFirstItem(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenu_default = DropdownMenu;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuSub.svelte
var get_default_slot_changes48 = (dirty) => ({ subIds: dirty & /*$idValues*/
1 });
var get_default_slot_context48 = (ctx) => ({ subIds: (
  /*$idValues*/
  ctx[0]
) });
function create_fragment52(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context48
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $idValues*/
        33)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes48
            ),
            get_default_slot_context48
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let $idValues;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuSub", slots, ["default"]);
  let { positioning = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { arrowSize = void 0 } = $$props;
  const { updateOption, ids } = setSubMenuCtx2({ positioning, disabled, arrowSize });
  const idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({ menu: $menuId, trigger: $triggerId }));
  validate_store(idValues, "idValues");
  component_subscribe($$self, idValues, (value) => $$invalidate(0, $idValues = value));
  const writable_props = ["positioning", "disabled", "arrowSize"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DropdownMenuSub> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("positioning" in $$props2) $$invalidate(2, positioning = $$props2.positioning);
    if ("disabled" in $$props2) $$invalidate(3, disabled = $$props2.disabled);
    if ("arrowSize" in $$props2) $$invalidate(4, arrowSize = $$props2.arrowSize);
    if ("$$scope" in $$props2) $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    derived,
    setSubMenuCtx: setSubMenuCtx2,
    positioning,
    disabled,
    arrowSize,
    updateOption,
    ids,
    idValues,
    $idValues
  });
  $$self.$inject_state = ($$props2) => {
    if ("positioning" in $$props2) $$invalidate(2, positioning = $$props2.positioning);
    if ("disabled" in $$props2) $$invalidate(3, disabled = $$props2.disabled);
    if ("arrowSize" in $$props2) $$invalidate(4, arrowSize = $$props2.arrowSize);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*positioning*/
    4) {
      $: updateOption("positioning", positioning);
    }
    if ($$self.$$.dirty & /*disabled*/
    8) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*arrowSize*/
    16) {
      $: updateOption("arrowSize", arrowSize);
    }
  };
  return [$idValues, idValues, positioning, disabled, arrowSize, $$scope, slots];
}
var DropdownMenuSub = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, {
      positioning: 2,
      disabled: 3,
      arrowSize: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuSub",
      options,
      id: create_fragment52.name
    });
  }
  get positioning() {
    throw new Error("<DropdownMenuSub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioning(value) {
    throw new Error("<DropdownMenuSub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DropdownMenuSub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DropdownMenuSub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowSize() {
    throw new Error("<DropdownMenuSub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowSize(value) {
    throw new Error("<DropdownMenuSub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuSub_default = DropdownMenuSub;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuItem.svelte
var file46 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuItem.svelte";
var get_default_slot_changes_136 = (dirty) => ({
  builder: dirty & /*builder*/
  8,
  attrs: dirty & /*attrs*/
  4
});
var get_default_slot_context_136 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[3]
  ),
  attrs: (
    /*attrs*/
    ctx[2]
  )
});
var get_default_slot_changes49 = (dirty) => ({
  builder: dirty & /*builder*/
  8,
  attrs: dirty & /*attrs*/
  4
});
var get_default_slot_context49 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[3]
  ),
  attrs: (
    /*attrs*/
    ctx[2]
  )
});
function create_else_block34(ctx) {
  let previous_tag = (
    /*href*/
    ctx[0] ? "a" : "div"
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*href*/
    ctx[0] ? "a" : "div"
  );
  validate_void_dynamic_element(
    /*href*/
    ctx[0] ? "a" : "div"
  );
  let svelte_element = (
    /*href*/
    (ctx[0] ? "a" : "div") && create_dynamic_element4(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element) svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*href*/
        ctx2[0] ? "a" : "div"
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element4(ctx2);
          previous_tag = /*href*/
          ctx2[0] ? "a" : "div";
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*href*/
          ctx2[0] ? "a" : "div"
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*href*/
            ctx2[0] ? "a" : "div"
          );
          validate_void_dynamic_element(
            /*href*/
            ctx2[0] ? "a" : "div"
          );
          svelte_element = create_dynamic_element4(ctx2);
          previous_tag = /*href*/
          ctx2[0] ? "a" : "div";
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*href*/
        ctx2[0] ? "a" : "div";
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block34.name,
    type: "else",
    source: "(20:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block44(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context49
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        524)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes49
            ),
            get_default_slot_context49
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block44.name,
    type: "if",
    source: "(18:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_dynamic_element4(ctx) {
  let svelte_element;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context_136
  );
  let svelte_element_levels = [
    { href: (
      /*href*/
      ctx[0]
    ) },
    /*builder*/
    ctx[3],
    /*$$restProps*/
    ctx[6],
    /*attrs*/
    ctx[2]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*href*/
        ctx[0] ? "a" : "div"
      );
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*href*/
        ((ctx[0] ? "a" : "div") || "null").toUpperCase(),
        { href: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot) default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*href*/
        ctx[0] ? "a" : "div"
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file46, 20, 1, 531);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[3].action(svelte_element)),
          listen_dev(
            svelte_element,
            "m-click",
            /*dispatch*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "m-focusin",
            /*dispatch*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "m-focusout",
            /*dispatch*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "m-keydown",
            /*dispatch*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "m-pointerdown",
            /*dispatch*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "m-pointerleave",
            /*dispatch*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "m-pointermove",
            /*dispatch*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        524)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes_136
            ),
            get_default_slot_context_136
          );
        }
      }
      set_dynamic_element_data(
        /*href*/
        ctx2[0] ? "a" : "div"
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx2[0]
        ) },
        dirty & /*builder*/
        8 && /*builder*/
        ctx2[3],
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        dirty & /*attrs*/
        4 && /*attrs*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element4.name,
    type: "child_dynamic_element",
    source: '(21:1) <svelte:element   this={href ? \\"a\\" : \\"div\\"}   {href}   {...builder} use:builder.action   {...$$restProps}   {...attrs}   on:m-click={dispatch}   on:m-focusin={dispatch}   on:m-focusout={dispatch}   on:m-keydown={dispatch}   on:m-pointerdown={dispatch}   on:m-pointerleave={dispatch}   on:m-pointermove={dispatch}  >',
    ctx
  });
  return block;
}
function create_fragment53(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block44, create_else_block34];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  let builder2;
  let attrs;
  const omit_props_names = ["href", "asChild", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $item;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuItem", slots, ["default"]);
  let { href = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { disabled = false } = $$props;
  const { elements: { item } } = getCtx9();
  validate_store(item, "item");
  component_subscribe($$self, item, (value) => $$invalidate(8, $item = value));
  const dispatch = createDispatcher();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props) $$invalidate(0, href = $$new_props.href);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createDispatcher,
    disabledAttrs,
    melt,
    getCtx: getCtx9,
    getAttrs: getAttrs9,
    href,
    asChild,
    disabled,
    item,
    dispatch,
    attrs,
    builder: builder2,
    $item
  });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("attrs" in $$props) $$invalidate(2, attrs = $$new_props.attrs);
    if ("builder" in $$props) $$invalidate(3, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$item*/
    256) {
      $: $$invalidate(3, builder2 = $item);
    }
    if ($$self.$$.dirty & /*disabled*/
    128) {
      $: $$invalidate(2, attrs = {
        ...getAttrs9("item"),
        ...disabledAttrs(disabled)
      });
    }
  };
  return [
    href,
    asChild,
    attrs,
    builder2,
    item,
    dispatch,
    $$restProps,
    disabled,
    $item,
    $$scope,
    slots
  ];
}
var DropdownMenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, { href: 0, asChild: 1, disabled: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuItem",
      options,
      id: create_fragment53.name
    });
  }
  get href() {
    throw new Error("<DropdownMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<DropdownMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<DropdownMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DropdownMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DropdownMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DropdownMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuItem_default = DropdownMenuItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuGroup.svelte
var file47 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuGroup.svelte";
var get_default_slot_changes_137 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_137 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes50 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context50 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block35(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context_137
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file47, 12, 1, 286);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes_137
            ),
            get_default_slot_context_137
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block35.name,
    type: "else",
    source: "(12:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block45(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context50
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes50
            ),
            get_default_slot_context50
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block45.name,
    type: "if",
    source: "(10:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block45, create_else_block35];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $group;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuGroup", slots, ["default"]);
  let { asChild = false } = $$props;
  const { group, id } = setGroupCtx();
  validate_store(group, "group");
  component_subscribe($$self, group, (value) => $$invalidate(5, $group = value));
  const attrs = getAttrs9("group");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setGroupCtx,
    getAttrs: getAttrs9,
    asChild,
    group,
    id,
    attrs,
    builder: builder2,
    $group
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$group*/
    32) {
      $: $$invalidate(1, builder2 = $group(id));
    }
  };
  return [asChild, builder2, group, attrs, $$restProps, $group, $$scope, slots];
}
var DropdownMenuGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuGroup",
      options,
      id: create_fragment54.name
    });
  }
  get asChild() {
    throw new Error("<DropdownMenuGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DropdownMenuGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuGroup_default = DropdownMenuGroup;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuLabel.svelte
var file48 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuLabel.svelte";
var get_default_slot_changes_138 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_138 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes51 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context51 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block36(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context_138
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file48, 12, 1, 300);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes_138
            ),
            get_default_slot_context_138
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block36.name,
    type: "else",
    source: "(12:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block46(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context51
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes51
            ),
            get_default_slot_context51
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block46.name,
    type: "if",
    source: "(10:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment55(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block46, create_else_block36];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance55($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $groupLabel;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuLabel", slots, ["default"]);
  let { asChild = false } = $$props;
  const { groupLabel, id } = getGroupLabel2();
  validate_store(groupLabel, "groupLabel");
  component_subscribe($$self, groupLabel, (value) => $$invalidate(5, $groupLabel = value));
  const attrs = getAttrs9("label");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getGroupLabel: getGroupLabel2,
    getAttrs: getAttrs9,
    asChild,
    groupLabel,
    id,
    attrs,
    builder: builder2,
    $groupLabel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$groupLabel*/
    32) {
      $: $$invalidate(1, builder2 = $groupLabel(id));
    }
  };
  return [asChild, builder2, groupLabel, attrs, $$restProps, $groupLabel, $$scope, slots];
}
var DropdownMenuLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuLabel",
      options,
      id: create_fragment55.name
    });
  }
  get asChild() {
    throw new Error("<DropdownMenuLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DropdownMenuLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuLabel_default = DropdownMenuLabel;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuArrow.svelte
var file49 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuArrow.svelte";
var get_default_slot_changes52 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context52 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block37(ctx) {
  let div;
  let builder_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file49, 15, 1, 313);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*builder*/
      2 && /*builder*/
      ctx2[1]]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block37.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block47(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context52
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes52
            ),
            get_default_slot_context52
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block47.name,
    type: "if",
    source: "(13:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment56(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block47, create_else_block37];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  let builder2;
  let $arrow;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuArrow", slots, ["default"]);
  let { size: size2 = 8 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { arrow: arrow2 } } = setArrow2(size2);
  validate_store(arrow2, "arrow");
  component_subscribe($$self, arrow2, (value) => $$invalidate(5, $arrow = value));
  const attrs = getAttrs9("arrow");
  const writable_props = ["size", "asChild"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DropdownMenuArrow> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2) $$invalidate(4, size2 = $$props2.size);
    if ("asChild" in $$props2) $$invalidate(0, asChild = $$props2.asChild);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setArrow: setArrow2,
    getAttrs: getAttrs9,
    size: size2,
    asChild,
    arrow: arrow2,
    attrs,
    builder: builder2,
    $arrow
  });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2) $$invalidate(4, size2 = $$props2.size);
    if ("asChild" in $$props2) $$invalidate(0, asChild = $$props2.asChild);
    if ("builder" in $$props2) $$invalidate(1, builder2 = $$props2.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$arrow*/
    32) {
      $: $$invalidate(1, builder2 = $arrow);
    }
  };
  return [asChild, builder2, arrow2, attrs, size2, $arrow, $$scope, slots];
}
var DropdownMenuArrow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, safe_not_equal, { size: 4, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuArrow",
      options,
      id: create_fragment56.name
    });
  }
  get size() {
    throw new Error("<DropdownMenuArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DropdownMenuArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<DropdownMenuArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DropdownMenuArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuArrow_default = DropdownMenuArrow;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuContent.svelte
var file50 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuContent.svelte";
var get_default_slot_changes_57 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_57 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_47 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_47 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_37 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_37 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_27 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_27 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_139 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_139 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes53 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context53 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
function create_if_block_59(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_57
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file50, 72, 1, 1755);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes_57
            ),
            get_default_slot_context_57
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13],
        /*attrs*/
        ctx2[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_59.name,
    type: "if",
    source: "(72:16) ",
    ctx
  });
  return block;
}
function create_if_block_49(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_47
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file50, 62, 1, 1558);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_47
            ),
            get_default_slot_context_47
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_49.name,
    type: "if",
    source: "(62:33) ",
    ctx
  });
  return block;
}
function create_if_block_39(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_37
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file50, 52, 1, 1347);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_37
            ),
            get_default_slot_context_37
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_39.name,
    type: "if",
    source: "(52:32) ",
    ctx
  });
  return block;
}
function create_if_block_29(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_27
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file50, 41, 1, 1095);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_27
            ),
            get_default_slot_context_27
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(41:49) ",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_139
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file50, 31, 1, 864);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_139
            ),
            get_default_slot_context_139
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(31:30) ",
    ctx
  });
  return block;
}
function create_if_block48(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context53
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes53
            ),
            get_default_slot_context53
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block48.name,
    type: "if",
    source: "(29:0) {#if asChild && $open}",
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block48,
    create_if_block_19,
    create_if_block_29,
    create_if_block_39,
    create_if_block_49,
    create_if_block_59
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$open*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$open*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$open*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 4;
    if (
      /*$open*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance57($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "sideOffset",
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $menu;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuContent", slots, ["default"]);
  let { sideOffset = 5 } = $$props;
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { menu }, states: { open }, ids } = getContent3(sideOffset);
  validate_store(menu, "menu");
  component_subscribe($$self, menu, (value) => $$invalidate(16, $menu = value));
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  const attrs = getAttrs9("content");
  const dispatch = createDispatcher();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("sideOffset" in $$new_props) $$invalidate(14, sideOffset = $$new_props.sideOffset);
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(15, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createDispatcher,
    melt,
    getContent: getContent3,
    getAttrs: getAttrs9,
    sideOffset,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    menu,
    open,
    ids,
    attrs,
    dispatch,
    builder: builder2,
    $menu,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("sideOffset" in $$props) $$invalidate(14, sideOffset = $$new_props.sideOffset);
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(15, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    32768) {
      $: if (id) {
        ids.menu.set(id);
      }
    }
    if ($$self.$$.dirty & /*$menu*/
    65536) {
      $: $$invalidate(7, builder2 = $menu);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $open,
    menu,
    open,
    attrs,
    dispatch,
    $$restProps,
    sideOffset,
    id,
    $menu,
    $$scope,
    slots
  ];
}
var DropdownMenuContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, {
      sideOffset: 14,
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6,
      id: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuContent",
      options,
      id: create_fragment57.name
    });
  }
  get sideOffset() {
    throw new Error("<DropdownMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sideOffset(value) {
    throw new Error("<DropdownMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<DropdownMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<DropdownMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<DropdownMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<DropdownMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<DropdownMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<DropdownMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<DropdownMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<DropdownMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<DropdownMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<DropdownMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<DropdownMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<DropdownMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<DropdownMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DropdownMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DropdownMenuContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DropdownMenuContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuContent_default = DropdownMenuContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuTrigger.svelte
var file51 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuTrigger.svelte";
var get_default_slot_changes_140 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_140 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes54 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context54 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block38(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_140
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file51, 22, 1, 466);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-pointerdown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_140
            ),
            get_default_slot_context_140
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block38.name,
    type: "else",
    source: "(22:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block49(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context54
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes54
            ),
            get_default_slot_context54
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block49.name,
    type: "if",
    source: "(20:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment58(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block49, create_else_block38];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance58($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $trigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuTrigger", slots, ["default"]);
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { trigger }, ids } = getCtx9();
  validate_store(trigger, "trigger");
  component_subscribe($$self, trigger, (value) => $$invalidate(7, $trigger = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs9("trigger");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(6, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx9,
    getAttrs: getAttrs9,
    createDispatcher,
    asChild,
    id,
    trigger,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $trigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(6, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    64) {
      $: if (id) {
        ids.trigger.set(id);
      }
    }
    if ($$self.$$.dirty & /*$trigger*/
    128) {
      $: $$invalidate(1, builder2 = $trigger);
    }
  };
  return [
    asChild,
    builder2,
    trigger,
    dispatch,
    attrs,
    $$restProps,
    id,
    $trigger,
    $$scope,
    slots
  ];
}
var DropdownMenuTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment58, safe_not_equal, { asChild: 0, id: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuTrigger",
      options,
      id: create_fragment58.name
    });
  }
  get asChild() {
    throw new Error("<DropdownMenuTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DropdownMenuTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DropdownMenuTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DropdownMenuTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuTrigger_default = DropdownMenuTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuRadioItem.svelte
var file52 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuRadioItem.svelte";
var get_default_slot_changes_141 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_141 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes55 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context55 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block39(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context_141
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file52, 20, 1, 574);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(div)),
          listen_dev(
            div,
            "m-click",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusin",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes_141
            ),
            get_default_slot_context_141
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block39.name,
    type: "else",
    source: "(20:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block50(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context55
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes55
            ),
            get_default_slot_context55
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block50.name,
    type: "if",
    source: "(18:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment59(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block50, create_else_block39];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance59($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["value", "disabled", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $radioItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuRadioItem", slots, ["default"]);
  let { value } = $$props;
  let { disabled = false } = $$props;
  let { asChild = false } = $$props;
  const { elements: { radioItem } } = setRadioItem2(value);
  validate_store(radioItem, "radioItem");
  component_subscribe($$self, radioItem, (value2) => $$invalidate(8, $radioItem = value2));
  const attrs = getAttrs9("radio-item");
  const dispatch = createDispatcher();
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<DropdownMenuRadioItem> was created without expected prop 'value'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setRadioItem: setRadioItem2,
    getAttrs: getAttrs9,
    createDispatcher,
    value,
    disabled,
    asChild,
    radioItem,
    attrs,
    dispatch,
    builder: builder2,
    $radioItem
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$radioItem, value, disabled*/
    448) {
      $: $$invalidate(1, builder2 = $radioItem({ value, disabled }));
    }
  };
  return [
    asChild,
    builder2,
    radioItem,
    attrs,
    dispatch,
    $$restProps,
    value,
    disabled,
    $radioItem,
    $$scope,
    slots
  ];
}
var DropdownMenuRadioItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance59, create_fragment59, safe_not_equal, { value: 6, disabled: 7, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuRadioItem",
      options,
      id: create_fragment59.name
    });
  }
  get value() {
    throw new Error("<DropdownMenuRadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<DropdownMenuRadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DropdownMenuRadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DropdownMenuRadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<DropdownMenuRadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DropdownMenuRadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuRadioItem_default = DropdownMenuRadioItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuSeparator.svelte
var file53 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuSeparator.svelte";
var get_default_slot_changes56 = (dirty) => ({ builder: dirty & /*builder*/
4 });
var get_default_slot_context56 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block40(ctx) {
  let div;
  let $separator_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*$separator*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file53, 14, 1, 296);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer($separator_action_action = /*$separator*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$separator*/
        2 && /*$separator*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block40.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block51(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context56
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        68)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes56
            ),
            get_default_slot_context56
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block51.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment60(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block51, create_else_block40];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance60($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $separator;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuSeparator", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { separator } } = getCtx9();
  validate_store(separator, "separator");
  component_subscribe($$self, separator, (value) => $$invalidate(1, $separator = value));
  const attrs = getAttrs9("separator");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx9,
    getAttrs: getAttrs9,
    asChild,
    separator,
    attrs,
    builder: builder2,
    $separator
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$separator*/
    2) {
      $: $$invalidate(2, builder2 = $separator);
    }
  };
  return [asChild, $separator, builder2, separator, attrs, $$restProps, $$scope, slots];
}
var DropdownMenuSeparator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuSeparator",
      options,
      id: create_fragment60.name
    });
  }
  get asChild() {
    throw new Error("<DropdownMenuSeparator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DropdownMenuSeparator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuSeparator_default = DropdownMenuSeparator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuRadioGroup.svelte
var file54 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuRadioGroup.svelte";
var get_default_slot_changes_142 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_142 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes57 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context57 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block41(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_142
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file54, 28, 1, 632);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_142
            ),
            get_default_slot_context_142
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block41.name,
    type: "else",
    source: "(28:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block52(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context57
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes57
            ),
            get_default_slot_context57
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block52.name,
    type: "if",
    source: "(26:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment61(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block52, create_else_block41];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance61($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["value", "onValueChange", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $radioGroup;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuRadioGroup", slots, ["default"]);
  let { value = void 0 } = $$props;
  let { onValueChange = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { radioGroup }, states: { value: localValue } } = setRadioGroupCtx2({
    defaultValue: value,
    onValueChange: ({ next: next2 }) => {
      if (next2 && value !== next2) {
        onValueChange == null ? void 0 : onValueChange(next2);
        $$invalidate(5, value = next2);
      }
      return next2;
    }
  });
  validate_store(radioGroup, "radioGroup");
  component_subscribe($$self, radioGroup, (value2) => $$invalidate(7, $radioGroup = value2));
  const attrs = getAttrs9("radio-group");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$new_props) $$invalidate(6, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setRadioGroupCtx: setRadioGroupCtx2,
    getAttrs: getAttrs9,
    value,
    onValueChange,
    asChild,
    radioGroup,
    localValue,
    attrs,
    builder: builder2,
    $radioGroup
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$props) $$invalidate(6, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    32) {
      $: value !== void 0 && localValue.set(value);
    }
    if ($$self.$$.dirty & /*$radioGroup*/
    128) {
      $: $$invalidate(1, builder2 = $radioGroup);
    }
  };
  return [
    asChild,
    builder2,
    radioGroup,
    attrs,
    $$restProps,
    value,
    onValueChange,
    $radioGroup,
    $$scope,
    slots
  ];
}
var DropdownMenuRadioGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, { value: 5, onValueChange: 6, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuRadioGroup",
      options,
      id: create_fragment61.name
    });
  }
  get value() {
    throw new Error("<DropdownMenuRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<DropdownMenuRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValueChange() {
    throw new Error("<DropdownMenuRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValueChange(value) {
    throw new Error("<DropdownMenuRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<DropdownMenuRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DropdownMenuRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuRadioGroup_default = DropdownMenuRadioGroup;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuSubContent.svelte
var file55 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuSubContent.svelte";
var get_default_slot_changes_58 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_58 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_48 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_48 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_38 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_38 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_28 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_28 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_143 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_143 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes58 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context58 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
function create_if_block_510(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_58
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file55, 78, 1, 1892);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes_58
            ),
            get_default_slot_context_58
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13],
        /*attrs*/
        ctx2[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_510.name,
    type: "if",
    source: "(78:19) ",
    ctx
  });
  return block;
}
function create_if_block_410(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_48
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file55, 66, 1, 1635);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_48
            ),
            get_default_slot_context_48
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_410.name,
    type: "if",
    source: "(66:36) ",
    ctx
  });
  return block;
}
function create_if_block_310(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_38
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file55, 54, 1, 1364);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_38
            ),
            get_default_slot_context_38
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_310.name,
    type: "if",
    source: "(54:35) ",
    ctx
  });
  return block;
}
function create_if_block_210(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_28
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file55, 41, 1, 1052);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_28
            ),
            get_default_slot_context_28
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(41:52) ",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_143
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file55, 29, 1, 761);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_143
            ),
            get_default_slot_context_143
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(29:33) ",
    ctx
  });
  return block;
}
function create_if_block53(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context58
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes58
            ),
            get_default_slot_context58
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block53.name,
    type: "if",
    source: "(27:0) {#if asChild && $subOpen}",
    ctx
  });
  return block;
}
function create_fragment62(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block53,
    create_if_block_110,
    create_if_block_210,
    create_if_block_310,
    create_if_block_410,
    create_if_block_510
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$subOpen*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$subOpen*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$subOpen*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$subOpen*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$subOpen*/
      ctx2[8]
    ) return 4;
    if (
      /*$subOpen*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance62($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $subMenu;
  let $subOpen;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuSubContent", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { subMenu }, states: { subOpen }, ids } = getSubContent2();
  validate_store(subMenu, "subMenu");
  component_subscribe($$self, subMenu, (value) => $$invalidate(15, $subMenu = value));
  validate_store(subOpen, "subOpen");
  component_subscribe($$self, subOpen, (value) => $$invalidate(8, $subOpen = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs9("sub-content");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(14, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    createDispatcher,
    getSubContent: getSubContent2,
    getAttrs: getAttrs9,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    subMenu,
    subOpen,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $subMenu,
    $subOpen
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(14, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    16384) {
      $: if (id) {
        ids.menu.set(id);
      }
    }
    if ($$self.$$.dirty & /*$subMenu*/
    32768) {
      $: $$invalidate(7, builder2 = $subMenu);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $subOpen,
    subMenu,
    subOpen,
    dispatch,
    attrs,
    $$restProps,
    id,
    $subMenu,
    $$scope,
    slots
  ];
}
var DropdownMenuSubContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance62, create_fragment62, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6,
      id: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuSubContent",
      options,
      id: create_fragment62.name
    });
  }
  get transition() {
    throw new Error("<DropdownMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<DropdownMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<DropdownMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<DropdownMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<DropdownMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<DropdownMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<DropdownMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<DropdownMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<DropdownMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<DropdownMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<DropdownMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<DropdownMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<DropdownMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DropdownMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DropdownMenuSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DropdownMenuSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuSubContent_default = DropdownMenuSubContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuSubTrigger.svelte
var file56 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuSubTrigger.svelte";
var get_default_slot_changes_144 = (dirty) => ({
  builder: dirty & /*builder*/
  4,
  attrs: dirty & /*attrs*/
  2
});
var get_default_slot_context_144 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[1]
  )
});
var get_default_slot_changes59 = (dirty) => ({
  builder: dirty & /*builder*/
  4,
  attrs: dirty & /*attrs*/
  2
});
var get_default_slot_context59 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[1]
  )
});
function create_else_block42(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context_144
  );
  let div_levels = [
    /*builder*/
    ctx[2],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file56, 26, 1, 703);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[2].action(div)),
          listen_dev(
            div,
            "m-click",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusin",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        518)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes_144
            ),
            get_default_slot_context_144
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        4 && /*builder*/
        ctx2[2],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        dirty & /*attrs*/
        2 && /*attrs*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block42.name,
    type: "else",
    source: "(26:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block54(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context59
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        518)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes59
            ),
            get_default_slot_context59
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block54.name,
    type: "if",
    source: "(24:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment63(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block54, create_else_block42];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance63($$self, $$props, $$invalidate) {
  let builder2;
  let attrs;
  const omit_props_names = ["disabled", "asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $subTrigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuSubTrigger", slots, ["default"]);
  let { disabled = false } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { subTrigger }, ids } = getSubTrigger();
  validate_store(subTrigger, "subTrigger");
  component_subscribe($$self, subTrigger, (value) => $$invalidate(8, $subTrigger = value));
  const dispatch = createDispatcher();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("disabled" in $$new_props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    disabledAttrs,
    getSubTrigger,
    getAttrs: getAttrs9,
    createDispatcher,
    disabled,
    asChild,
    id,
    subTrigger,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $subTrigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("disabled" in $$props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
    if ("attrs" in $$props) $$invalidate(1, attrs = $$new_props.attrs);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    128) {
      $: if (id) {
        ids.trigger.set(id);
      }
    }
    if ($$self.$$.dirty & /*$subTrigger*/
    256) {
      $: $$invalidate(2, builder2 = $subTrigger);
    }
    if ($$self.$$.dirty & /*disabled*/
    64) {
      $: $$invalidate(1, attrs = {
        ...getAttrs9("sub-trigger"),
        ...disabledAttrs(disabled)
      });
    }
  };
  return [
    asChild,
    attrs,
    builder2,
    subTrigger,
    dispatch,
    $$restProps,
    disabled,
    id,
    $subTrigger,
    $$scope,
    slots
  ];
}
var DropdownMenuSubTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment63, safe_not_equal, { disabled: 6, asChild: 0, id: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuSubTrigger",
      options,
      id: create_fragment63.name
    });
  }
  get disabled() {
    throw new Error("<DropdownMenuSubTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DropdownMenuSubTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<DropdownMenuSubTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DropdownMenuSubTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DropdownMenuSubTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DropdownMenuSubTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuSubTrigger_default = DropdownMenuSubTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuCheckboxItem.svelte
var file57 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuCheckboxItem.svelte";
var get_default_slot_changes_145 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_145 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes60 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context60 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block43(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context_145
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file57, 35, 1, 854);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(div)),
          listen_dev(
            div,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusin",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1026)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes_145
            ),
            get_default_slot_context_145
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block43.name,
    type: "else",
    source: "(35:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block55(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context60
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1026)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes60
            ),
            get_default_slot_context60
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block55.name,
    type: "if",
    source: "(33:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment64(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block55, create_else_block43];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance64($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["checked", "onCheckedChange", "disabled", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $checkboxItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuCheckboxItem", slots, ["default"]);
  let { checked = void 0 } = $$props;
  let { onCheckedChange = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { checkboxItem }, states: { checked: localChecked }, updateOption } = setCheckboxItem2({
    disabled,
    defaultChecked: checked,
    onCheckedChange: ({ next: next2 }) => {
      if (checked !== next2) {
        onCheckedChange == null ? void 0 : onCheckedChange(next2);
        $$invalidate(6, checked = next2);
      }
      return next2;
    }
  });
  validate_store(checkboxItem, "checkboxItem");
  component_subscribe($$self, checkboxItem, (value) => $$invalidate(9, $checkboxItem = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs9("checkbox-item");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props) $$invalidate(6, checked = $$new_props.checked);
    if ("onCheckedChange" in $$new_props) $$invalidate(7, onCheckedChange = $$new_props.onCheckedChange);
    if ("disabled" in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCheckboxItem: setCheckboxItem2,
    getAttrs: getAttrs9,
    createDispatcher,
    checked,
    onCheckedChange,
    disabled,
    asChild,
    checkboxItem,
    localChecked,
    updateOption,
    dispatch,
    attrs,
    builder: builder2,
    $checkboxItem
  });
  $$self.$inject_state = ($$new_props) => {
    if ("checked" in $$props) $$invalidate(6, checked = $$new_props.checked);
    if ("onCheckedChange" in $$props) $$invalidate(7, onCheckedChange = $$new_props.onCheckedChange);
    if ("disabled" in $$props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checked*/
    64) {
      $: checked !== void 0 && localChecked.set(checked);
    }
    if ($$self.$$.dirty & /*disabled*/
    256) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*$checkboxItem*/
    512) {
      $: $$invalidate(1, builder2 = $checkboxItem);
    }
  };
  return [
    asChild,
    builder2,
    checkboxItem,
    dispatch,
    attrs,
    $$restProps,
    checked,
    onCheckedChange,
    disabled,
    $checkboxItem,
    $$scope,
    slots
  ];
}
var DropdownMenuCheckboxItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, {
      checked: 6,
      onCheckedChange: 7,
      disabled: 8,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuCheckboxItem",
      options,
      id: create_fragment64.name
    });
  }
  get checked() {
    throw new Error("<DropdownMenuCheckboxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<DropdownMenuCheckboxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCheckedChange() {
    throw new Error("<DropdownMenuCheckboxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCheckedChange(value) {
    throw new Error("<DropdownMenuCheckboxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DropdownMenuCheckboxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DropdownMenuCheckboxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<DropdownMenuCheckboxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<DropdownMenuCheckboxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenuCheckboxItem_default = DropdownMenuCheckboxItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuRadioIndicator.svelte
function create_if_block56(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block56.name,
    type: "if",
    source: "(5:0) {#if $isChecked(value)}",
    ctx
  });
  return block;
}
function create_fragment65(ctx) {
  let show_if = (
    /*$isChecked*/
    ctx[0](
      /*value*/
      ctx[2]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block56(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$isChecked*/
      1) show_if = /*$isChecked*/
      ctx2[0](
        /*value*/
        ctx2[2]
      );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$isChecked*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block56(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance65($$self, $$props, $$invalidate) {
  let $isChecked;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuRadioIndicator", slots, ["default"]);
  const { isChecked, value } = getRadioIndicator2();
  validate_store(isChecked, "isChecked");
  component_subscribe($$self, isChecked, (value2) => $$invalidate(0, $isChecked = value2));
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DropdownMenuRadioIndicator> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getRadioIndicator: getRadioIndicator2,
    isChecked,
    value,
    $isChecked
  });
  return [$isChecked, isChecked, value, $$scope, slots];
}
var DropdownMenuRadioIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuRadioIndicator",
      options,
      id: create_fragment65.name
    });
  }
};
var DropdownMenuRadioIndicator_default = DropdownMenuRadioIndicator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuCheckboxIndicator.svelte
var file58 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/dropdown-menu/components/DropdownMenuCheckboxIndicator.svelte";
var get_default_slot_changes61 = (dirty) => ({ checked: dirty & /*$checked*/
1 });
var get_default_slot_context61 = (ctx) => ({ checked: (
  /*$checked*/
  ctx[0]
) });
function create_if_block57(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_default_slot_context61
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $checked*/
        17)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_default_slot_changes61
            ),
            get_default_slot_context61
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block57.name,
    type: "if",
    source: "(7:1) {#if $checked}",
    ctx
  });
  return block;
}
function create_fragment66(ctx) {
  let div;
  let current;
  let if_block = (
    /*$checked*/
    ctx[0] && create_if_block57(ctx)
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    /*attrs*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block) if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file58, 5, 0, 165);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block) if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$checked*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$checked*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block57(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        /*attrs*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance66($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $checked;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenuCheckboxIndicator", slots, ["default"]);
  const checked = getCheckboxIndicator2();
  validate_store(checked, "checked");
  component_subscribe($$self, checked, (value) => $$invalidate(0, $checked = value));
  const attrs = getAttrs9("checkbox-indicator");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getAttrs: getAttrs9,
    getCheckboxIndicator: getCheckboxIndicator2,
    checked,
    attrs,
    $checked
  });
  return [$checked, checked, attrs, $$restProps, $$scope, slots];
}
var DropdownMenuCheckboxIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance66, create_fragment66, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenuCheckboxIndicator",
      options,
      id: create_fragment66.name
    });
  }
};
var DropdownMenuCheckboxIndicator_default = DropdownMenuCheckboxIndicator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/link-preview/index.js
var link_preview_exports = {};
__export(link_preview_exports, {
  Arrow: () => LinkPreviewArrow_default,
  Content: () => LinkPreviewContent_default,
  LinkPreview: () => LinkPreview_default,
  LinkPreviewArrow: () => LinkPreviewArrow_default,
  LinkPreviewContent: () => LinkPreviewContent_default,
  LinkPreviewTrigger: () => LinkPreviewTrigger_default,
  Root: () => LinkPreview_default,
  Trigger: () => LinkPreviewTrigger_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/link-preview/ctx.js
var NAME10 = "link-preview";
var PARTS9 = ["arrow", "content", "trigger"];
var getAttrs10 = createBitAttrs(NAME10, PARTS9);
function getCtx10() {
  return getContext(NAME10);
}
function setCtx9(props) {
  const linkPreview = createLinkPreview({
    ...removeUndefined2(props),
    forceVisible: true
  });
  setContext(NAME10, linkPreview);
  return {
    ...linkPreview,
    updateOption: getOptionUpdater(linkPreview.options)
  };
}
function setArrow3(size2 = 8) {
  const linkPreview = getCtx10();
  linkPreview.options.arrowSize.set(size2);
  return linkPreview;
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/link-preview/components/LinkPreview.svelte
var get_default_slot_changes62 = (dirty) => ({ ids: dirty & /*$idValues*/
1 });
var get_default_slot_context62 = (ctx) => ({ ids: (
  /*$idValues*/
  ctx[0]
) });
function create_fragment67(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context62
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $idValues*/
        2049)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes62
            ),
            get_default_slot_context62
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance67($$self, $$props, $$invalidate) {
  let $idValues;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LinkPreview", slots, ["default"]);
  let { positioning = void 0 } = $$props;
  let { open = void 0 } = $$props;
  let { onOpenChange = void 0 } = $$props;
  let { openDelay = 700 } = $$props;
  let { closeDelay = 300 } = $$props;
  let { closeOnOutsideClick = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { arrowSize = void 0 } = $$props;
  let { portal = void 0 } = $$props;
  const { states: { open: localOpen }, updateOption, ids } = setCtx9({
    defaultOpen: open,
    positioning,
    openDelay,
    closeDelay,
    closeOnOutsideClick,
    closeOnEscape,
    arrowSize,
    portal,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange == null ? void 0 : onOpenChange(next2);
        $$invalidate(2, open = next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.content, ids.trigger], ([$contentId, $triggerId]) => ({ content: $contentId, trigger: $triggerId }));
  validate_store(idValues, "idValues");
  component_subscribe($$self, idValues, (value) => $$invalidate(0, $idValues = value));
  const writable_props = [
    "positioning",
    "open",
    "onOpenChange",
    "openDelay",
    "closeDelay",
    "closeOnOutsideClick",
    "closeOnEscape",
    "arrowSize",
    "portal"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<LinkPreview> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("positioning" in $$props2) $$invalidate(3, positioning = $$props2.positioning);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(4, onOpenChange = $$props2.onOpenChange);
    if ("openDelay" in $$props2) $$invalidate(5, openDelay = $$props2.openDelay);
    if ("closeDelay" in $$props2) $$invalidate(6, closeDelay = $$props2.closeDelay);
    if ("closeOnOutsideClick" in $$props2) $$invalidate(7, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("closeOnEscape" in $$props2) $$invalidate(8, closeOnEscape = $$props2.closeOnEscape);
    if ("arrowSize" in $$props2) $$invalidate(9, arrowSize = $$props2.arrowSize);
    if ("portal" in $$props2) $$invalidate(10, portal = $$props2.portal);
    if ("$$scope" in $$props2) $$invalidate(11, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    derived,
    setCtx: setCtx9,
    positioning,
    open,
    onOpenChange,
    openDelay,
    closeDelay,
    closeOnOutsideClick,
    closeOnEscape,
    arrowSize,
    portal,
    localOpen,
    updateOption,
    ids,
    idValues,
    $idValues
  });
  $$self.$inject_state = ($$props2) => {
    if ("positioning" in $$props2) $$invalidate(3, positioning = $$props2.positioning);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(4, onOpenChange = $$props2.onOpenChange);
    if ("openDelay" in $$props2) $$invalidate(5, openDelay = $$props2.openDelay);
    if ("closeDelay" in $$props2) $$invalidate(6, closeDelay = $$props2.closeDelay);
    if ("closeOnOutsideClick" in $$props2) $$invalidate(7, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("closeOnEscape" in $$props2) $$invalidate(8, closeOnEscape = $$props2.closeOnEscape);
    if ("arrowSize" in $$props2) $$invalidate(9, arrowSize = $$props2.arrowSize);
    if ("portal" in $$props2) $$invalidate(10, portal = $$props2.portal);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    4) {
      $: open !== void 0 && localOpen.set(open);
    }
    if ($$self.$$.dirty & /*positioning*/
    8) {
      $: updateOption("positioning", positioning);
    }
    if ($$self.$$.dirty & /*openDelay*/
    32) {
      $: updateOption("openDelay", openDelay);
    }
    if ($$self.$$.dirty & /*closeDelay*/
    64) {
      $: updateOption("closeDelay", closeDelay);
    }
    if ($$self.$$.dirty & /*closeOnOutsideClick*/
    128) {
      $: updateOption("closeOnOutsideClick", closeOnOutsideClick);
    }
    if ($$self.$$.dirty & /*closeOnEscape*/
    256) {
      $: updateOption("closeOnEscape", closeOnEscape);
    }
    if ($$self.$$.dirty & /*arrowSize*/
    512) {
      $: updateOption("arrowSize", arrowSize);
    }
    if ($$self.$$.dirty & /*portal*/
    1024) {
      $: updateOption("portal", portal);
    }
  };
  return [
    $idValues,
    idValues,
    open,
    positioning,
    onOpenChange,
    openDelay,
    closeDelay,
    closeOnOutsideClick,
    closeOnEscape,
    arrowSize,
    portal,
    $$scope,
    slots
  ];
}
var LinkPreview = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, {
      positioning: 3,
      open: 2,
      onOpenChange: 4,
      openDelay: 5,
      closeDelay: 6,
      closeOnOutsideClick: 7,
      closeOnEscape: 8,
      arrowSize: 9,
      portal: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LinkPreview",
      options,
      id: create_fragment67.name
    });
  }
  get positioning() {
    throw new Error("<LinkPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioning(value) {
    throw new Error("<LinkPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<LinkPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<LinkPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onOpenChange() {
    throw new Error("<LinkPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onOpenChange(value) {
    throw new Error("<LinkPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openDelay() {
    throw new Error("<LinkPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openDelay(value) {
    throw new Error("<LinkPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeDelay() {
    throw new Error("<LinkPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeDelay(value) {
    throw new Error("<LinkPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnOutsideClick() {
    throw new Error("<LinkPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnOutsideClick(value) {
    throw new Error("<LinkPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<LinkPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<LinkPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowSize() {
    throw new Error("<LinkPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowSize(value) {
    throw new Error("<LinkPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get portal() {
    throw new Error("<LinkPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portal(value) {
    throw new Error("<LinkPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LinkPreview_default = LinkPreview;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/link-preview/components/LinkPreviewArrow.svelte
var file59 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/link-preview/components/LinkPreviewArrow.svelte";
var get_default_slot_changes63 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context63 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block44(ctx) {
  let div;
  let builder_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file59, 15, 1, 313);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block44.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block58(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context63
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes63
            ),
            get_default_slot_context63
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block58.name,
    type: "if",
    source: "(13:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment68(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block58, create_else_block44];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance68($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $arrow;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LinkPreviewArrow", slots, ["default"]);
  let { asChild = false } = $$props;
  let { size: size2 = 8 } = $$props;
  const { elements: { arrow: arrow2 } } = setArrow3(size2);
  validate_store(arrow2, "arrow");
  component_subscribe($$self, arrow2, (value) => $$invalidate(6, $arrow = value));
  const attrs = getAttrs10("arrow");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("size" in $$new_props) $$invalidate(5, size2 = $$new_props.size);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setArrow: setArrow3,
    getAttrs: getAttrs10,
    melt,
    asChild,
    size: size2,
    arrow: arrow2,
    attrs,
    builder: builder2,
    $arrow
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("size" in $$props) $$invalidate(5, size2 = $$new_props.size);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$arrow*/
    64) {
      $: $$invalidate(1, builder2 = $arrow);
    }
  };
  return [asChild, builder2, arrow2, attrs, $$restProps, size2, $arrow, $$scope, slots];
}
var LinkPreviewArrow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance68, create_fragment68, safe_not_equal, { asChild: 0, size: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LinkPreviewArrow",
      options,
      id: create_fragment68.name
    });
  }
  get asChild() {
    throw new Error("<LinkPreviewArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<LinkPreviewArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<LinkPreviewArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<LinkPreviewArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LinkPreviewArrow_default = LinkPreviewArrow;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/link-preview/components/LinkPreviewContent.svelte
var file60 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/link-preview/components/LinkPreviewContent.svelte";
var get_default_slot_changes_59 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_59 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_49 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_49 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_39 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_39 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_29 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_29 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_146 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_146 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes64 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context64 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
function create_if_block_511(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_59
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file60, 84, 1, 2087);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerenter",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes_59
            ),
            get_default_slot_context_59
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13],
        /*attrs*/
        ctx2[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_511.name,
    type: "if",
    source: "(84:16) ",
    ctx
  });
  return block;
}
function create_if_block_411(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_49
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file60, 71, 1, 1797);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerenter",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_49
            ),
            get_default_slot_context_49
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_411.name,
    type: "if",
    source: "(71:33) ",
    ctx
  });
  return block;
}
function create_if_block_311(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_39
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file60, 58, 1, 1493);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerenter",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_39
            ),
            get_default_slot_context_39
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_311.name,
    type: "if",
    source: "(58:32) ",
    ctx
  });
  return block;
}
function create_if_block_211(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_29
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file60, 44, 1, 1148);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerenter",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_29
            ),
            get_default_slot_context_29
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_211.name,
    type: "if",
    source: "(44:49) ",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_146
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file60, 31, 1, 824);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerenter",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_146
            ),
            get_default_slot_context_146
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(31:30) ",
    ctx
  });
  return block;
}
function create_if_block59(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context64
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes64
            ),
            get_default_slot_context64
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block59.name,
    type: "if",
    source: "(29:0) {#if asChild && $open}",
    ctx
  });
  return block;
}
function create_fragment69(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block59,
    create_if_block_111,
    create_if_block_211,
    create_if_block_311,
    create_if_block_411,
    create_if_block_511
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$open*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$open*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$open*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 4;
    if (
      /*$open*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance69($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $content;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LinkPreviewContent", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { content }, states: { open }, ids } = getCtx10();
  validate_store(content, "content");
  component_subscribe($$self, content, (value) => $$invalidate(15, $content = value));
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  const attrs = getAttrs10("content");
  const dispatch = createDispatcher();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(14, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    createDispatcher,
    getCtx: getCtx10,
    getAttrs: getAttrs10,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    content,
    open,
    ids,
    attrs,
    dispatch,
    builder: builder2,
    $content,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(14, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    16384) {
      $: if (id) {
        ids.content.set(id);
      }
    }
    if ($$self.$$.dirty & /*$content*/
    32768) {
      $: $$invalidate(7, builder2 = $content);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $open,
    content,
    open,
    attrs,
    dispatch,
    $$restProps,
    id,
    $content,
    $$scope,
    slots
  ];
}
var LinkPreviewContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment69, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6,
      id: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LinkPreviewContent",
      options,
      id: create_fragment69.name
    });
  }
  get transition() {
    throw new Error("<LinkPreviewContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<LinkPreviewContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<LinkPreviewContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<LinkPreviewContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<LinkPreviewContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<LinkPreviewContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<LinkPreviewContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<LinkPreviewContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<LinkPreviewContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<LinkPreviewContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<LinkPreviewContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<LinkPreviewContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<LinkPreviewContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<LinkPreviewContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<LinkPreviewContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<LinkPreviewContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LinkPreviewContent_default = LinkPreviewContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/link-preview/components/LinkPreviewTrigger.svelte
var file61 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/link-preview/components/LinkPreviewTrigger.svelte";
var get_default_slot_changes_147 = (dirty) => ({ builder: dirty & /*$trigger*/
2 });
var get_default_slot_context_147 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[5]
  )
});
var get_default_slot_changes65 = (dirty) => ({ builder: dirty & /*builder*/
4 });
var get_default_slot_context65 = (ctx) => ({
  attrs: (
    /*attrs*/
    ctx[5]
  ),
  builder: (
    /*builder*/
    ctx[2]
  )
});
function get_else_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*$trigger*/
    child_ctx[1]
  );
  child_ctx[2] = constants_0;
  return child_ctx;
}
function create_else_block45(ctx) {
  let current;
  validate_dynamic_element("a");
  validate_void_dynamic_element("a");
  let svelte_element = create_dynamic_element5(ctx);
  const block = {
    c: function create() {
      if (svelte_element) svelte_element.c();
    },
    l: function claim(nodes) {
      if (svelte_element) svelte_element.l(nodes);
    },
    m: function mount(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ("a") {
        svelte_element.p(ctx2, dirty);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (svelte_element) svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block45.name,
    type: "else",
    source: "(22:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block60(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context65
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes65
            ),
            get_default_slot_context65
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block60.name,
    type: "if",
    source: "(20:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_dynamic_element5(ctx) {
  let svelte_element;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_147
  );
  let svelte_element_levels = [
    /*builder*/
    ctx[2],
    /*$$restProps*/
    ctx[6],
    /*attrs*/
    ctx[5]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element("a");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(nodes, "A", {});
      var svelte_element_nodes = children(svelte_element);
      if (default_slot) default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data("a")(svelte_element, svelte_element_data);
      add_location(svelte_element, file61, 23, 1, 495);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[2].action(svelte_element)),
          listen_dev(
            svelte_element,
            "m-blur",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "m-focus",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "m-pointerenter",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "m-pointerleave",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $trigger*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_147
            ),
            get_default_slot_context_147
          );
        }
      }
      set_dynamic_element_data("a")(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        dirty & /*$trigger*/
        2 && /*builder*/
        ctx2[2],
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        /*attrs*/
        ctx2[5]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element5.name,
    type: "child_dynamic_element",
    source: '(24:1) <svelte:element   this={\\"a\\"}   {...builder} use:builder.action   {...$$restProps}   {...attrs}   on:m-blur={dispatch}   on:m-focus={dispatch}   on:m-pointerenter={dispatch}   on:m-pointerleave={dispatch}  >',
    ctx
  });
  return block;
}
function create_fragment70(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block60, create_else_block45];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  function select_block_ctx(ctx2, index) {
    if (index === 1) return get_else_ctx(ctx2);
    return ctx2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(select_block_ctx(ctx2, current_block_type_index), dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx2, current_block_type_index));
          if_block.c();
        } else {
          if_block.p(select_block_ctx(ctx2, current_block_type_index), dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance70($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $trigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LinkPreviewTrigger", slots, ["default"]);
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { trigger }, ids } = getCtx10();
  validate_store(trigger, "trigger");
  component_subscribe($$self, trigger, (value) => $$invalidate(1, $trigger = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs10("trigger");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx10,
    getAttrs: getAttrs10,
    createDispatcher,
    asChild,
    id,
    trigger,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $trigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    128) {
      $: if (id) {
        ids.trigger.set(id);
      }
    }
    if ($$self.$$.dirty & /*$trigger*/
    2) {
      $: $$invalidate(2, builder2 = $trigger);
    }
  };
  return [
    asChild,
    $trigger,
    builder2,
    trigger,
    dispatch,
    attrs,
    $$restProps,
    id,
    $$scope,
    slots
  ];
}
var LinkPreviewTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance70, create_fragment70, safe_not_equal, { asChild: 0, id: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LinkPreviewTrigger",
      options,
      id: create_fragment70.name
    });
  }
  get asChild() {
    throw new Error("<LinkPreviewTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<LinkPreviewTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<LinkPreviewTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<LinkPreviewTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LinkPreviewTrigger_default = LinkPreviewTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/label/index.js
var label_exports = {};
__export(label_exports, {
  Label: () => Label_default,
  Root: () => Label_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/label/ctx.js
var NAME11 = "label";
var PARTS10 = ["root"];
var getAttrs11 = createBitAttrs(NAME11, PARTS10);

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/label/components/Label.svelte
var file62 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/label/components/Label.svelte";
var get_default_slot_changes_148 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_148 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes66 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context66 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block46(ctx) {
  let label;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_148
  );
  let label_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", {});
      var label_nodes = children(label);
      if (default_slot) default_slot.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label, label_data);
      add_location(label, file62, 16, 1, 392);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(label)),
          listen_dev(
            label,
            "m-mousedown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_148
            ),
            get_default_slot_context_148
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block46.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block61(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context66
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes66
            ),
            get_default_slot_context66
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block61.name,
    type: "if",
    source: "(14:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment71(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block61, create_else_block46];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance71($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $root;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { root } } = createLabel();
  validate_store(root, "root");
  component_subscribe($$self, root, (value) => $$invalidate(6, $root = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs11("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    createLabel,
    getAttrs: getAttrs11,
    createDispatcher,
    asChild,
    root,
    dispatch,
    attrs,
    builder: builder2,
    $root
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$root*/
    64) {
      $: $$invalidate(1, builder2 = $root);
    }
  };
  return [asChild, builder2, root, dispatch, attrs, $$restProps, $root, $$scope, slots];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment71, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment71.name
    });
  }
  get asChild() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/index.js
var menubar_exports = {};
__export(menubar_exports, {
  Arrow: () => MenubarArrow_default,
  CheckboxIndicator: () => MenubarCheckboxIndicator_default,
  CheckboxItem: () => MenubarCheckboxItem_default,
  Content: () => MenubarContent_default,
  Group: () => MenubarGroup_default,
  Item: () => MenubarItem_default,
  Label: () => MenubarLabel_default,
  Menu: () => MenubarMenu_default,
  Menubar: () => Menubar_default,
  MenubarArrow: () => MenubarArrow_default,
  MenubarCheckboxIndicator: () => MenubarCheckboxIndicator_default,
  MenubarCheckboxItem: () => MenubarCheckboxItem_default,
  MenubarContent: () => MenubarContent_default,
  MenubarGroup: () => MenubarGroup_default,
  MenubarItem: () => MenubarItem_default,
  MenubarLabel: () => MenubarLabel_default,
  MenubarMenu: () => MenubarMenu_default,
  MenubarRadioGroup: () => MenubarRadioGroup_default,
  MenubarRadioIndicator: () => MenubarRadioIndicator_default,
  MenubarRadioItem: () => MenubarRadioItem_default,
  MenubarSeparator: () => MenubarSeparator_default,
  MenubarSub: () => MenubarSub_default,
  MenubarSubContent: () => MenubarSubContent_default,
  MenubarSubTrigger: () => MenubarSubTrigger_default,
  MenubarTrigger: () => MenubarTrigger_default,
  RadioGroup: () => MenubarRadioGroup_default,
  RadioIndicator: () => MenubarRadioIndicator_default,
  RadioItem: () => MenubarRadioItem_default,
  Root: () => Menubar_default,
  Separator: () => MenubarSeparator_default,
  Sub: () => MenubarSub_default,
  SubContent: () => MenubarSubContent_default,
  SubTrigger: () => MenubarSubTrigger_default,
  Trigger: () => MenubarTrigger_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/ctx.js
var NAME12 = "menubar";
var MENU_NAME = "menubar-menu";
var SUB_NAME3 = "menubar-sub";
var CHECKBOX_ITEM_NAME3 = "menubar-checkbox-item";
var RADIO_GROUP_NAME3 = "menubar-radio-group";
var RADIO_ITEM_NAME3 = "menubar-radio-item";
var GROUP_NAME4 = "menubar-group";
var PARTS11 = [
  "root",
  "arrow",
  "checkbox-indicator",
  "checkbox-item",
  "content",
  "group",
  "item",
  "label",
  "radio-group",
  "radio-item",
  "separator",
  "sub-content",
  "sub-trigger",
  "trigger"
];
var getAttrs12 = createBitAttrs(NAME12, PARTS11);
function setCtx10(props) {
  const menubar = createMenubar(removeUndefined2(props));
  setContext(NAME12, menubar);
  return {
    ...menubar,
    updateOption: getOptionUpdater(menubar.options)
  };
}
function getCtx11() {
  return getContext(NAME12);
}
function setMenuCtx(props) {
  const { builders: { createMenu } } = getCtx11();
  const menu = createMenu({ ...removeUndefined2(props), forceVisible: false });
  setContext(MENU_NAME, menu);
  return {
    ...menu,
    updateOption: getOptionUpdater(menu.options)
  };
}
function getMenuCtx() {
  return getContext(MENU_NAME);
}
function setSubMenuCtx3(props) {
  const { builders: { createSubmenu } } = getMenuCtx();
  const sub = createSubmenu(removeUndefined2(props));
  setContext(SUB_NAME3, sub);
  return {
    ...sub,
    updateOption: getOptionUpdater(sub.options)
  };
}
function getSubMenuCtx2() {
  return getContext(SUB_NAME3);
}
function setRadioGroupCtx3(props) {
  const { builders: { createMenuRadioGroup } } = getMenuCtx();
  const radioGroup = createMenuRadioGroup(removeUndefined2(props));
  setContext(RADIO_GROUP_NAME3, radioGroup);
  return radioGroup;
}
function setRadioItemCtx(value) {
  const radioGroup = getContext(RADIO_GROUP_NAME3);
  setContext(RADIO_ITEM_NAME3, { isChecked: radioGroup.helpers.isChecked, value });
  return radioGroup;
}
function getContent4(sideOffset = 5) {
  const menu = getMenuCtx();
  menu.options.positioning.update((prev2) => ({ ...prev2, gutter: sideOffset }));
  return menu;
}
function setCheckboxItem3(props) {
  const { builders: { createCheckboxItem } } = getMenuCtx();
  const checkboxItem = createCheckboxItem(removeUndefined2(props));
  setContext(CHECKBOX_ITEM_NAME3, checkboxItem.states.checked);
  return {
    ...checkboxItem,
    updateOption: getOptionUpdater(checkboxItem.options)
  };
}
function getCheckboxIndicator3() {
  return getContext(CHECKBOX_ITEM_NAME3);
}
function getRadioIndicator3() {
  return getContext(RADIO_ITEM_NAME3);
}
function setGroupCtx2() {
  const { elements: { group } } = getMenuCtx();
  const id = generateId3();
  setContext(GROUP_NAME4, id);
  return { group, id };
}
function getGroupLabel3() {
  const id = getContext(GROUP_NAME4) ?? generateId3();
  const { elements: { groupLabel } } = getMenuCtx();
  return { groupLabel, id };
}
function setArrow4(size2 = 8) {
  const menu = getMenuCtx();
  menu.options.arrowSize.set(size2);
  return menu;
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/Menubar.svelte
var file63 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/Menubar.svelte";
var get_default_slot_changes_149 = (dirty) => ({
  builder: dirty & /*builder*/
  2,
  ids: dirty & /*$idValues*/
  4
});
var get_default_slot_context_149 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[5]
  ),
  ids: (
    /*$idValues*/
    ctx[2]
  )
});
var get_default_slot_changes67 = (dirty) => ({
  builder: dirty & /*builder*/
  2,
  ids: dirty & /*$idValues*/
  4
});
var get_default_slot_context67 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[5]
  ),
  ids: (
    /*$idValues*/
    ctx[2]
  )
});
function create_else_block47(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context_149
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[6],
    /*attrs*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file63, 31, 1, 686);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, $idValues*/
        2054)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes_149
            ),
            get_default_slot_context_149
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        /*attrs*/
        ctx2[5]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block47.name,
    type: "else",
    source: "(31:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block62(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context67
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, $idValues*/
        2054)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes67
            ),
            get_default_slot_context67
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block62.name,
    type: "if",
    source: "(29:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment72(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block62, create_else_block47];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment72.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance72($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["loop", "closeOnEscape", "asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $menubar;
  let $idValues;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menubar", slots, ["default"]);
  let { loop = true } = $$props;
  let { closeOnEscape = true } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { menubar }, updateOption, ids } = setCtx10({ loop, closeOnEscape });
  validate_store(menubar, "menubar");
  component_subscribe($$self, menubar, (value) => $$invalidate(10, $menubar = value));
  const idValues = derived([ids.menubar], ([$menubarId]) => ({ menubar: $menubarId }));
  validate_store(idValues, "idValues");
  component_subscribe($$self, idValues, (value) => $$invalidate(2, $idValues = value));
  const attrs = getAttrs12("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("loop" in $$new_props) $$invalidate(7, loop = $$new_props.loop);
    if ("closeOnEscape" in $$new_props) $$invalidate(8, closeOnEscape = $$new_props.closeOnEscape);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(9, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCtx: setCtx10,
    getAttrs: getAttrs12,
    derived,
    loop,
    closeOnEscape,
    asChild,
    id,
    menubar,
    updateOption,
    ids,
    idValues,
    attrs,
    builder: builder2,
    $menubar,
    $idValues
  });
  $$self.$inject_state = ($$new_props) => {
    if ("loop" in $$props) $$invalidate(7, loop = $$new_props.loop);
    if ("closeOnEscape" in $$props) $$invalidate(8, closeOnEscape = $$new_props.closeOnEscape);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(9, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    512) {
      $: if (id) {
        ids.menubar.set(id);
      }
    }
    if ($$self.$$.dirty & /*loop*/
    128) {
      $: updateOption("loop", loop);
    }
    if ($$self.$$.dirty & /*closeOnEscape*/
    256) {
      $: updateOption("closeOnEscape", closeOnEscape);
    }
    if ($$self.$$.dirty & /*$menubar*/
    1024) {
      $: $$invalidate(1, builder2 = $menubar);
    }
  };
  return [
    asChild,
    builder2,
    $idValues,
    menubar,
    idValues,
    attrs,
    $$restProps,
    loop,
    closeOnEscape,
    id,
    $menubar,
    $$scope,
    slots
  ];
}
var Menubar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance72, create_fragment72, safe_not_equal, {
      loop: 7,
      closeOnEscape: 8,
      asChild: 0,
      id: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menubar",
      options,
      id: create_fragment72.name
    });
  }
  get loop() {
    throw new Error("<Menubar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<Menubar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<Menubar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<Menubar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Menubar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Menubar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Menubar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Menubar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Menubar_default = Menubar;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarSub.svelte
var get_default_slot_changes68 = (dirty) => ({ subIds: dirty & /*$idValues*/
1 });
var get_default_slot_context68 = (ctx) => ({ subIds: (
  /*$idValues*/
  ctx[0]
) });
function create_fragment73(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context68
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $idValues*/
        33)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes68
            ),
            get_default_slot_context68
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment73.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance73($$self, $$props, $$invalidate) {
  let $idValues;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarSub", slots, ["default"]);
  let { positioning = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { arrowSize = void 0 } = $$props;
  const { updateOption, ids } = setSubMenuCtx3({ positioning, disabled, arrowSize });
  const idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({ menu: $menuId, trigger: $triggerId }));
  validate_store(idValues, "idValues");
  component_subscribe($$self, idValues, (value) => $$invalidate(0, $idValues = value));
  const writable_props = ["positioning", "disabled", "arrowSize"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<MenubarSub> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("positioning" in $$props2) $$invalidate(2, positioning = $$props2.positioning);
    if ("disabled" in $$props2) $$invalidate(3, disabled = $$props2.disabled);
    if ("arrowSize" in $$props2) $$invalidate(4, arrowSize = $$props2.arrowSize);
    if ("$$scope" in $$props2) $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    derived,
    setSubMenuCtx: setSubMenuCtx3,
    positioning,
    disabled,
    arrowSize,
    updateOption,
    ids,
    idValues,
    $idValues
  });
  $$self.$inject_state = ($$props2) => {
    if ("positioning" in $$props2) $$invalidate(2, positioning = $$props2.positioning);
    if ("disabled" in $$props2) $$invalidate(3, disabled = $$props2.disabled);
    if ("arrowSize" in $$props2) $$invalidate(4, arrowSize = $$props2.arrowSize);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*positioning*/
    4) {
      $: updateOption("positioning", positioning);
    }
    if ($$self.$$.dirty & /*disabled*/
    8) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*arrowSize*/
    16) {
      $: updateOption("arrowSize", arrowSize);
    }
  };
  return [$idValues, idValues, positioning, disabled, arrowSize, $$scope, slots];
}
var MenubarSub = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance73, create_fragment73, safe_not_equal, {
      positioning: 2,
      disabled: 3,
      arrowSize: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarSub",
      options,
      id: create_fragment73.name
    });
  }
  get positioning() {
    throw new Error("<MenubarSub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioning(value) {
    throw new Error("<MenubarSub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<MenubarSub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<MenubarSub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowSize() {
    throw new Error("<MenubarSub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowSize(value) {
    throw new Error("<MenubarSub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarSub_default = MenubarSub;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarItem.svelte
var file64 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarItem.svelte";
var get_default_slot_changes_150 = (dirty) => ({
  builder: dirty & /*builder*/
  4,
  attrs: dirty & /*attrs*/
  2
});
var get_default_slot_context_150 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[1]
  )
});
var get_default_slot_changes69 = (dirty) => ({
  builder: dirty & /*builder*/
  4,
  attrs: dirty & /*attrs*/
  2
});
var get_default_slot_context69 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[1]
  )
});
function create_else_block48(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_150
  );
  let div_levels = [
    /*builder*/
    ctx[2],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file64, 19, 1, 513);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[2].action(div)),
          listen_dev(
            div,
            "m-click",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusin",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        262)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_150
            ),
            get_default_slot_context_150
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        4 && /*builder*/
        ctx2[2],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        dirty & /*attrs*/
        2 && /*attrs*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block48.name,
    type: "else",
    source: "(19:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block63(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context69
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        262)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes69
            ),
            get_default_slot_context69
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block63.name,
    type: "if",
    source: "(17:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment74(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block63, create_else_block48];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment74.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance74($$self, $$props, $$invalidate) {
  let builder2;
  let attrs;
  const omit_props_names = ["asChild", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $item;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarItem", slots, ["default"]);
  let { asChild = false } = $$props;
  let { disabled = false } = $$props;
  const { elements: { item } } = getMenuCtx();
  validate_store(item, "item");
  component_subscribe($$self, item, (value) => $$invalidate(7, $item = value));
  const dispatch = createDispatcher();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("disabled" in $$new_props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    disabledAttrs,
    getMenuCtx,
    getAttrs: getAttrs12,
    createDispatcher,
    asChild,
    disabled,
    item,
    dispatch,
    attrs,
    builder: builder2,
    $item
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("disabled" in $$props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("attrs" in $$props) $$invalidate(1, attrs = $$new_props.attrs);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$item*/
    128) {
      $: $$invalidate(2, builder2 = $item);
    }
    if ($$self.$$.dirty & /*disabled*/
    64) {
      $: $$invalidate(1, attrs = {
        ...getAttrs12("item"),
        ...disabledAttrs(disabled)
      });
    }
  };
  return [
    asChild,
    attrs,
    builder2,
    item,
    dispatch,
    $$restProps,
    disabled,
    $item,
    $$scope,
    slots
  ];
}
var MenubarItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance74, create_fragment74, safe_not_equal, { asChild: 0, disabled: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarItem",
      options,
      id: create_fragment74.name
    });
  }
  get asChild() {
    throw new Error("<MenubarItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<MenubarItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<MenubarItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<MenubarItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarItem_default = MenubarItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarMenu.svelte
var get_default_slot_changes70 = (dirty) => ({});
var get_default_slot_context70 = (ctx) => ({ menuIds: (
  /*ids*/
  ctx[0]
) });
function create_fragment75(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context70
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes70
            ),
            get_default_slot_context70
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment75.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance75($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarMenu", slots, ["default"]);
  let { closeOnOutsideClick = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { portal = void 0 } = $$props;
  let { open = void 0 } = $$props;
  let { onOpenChange = void 0 } = $$props;
  let { preventScroll = void 0 } = $$props;
  let { arrowSize = void 0 } = $$props;
  let { positioning = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { dir = void 0 } = $$props;
  let { typeahead = void 0 } = $$props;
  let { closeFocus = void 0 } = $$props;
  let { disableFocusFirstItem = void 0 } = $$props;
  const ids = {
    menu: generateId3(),
    trigger: generateId3()
  };
  const { states: { open: localOpen }, updateOption } = setMenuCtx({
    closeOnOutsideClick,
    ids,
    closeOnEscape,
    portal,
    preventScroll,
    arrowSize,
    positioning,
    loop,
    dir,
    typeahead,
    closeFocus,
    disableFocusFirstItem,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange == null ? void 0 : onOpenChange(next2);
        $$invalidate(1, open = next2);
      }
      return next2;
    }
  });
  const writable_props = [
    "closeOnOutsideClick",
    "closeOnEscape",
    "portal",
    "open",
    "onOpenChange",
    "preventScroll",
    "arrowSize",
    "positioning",
    "loop",
    "dir",
    "typeahead",
    "closeFocus",
    "disableFocusFirstItem"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<MenubarMenu> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("closeOnOutsideClick" in $$props2) $$invalidate(2, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("closeOnEscape" in $$props2) $$invalidate(3, closeOnEscape = $$props2.closeOnEscape);
    if ("portal" in $$props2) $$invalidate(4, portal = $$props2.portal);
    if ("open" in $$props2) $$invalidate(1, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(5, onOpenChange = $$props2.onOpenChange);
    if ("preventScroll" in $$props2) $$invalidate(6, preventScroll = $$props2.preventScroll);
    if ("arrowSize" in $$props2) $$invalidate(7, arrowSize = $$props2.arrowSize);
    if ("positioning" in $$props2) $$invalidate(8, positioning = $$props2.positioning);
    if ("loop" in $$props2) $$invalidate(9, loop = $$props2.loop);
    if ("dir" in $$props2) $$invalidate(10, dir = $$props2.dir);
    if ("typeahead" in $$props2) $$invalidate(11, typeahead = $$props2.typeahead);
    if ("closeFocus" in $$props2) $$invalidate(12, closeFocus = $$props2.closeFocus);
    if ("disableFocusFirstItem" in $$props2) $$invalidate(13, disableFocusFirstItem = $$props2.disableFocusFirstItem);
    if ("$$scope" in $$props2) $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setMenuCtx,
    generateId: generateId3,
    closeOnOutsideClick,
    closeOnEscape,
    portal,
    open,
    onOpenChange,
    preventScroll,
    arrowSize,
    positioning,
    loop,
    dir,
    typeahead,
    closeFocus,
    disableFocusFirstItem,
    ids,
    localOpen,
    updateOption
  });
  $$self.$inject_state = ($$props2) => {
    if ("closeOnOutsideClick" in $$props2) $$invalidate(2, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("closeOnEscape" in $$props2) $$invalidate(3, closeOnEscape = $$props2.closeOnEscape);
    if ("portal" in $$props2) $$invalidate(4, portal = $$props2.portal);
    if ("open" in $$props2) $$invalidate(1, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(5, onOpenChange = $$props2.onOpenChange);
    if ("preventScroll" in $$props2) $$invalidate(6, preventScroll = $$props2.preventScroll);
    if ("arrowSize" in $$props2) $$invalidate(7, arrowSize = $$props2.arrowSize);
    if ("positioning" in $$props2) $$invalidate(8, positioning = $$props2.positioning);
    if ("loop" in $$props2) $$invalidate(9, loop = $$props2.loop);
    if ("dir" in $$props2) $$invalidate(10, dir = $$props2.dir);
    if ("typeahead" in $$props2) $$invalidate(11, typeahead = $$props2.typeahead);
    if ("closeFocus" in $$props2) $$invalidate(12, closeFocus = $$props2.closeFocus);
    if ("disableFocusFirstItem" in $$props2) $$invalidate(13, disableFocusFirstItem = $$props2.disableFocusFirstItem);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    2) {
      $: open !== void 0 && localOpen.set(open);
    }
    if ($$self.$$.dirty & /*closeOnOutsideClick*/
    4) {
      $: updateOption("closeOnOutsideClick", closeOnOutsideClick);
    }
    if ($$self.$$.dirty & /*closeOnEscape*/
    8) {
      $: updateOption("closeOnEscape", closeOnEscape);
    }
    if ($$self.$$.dirty & /*portal*/
    16) {
      $: updateOption("portal", portal);
    }
    if ($$self.$$.dirty & /*preventScroll*/
    64) {
      $: updateOption("preventScroll", preventScroll);
    }
    if ($$self.$$.dirty & /*arrowSize*/
    128) {
      $: updateOption("arrowSize", arrowSize);
    }
    if ($$self.$$.dirty & /*positioning*/
    256) {
      $: updateOption("positioning", positioning);
    }
    if ($$self.$$.dirty & /*loop*/
    512) {
      $: updateOption("loop", loop);
    }
    if ($$self.$$.dirty & /*dir*/
    1024) {
      $: updateOption("dir", dir);
    }
    if ($$self.$$.dirty & /*closeFocus*/
    4096) {
      $: updateOption("closeFocus", closeFocus);
    }
    if ($$self.$$.dirty & /*disableFocusFirstItem*/
    8192) {
      $: updateOption("disableFocusFirstItem", disableFocusFirstItem);
    }
    if ($$self.$$.dirty & /*typeahead*/
    2048) {
      $: updateOption("typeahead", typeahead);
    }
  };
  return [
    ids,
    open,
    closeOnOutsideClick,
    closeOnEscape,
    portal,
    onOpenChange,
    preventScroll,
    arrowSize,
    positioning,
    loop,
    dir,
    typeahead,
    closeFocus,
    disableFocusFirstItem,
    $$scope,
    slots
  ];
}
var MenubarMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance75, create_fragment75, safe_not_equal, {
      closeOnOutsideClick: 2,
      closeOnEscape: 3,
      portal: 4,
      open: 1,
      onOpenChange: 5,
      preventScroll: 6,
      arrowSize: 7,
      positioning: 8,
      loop: 9,
      dir: 10,
      typeahead: 11,
      closeFocus: 12,
      disableFocusFirstItem: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarMenu",
      options,
      id: create_fragment75.name
    });
  }
  get closeOnOutsideClick() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnOutsideClick(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get portal() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portal(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onOpenChange() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onOpenChange(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventScroll() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScroll(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowSize() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowSize(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positioning() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioning(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dir() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dir(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get typeahead() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set typeahead(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeFocus() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeFocus(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableFocusFirstItem() {
    throw new Error("<MenubarMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableFocusFirstItem(value) {
    throw new Error("<MenubarMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarMenu_default = MenubarMenu;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarGroup.svelte
var file65 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarGroup.svelte";
var get_default_slot_changes_151 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_151 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes71 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context71 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block49(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context_151
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file65, 12, 1, 286);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes_151
            ),
            get_default_slot_context_151
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block49.name,
    type: "else",
    source: "(12:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block64(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context71
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes71
            ),
            get_default_slot_context71
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block64.name,
    type: "if",
    source: "(10:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment76(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block64, create_else_block49];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment76.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance76($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $group;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarGroup", slots, ["default"]);
  let { asChild = false } = $$props;
  const { group, id } = setGroupCtx2();
  validate_store(group, "group");
  component_subscribe($$self, group, (value) => $$invalidate(5, $group = value));
  const attrs = getAttrs12("group");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setGroupCtx: setGroupCtx2,
    getAttrs: getAttrs12,
    asChild,
    group,
    id,
    attrs,
    builder: builder2,
    $group
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$group*/
    32) {
      $: $$invalidate(1, builder2 = $group(id));
    }
  };
  return [asChild, builder2, group, attrs, $$restProps, $group, $$scope, slots];
}
var MenubarGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance76, create_fragment76, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarGroup",
      options,
      id: create_fragment76.name
    });
  }
  get asChild() {
    throw new Error("<MenubarGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<MenubarGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarGroup_default = MenubarGroup;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarLabel.svelte
var file66 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarLabel.svelte";
var get_default_slot_changes_152 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_152 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes72 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context72 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block50(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context_152
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file66, 12, 1, 300);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes_152
            ),
            get_default_slot_context_152
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block50.name,
    type: "else",
    source: "(12:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block65(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context72
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes72
            ),
            get_default_slot_context72
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block65.name,
    type: "if",
    source: "(10:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment77(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block65, create_else_block50];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment77.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance77($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $groupLabel;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarLabel", slots, ["default"]);
  let { asChild = false } = $$props;
  const { groupLabel, id } = getGroupLabel3();
  validate_store(groupLabel, "groupLabel");
  component_subscribe($$self, groupLabel, (value) => $$invalidate(5, $groupLabel = value));
  const attrs = getAttrs12("label");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getGroupLabel: getGroupLabel3,
    getAttrs: getAttrs12,
    asChild,
    groupLabel,
    id,
    attrs,
    builder: builder2,
    $groupLabel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$groupLabel*/
    32) {
      $: $$invalidate(1, builder2 = $groupLabel(id));
    }
  };
  return [asChild, builder2, groupLabel, attrs, $$restProps, $groupLabel, $$scope, slots];
}
var MenubarLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance77, create_fragment77, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarLabel",
      options,
      id: create_fragment77.name
    });
  }
  get asChild() {
    throw new Error("<MenubarLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<MenubarLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarLabel_default = MenubarLabel;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarArrow.svelte
var file67 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarArrow.svelte";
var get_default_slot_changes73 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context73 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block51(ctx) {
  let div;
  let builder_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[1],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file67, 15, 1, 313);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block51.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block66(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context73
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes73
            ),
            get_default_slot_context73
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block66.name,
    type: "if",
    source: "(13:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment78(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block66, create_else_block51];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment78.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance78($$self, $$props, $$invalidate) {
  let builder2;
  let $arrow;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarArrow", slots, ["default"]);
  let { size: size2 = 8 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { arrow: arrow2 } } = setArrow4(size2);
  validate_store(arrow2, "arrow");
  component_subscribe($$self, arrow2, (value) => $$invalidate(5, $arrow = value));
  const attrs = getAttrs12("arrow");
  const writable_props = ["size", "asChild"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<MenubarArrow> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2) $$invalidate(4, size2 = $$props2.size);
    if ("asChild" in $$props2) $$invalidate(0, asChild = $$props2.asChild);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setArrow: setArrow4,
    getAttrs: getAttrs12,
    size: size2,
    asChild,
    arrow: arrow2,
    attrs,
    builder: builder2,
    $arrow
  });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2) $$invalidate(4, size2 = $$props2.size);
    if ("asChild" in $$props2) $$invalidate(0, asChild = $$props2.asChild);
    if ("builder" in $$props2) $$invalidate(1, builder2 = $$props2.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$arrow*/
    32) {
      $: $$invalidate(1, builder2 = $arrow);
    }
  };
  return [asChild, builder2, arrow2, attrs, size2, $arrow, $$scope, slots];
}
var MenubarArrow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance78, create_fragment78, safe_not_equal, { size: 4, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarArrow",
      options,
      id: create_fragment78.name
    });
  }
  get size() {
    throw new Error("<MenubarArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MenubarArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<MenubarArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<MenubarArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarArrow_default = MenubarArrow;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarContent.svelte
var file68 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarContent.svelte";
var get_default_slot_changes_510 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_510 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_410 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_410 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_310 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_310 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_210 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_210 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_153 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_153 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes74 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context74 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
function create_if_block_512(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_510
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file68, 71, 1, 1664);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes_510
            ),
            get_default_slot_context_510
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13],
        /*attrs*/
        ctx2[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_512.name,
    type: "if",
    source: "(71:16) ",
    ctx
  });
  return block;
}
function create_if_block_412(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_410
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file68, 61, 1, 1467);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_410
            ),
            get_default_slot_context_410
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_412.name,
    type: "if",
    source: "(61:33) ",
    ctx
  });
  return block;
}
function create_if_block_312(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_310
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file68, 51, 1, 1256);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_310
            ),
            get_default_slot_context_310
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_312.name,
    type: "if",
    source: "(51:32) ",
    ctx
  });
  return block;
}
function create_if_block_212(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_210
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file68, 40, 1, 1004);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_210
            ),
            get_default_slot_context_210
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_212.name,
    type: "if",
    source: "(40:49) ",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_153
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file68, 30, 1, 773);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_153
            ),
            get_default_slot_context_153
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(30:30) ",
    ctx
  });
  return block;
}
function create_if_block67(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context74
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes74
            ),
            get_default_slot_context74
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block67.name,
    type: "if",
    source: "(28:0) {#if asChild && $open}",
    ctx
  });
  return block;
}
function create_fragment79(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block67,
    create_if_block_112,
    create_if_block_212,
    create_if_block_312,
    create_if_block_412,
    create_if_block_512
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$open*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$open*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$open*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 4;
    if (
      /*$open*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment79.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance79($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "sideOffset",
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $menu;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarContent", slots, ["default"]);
  let { sideOffset = 5 } = $$props;
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { menu }, states: { open }, ids } = getContent4(sideOffset);
  validate_store(menu, "menu");
  component_subscribe($$self, menu, (value) => $$invalidate(16, $menu = value));
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs12("content");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("sideOffset" in $$new_props) $$invalidate(14, sideOffset = $$new_props.sideOffset);
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(15, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createDispatcher,
    melt,
    getContent: getContent4,
    getAttrs: getAttrs12,
    sideOffset,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    menu,
    open,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $menu,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("sideOffset" in $$props) $$invalidate(14, sideOffset = $$new_props.sideOffset);
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(15, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    32768) {
      $: if (id) {
        ids.menu.set(id);
      }
    }
    if ($$self.$$.dirty & /*$menu*/
    65536) {
      $: $$invalidate(7, builder2 = $menu);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $open,
    menu,
    open,
    dispatch,
    attrs,
    $$restProps,
    sideOffset,
    id,
    $menu,
    $$scope,
    slots
  ];
}
var MenubarContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance79, create_fragment79, safe_not_equal, {
      sideOffset: 14,
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6,
      id: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarContent",
      options,
      id: create_fragment79.name
    });
  }
  get sideOffset() {
    throw new Error("<MenubarContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sideOffset(value) {
    throw new Error("<MenubarContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<MenubarContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<MenubarContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<MenubarContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<MenubarContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<MenubarContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<MenubarContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<MenubarContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<MenubarContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<MenubarContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<MenubarContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<MenubarContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<MenubarContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<MenubarContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<MenubarContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<MenubarContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<MenubarContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarContent_default = MenubarContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarTrigger.svelte
var file69 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarTrigger.svelte";
var get_default_slot_changes_154 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_154 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes75 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context75 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block52(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_154
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file69, 22, 1, 474);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-pointerenter",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_154
            ),
            get_default_slot_context_154
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block52.name,
    type: "else",
    source: "(22:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block68(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context75
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes75
            ),
            get_default_slot_context75
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block68.name,
    type: "if",
    source: "(20:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment80(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block68, create_else_block52];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment80.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance80($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $trigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarTrigger", slots, ["default"]);
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { trigger }, ids } = getMenuCtx();
  validate_store(trigger, "trigger");
  component_subscribe($$self, trigger, (value) => $$invalidate(7, $trigger = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs12("trigger");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(6, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getMenuCtx,
    getAttrs: getAttrs12,
    createDispatcher,
    asChild,
    id,
    trigger,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $trigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(6, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    64) {
      $: if (id) {
        ids.trigger.set(id);
      }
    }
    if ($$self.$$.dirty & /*$trigger*/
    128) {
      $: $$invalidate(1, builder2 = $trigger);
    }
  };
  return [
    asChild,
    builder2,
    trigger,
    dispatch,
    attrs,
    $$restProps,
    id,
    $trigger,
    $$scope,
    slots
  ];
}
var MenubarTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance80, create_fragment80, safe_not_equal, { asChild: 0, id: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarTrigger",
      options,
      id: create_fragment80.name
    });
  }
  get asChild() {
    throw new Error("<MenubarTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<MenubarTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<MenubarTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<MenubarTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarTrigger_default = MenubarTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarRadioItem.svelte
var file70 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarRadioItem.svelte";
var get_default_slot_changes_155 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_155 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes76 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context76 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block53(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context_155
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file70, 18, 1, 489);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(div)),
          listen_dev(
            div,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusin",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes_155
            ),
            get_default_slot_context_155
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block53.name,
    type: "else",
    source: "(18:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block69(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context76
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes76
            ),
            get_default_slot_context76
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block69.name,
    type: "if",
    source: "(16:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment81(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block69, create_else_block53];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment81.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance81($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["value", "disabled", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $radioItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarRadioItem", slots, ["default"]);
  let { value } = $$props;
  let { disabled = false } = $$props;
  let { asChild = false } = $$props;
  const { elements: { radioItem } } = setRadioItemCtx(value);
  validate_store(radioItem, "radioItem");
  component_subscribe($$self, radioItem, (value2) => $$invalidate(8, $radioItem = value2));
  const dispatch = createDispatcher();
  const attrs = getAttrs12("radio-item");
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<MenubarRadioItem> was created without expected prop 'value'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setRadioItemCtx,
    getAttrs: getAttrs12,
    createDispatcher,
    value,
    disabled,
    asChild,
    radioItem,
    dispatch,
    attrs,
    builder: builder2,
    $radioItem
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$radioItem, value, disabled*/
    448) {
      $: $$invalidate(1, builder2 = $radioItem({ value, disabled }));
    }
  };
  return [
    asChild,
    builder2,
    radioItem,
    dispatch,
    attrs,
    $$restProps,
    value,
    disabled,
    $radioItem,
    $$scope,
    slots
  ];
}
var MenubarRadioItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance81, create_fragment81, safe_not_equal, { value: 6, disabled: 7, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarRadioItem",
      options,
      id: create_fragment81.name
    });
  }
  get value() {
    throw new Error("<MenubarRadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<MenubarRadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<MenubarRadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<MenubarRadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<MenubarRadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<MenubarRadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarRadioItem_default = MenubarRadioItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarSeparator.svelte
var file71 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarSeparator.svelte";
var get_default_slot_changes77 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context77 = (ctx) => ({ builder: (
  /*builder*/
  ctx[1]
) });
function create_else_block54(ctx) {
  let div;
  let builder_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file71, 14, 1, 296);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block54.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block70(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context77
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes77
            ),
            get_default_slot_context77
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block70.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment82(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block70, create_else_block54];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment82.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance82($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $separator;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarSeparator", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { separator } } = getMenuCtx();
  validate_store(separator, "separator");
  component_subscribe($$self, separator, (value) => $$invalidate(5, $separator = value));
  const attrs = getAttrs12("separator");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getMenuCtx,
    getAttrs: getAttrs12,
    asChild,
    separator,
    attrs,
    builder: builder2,
    $separator
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$separator*/
    32) {
      $: $$invalidate(1, builder2 = $separator);
    }
  };
  return [asChild, builder2, separator, attrs, $$restProps, $separator, $$scope, slots];
}
var MenubarSeparator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance82, create_fragment82, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarSeparator",
      options,
      id: create_fragment82.name
    });
  }
  get asChild() {
    throw new Error("<MenubarSeparator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<MenubarSeparator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarSeparator_default = MenubarSeparator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarSubContent.svelte
var file72 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarSubContent.svelte";
var get_default_slot_changes_511 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_511 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_411 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_411 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_311 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_311 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_211 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_211 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_156 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_156 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes78 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context78 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
function create_if_block_513(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_511
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file72, 79, 1, 1975);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes_511
            ),
            get_default_slot_context_511
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13],
        /*attrs*/
        ctx2[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_513.name,
    type: "if",
    source: "(79:19) ",
    ctx
  });
  return block;
}
function create_if_block_413(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_411
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file72, 67, 1, 1718);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_411
            ),
            get_default_slot_context_411
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_413.name,
    type: "if",
    source: "(67:36) ",
    ctx
  });
  return block;
}
function create_if_block_313(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_311
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file72, 55, 1, 1447);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_311
            ),
            get_default_slot_context_311
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_313.name,
    type: "if",
    source: "(55:35) ",
    ctx
  });
  return block;
}
function create_if_block_213(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_211
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file72, 42, 1, 1135);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_211
            ),
            get_default_slot_context_211
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_213.name,
    type: "if",
    source: "(42:52) ",
    ctx
  });
  return block;
}
function create_if_block_113(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_156
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file72, 30, 1, 844);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_156
            ),
            get_default_slot_context_156
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(30:33) ",
    ctx
  });
  return block;
}
function create_if_block71(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context78
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes78
            ),
            get_default_slot_context78
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block71.name,
    type: "if",
    source: "(28:0) {#if asChild && $subOpen}",
    ctx
  });
  return block;
}
function create_fragment83(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block71,
    create_if_block_113,
    create_if_block_213,
    create_if_block_313,
    create_if_block_413,
    create_if_block_513
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$subOpen*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$subOpen*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$subOpen*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$subOpen*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$subOpen*/
      ctx2[8]
    ) return 4;
    if (
      /*$subOpen*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment83.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance83($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $subMenu;
  let $subOpen;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarSubContent", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { subMenu }, states: { subOpen }, ids } = getSubMenuCtx2();
  validate_store(subMenu, "subMenu");
  component_subscribe($$self, subMenu, (value) => $$invalidate(15, $subMenu = value));
  validate_store(subOpen, "subOpen");
  component_subscribe($$self, subOpen, (value) => $$invalidate(8, $subOpen = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs12("sub-content");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(14, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createDispatcher,
    melt,
    getSubMenuCtx: getSubMenuCtx2,
    getAttrs: getAttrs12,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    subMenu,
    subOpen,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $subMenu,
    $subOpen
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(14, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    16384) {
      $: if (id) {
        ids.menu.set(id);
      }
    }
    if ($$self.$$.dirty & /*$subMenu*/
    32768) {
      $: $$invalidate(7, builder2 = $subMenu);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $subOpen,
    subMenu,
    subOpen,
    dispatch,
    attrs,
    $$restProps,
    id,
    $subMenu,
    $$scope,
    slots
  ];
}
var MenubarSubContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance83, create_fragment83, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6,
      id: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarSubContent",
      options,
      id: create_fragment83.name
    });
  }
  get transition() {
    throw new Error("<MenubarSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<MenubarSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<MenubarSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<MenubarSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<MenubarSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<MenubarSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<MenubarSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<MenubarSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<MenubarSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<MenubarSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<MenubarSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<MenubarSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<MenubarSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<MenubarSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<MenubarSubContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<MenubarSubContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarSubContent_default = MenubarSubContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarSubTrigger.svelte
var file73 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarSubTrigger.svelte";
var get_default_slot_changes_157 = (dirty) => ({
  builder: dirty & /*builder*/
  4,
  attrs: dirty & /*attrs*/
  2
});
var get_default_slot_context_157 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[1]
  )
});
var get_default_slot_changes79 = (dirty) => ({
  builder: dirty & /*builder*/
  4,
  attrs: dirty & /*attrs*/
  2
});
var get_default_slot_context79 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[1]
  )
});
function create_else_block55(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context_157
  );
  let div_levels = [
    /*builder*/
    ctx[2],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file73, 26, 1, 699);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[2].action(div)),
          listen_dev(
            div,
            "m-click",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusin",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        518)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes_157
            ),
            get_default_slot_context_157
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        4 && /*builder*/
        ctx2[2],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        dirty & /*attrs*/
        2 && /*attrs*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block55.name,
    type: "else",
    source: "(26:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block72(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context79
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        518)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes79
            ),
            get_default_slot_context79
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block72.name,
    type: "if",
    source: "(24:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment84(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block72, create_else_block55];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment84.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance84($$self, $$props, $$invalidate) {
  let builder2;
  let attrs;
  const omit_props_names = ["disabled", "asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $subTrigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarSubTrigger", slots, ["default"]);
  let { disabled = false } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { subTrigger }, ids } = getSubMenuCtx2();
  validate_store(subTrigger, "subTrigger");
  component_subscribe($$self, subTrigger, (value) => $$invalidate(8, $subTrigger = value));
  const dispatch = createDispatcher();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("disabled" in $$new_props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    disabledAttrs,
    getSubMenuCtx: getSubMenuCtx2,
    getAttrs: getAttrs12,
    createDispatcher,
    disabled,
    asChild,
    id,
    subTrigger,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $subTrigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("disabled" in $$props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
    if ("attrs" in $$props) $$invalidate(1, attrs = $$new_props.attrs);
    if ("builder" in $$props) $$invalidate(2, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    128) {
      $: if (id) {
        ids.trigger.set(id);
      }
    }
    if ($$self.$$.dirty & /*$subTrigger*/
    256) {
      $: $$invalidate(2, builder2 = $subTrigger);
    }
    if ($$self.$$.dirty & /*disabled*/
    64) {
      $: $$invalidate(1, attrs = {
        ...getAttrs12("sub-trigger"),
        ...disabledAttrs(disabled)
      });
    }
  };
  return [
    asChild,
    attrs,
    builder2,
    subTrigger,
    dispatch,
    $$restProps,
    disabled,
    id,
    $subTrigger,
    $$scope,
    slots
  ];
}
var MenubarSubTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance84, create_fragment84, safe_not_equal, { disabled: 6, asChild: 0, id: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarSubTrigger",
      options,
      id: create_fragment84.name
    });
  }
  get disabled() {
    throw new Error("<MenubarSubTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<MenubarSubTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<MenubarSubTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<MenubarSubTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<MenubarSubTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<MenubarSubTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarSubTrigger_default = MenubarSubTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarRadioGroup.svelte
var file74 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarRadioGroup.svelte";
var get_default_slot_changes_158 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_158 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes80 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context80 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block56(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_158
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file74, 28, 1, 632);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_158
            ),
            get_default_slot_context_158
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block56.name,
    type: "else",
    source: "(28:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block73(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context80
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes80
            ),
            get_default_slot_context80
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block73.name,
    type: "if",
    source: "(26:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment85(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block73, create_else_block56];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment85.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance85($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["value", "onValueChange", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $radioGroup;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarRadioGroup", slots, ["default"]);
  let { value = void 0 } = $$props;
  let { onValueChange = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { radioGroup }, states: { value: localValue } } = setRadioGroupCtx3({
    defaultValue: value,
    onValueChange: ({ next: next2 }) => {
      if (next2 && next2 !== value) {
        onValueChange == null ? void 0 : onValueChange(next2);
        $$invalidate(5, value = next2);
      }
      return next2;
    }
  });
  validate_store(radioGroup, "radioGroup");
  component_subscribe($$self, radioGroup, (value2) => $$invalidate(7, $radioGroup = value2));
  const attrs = getAttrs12("radio-group");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$new_props) $$invalidate(6, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setRadioGroupCtx: setRadioGroupCtx3,
    getAttrs: getAttrs12,
    value,
    onValueChange,
    asChild,
    radioGroup,
    localValue,
    attrs,
    builder: builder2,
    $radioGroup
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$props) $$invalidate(6, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    32) {
      $: value !== void 0 && localValue.set(value);
    }
    if ($$self.$$.dirty & /*$radioGroup*/
    128) {
      $: $$invalidate(1, builder2 = $radioGroup);
    }
  };
  return [
    asChild,
    builder2,
    radioGroup,
    attrs,
    $$restProps,
    value,
    onValueChange,
    $radioGroup,
    $$scope,
    slots
  ];
}
var MenubarRadioGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance85, create_fragment85, safe_not_equal, { value: 5, onValueChange: 6, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarRadioGroup",
      options,
      id: create_fragment85.name
    });
  }
  get value() {
    throw new Error("<MenubarRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<MenubarRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValueChange() {
    throw new Error("<MenubarRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValueChange(value) {
    throw new Error("<MenubarRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<MenubarRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<MenubarRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarRadioGroup_default = MenubarRadioGroup;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarCheckboxItem.svelte
var file75 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarCheckboxItem.svelte";
var get_default_slot_changes_159 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_159 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes81 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context81 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block57(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context_159
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file75, 35, 1, 854);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(div)),
          listen_dev(
            div,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusin",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-focusout",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1026)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes_159
            ),
            get_default_slot_context_159
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block57.name,
    type: "else",
    source: "(35:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block74(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context81
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1026)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes81
            ),
            get_default_slot_context81
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block74.name,
    type: "if",
    source: "(33:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment86(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block74, create_else_block57];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment86.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance86($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["checked", "onCheckedChange", "disabled", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $checkboxItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarCheckboxItem", slots, ["default"]);
  let { checked = void 0 } = $$props;
  let { onCheckedChange = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { checkboxItem }, states: { checked: localChecked }, updateOption } = setCheckboxItem3({
    disabled,
    defaultChecked: checked,
    onCheckedChange: ({ next: next2 }) => {
      if (checked !== next2) {
        onCheckedChange == null ? void 0 : onCheckedChange(next2);
        $$invalidate(6, checked = next2);
      }
      return next2;
    }
  });
  validate_store(checkboxItem, "checkboxItem");
  component_subscribe($$self, checkboxItem, (value) => $$invalidate(9, $checkboxItem = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs12("checkbox-item");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props) $$invalidate(6, checked = $$new_props.checked);
    if ("onCheckedChange" in $$new_props) $$invalidate(7, onCheckedChange = $$new_props.onCheckedChange);
    if ("disabled" in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCheckboxItem: setCheckboxItem3,
    getAttrs: getAttrs12,
    createDispatcher,
    checked,
    onCheckedChange,
    disabled,
    asChild,
    checkboxItem,
    localChecked,
    updateOption,
    dispatch,
    attrs,
    builder: builder2,
    $checkboxItem
  });
  $$self.$inject_state = ($$new_props) => {
    if ("checked" in $$props) $$invalidate(6, checked = $$new_props.checked);
    if ("onCheckedChange" in $$props) $$invalidate(7, onCheckedChange = $$new_props.onCheckedChange);
    if ("disabled" in $$props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checked*/
    64) {
      $: checked !== void 0 && localChecked.set(checked);
    }
    if ($$self.$$.dirty & /*disabled*/
    256) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*$checkboxItem*/
    512) {
      $: $$invalidate(1, builder2 = $checkboxItem);
    }
  };
  return [
    asChild,
    builder2,
    checkboxItem,
    dispatch,
    attrs,
    $$restProps,
    checked,
    onCheckedChange,
    disabled,
    $checkboxItem,
    $$scope,
    slots
  ];
}
var MenubarCheckboxItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance86, create_fragment86, safe_not_equal, {
      checked: 6,
      onCheckedChange: 7,
      disabled: 8,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarCheckboxItem",
      options,
      id: create_fragment86.name
    });
  }
  get checked() {
    throw new Error("<MenubarCheckboxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<MenubarCheckboxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCheckedChange() {
    throw new Error("<MenubarCheckboxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCheckedChange(value) {
    throw new Error("<MenubarCheckboxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<MenubarCheckboxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<MenubarCheckboxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<MenubarCheckboxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<MenubarCheckboxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenubarCheckboxItem_default = MenubarCheckboxItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarRadioIndicator.svelte
function create_if_block75(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block75.name,
    type: "if",
    source: "(5:0) {#if $isChecked(value)}",
    ctx
  });
  return block;
}
function create_fragment87(ctx) {
  let show_if = (
    /*$isChecked*/
    ctx[0](
      /*value*/
      ctx[2]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block75(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$isChecked*/
      1) show_if = /*$isChecked*/
      ctx2[0](
        /*value*/
        ctx2[2]
      );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$isChecked*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block75(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment87.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance87($$self, $$props, $$invalidate) {
  let $isChecked;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarRadioIndicator", slots, ["default"]);
  const { isChecked, value } = getRadioIndicator3();
  validate_store(isChecked, "isChecked");
  component_subscribe($$self, isChecked, (value2) => $$invalidate(0, $isChecked = value2));
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<MenubarRadioIndicator> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getRadioIndicator: getRadioIndicator3,
    isChecked,
    value,
    $isChecked
  });
  return [$isChecked, isChecked, value, $$scope, slots];
}
var MenubarRadioIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance87, create_fragment87, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarRadioIndicator",
      options,
      id: create_fragment87.name
    });
  }
};
var MenubarRadioIndicator_default = MenubarRadioIndicator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarCheckboxIndicator.svelte
var file76 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/menubar/components/MenubarCheckboxIndicator.svelte";
var get_default_slot_changes82 = (dirty) => ({ checked: dirty & /*$checked*/
1 });
var get_default_slot_context82 = (ctx) => ({ checked: (
  /*$checked*/
  ctx[0]
) });
function create_if_block76(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_default_slot_context82
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $checked*/
        17)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_default_slot_changes82
            ),
            get_default_slot_context82
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block76.name,
    type: "if",
    source: "(7:1) {#if $checked}",
    ctx
  });
  return block;
}
function create_fragment88(ctx) {
  let div;
  let current;
  let if_block = (
    /*$checked*/
    ctx[0] && create_if_block76(ctx)
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    /*attrs*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block) if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file76, 5, 0, 165);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block) if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$checked*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$checked*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block76(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        /*attrs*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment88.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance88($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $checked;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenubarCheckboxIndicator", slots, ["default"]);
  const checked = getCheckboxIndicator3();
  validate_store(checked, "checked");
  component_subscribe($$self, checked, (value) => $$invalidate(0, $checked = value));
  const attrs = getAttrs12("checkbox-indicator");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getCheckboxIndicator: getCheckboxIndicator3,
    getAttrs: getAttrs12,
    checked,
    attrs,
    $checked
  });
  return [$checked, checked, attrs, $$restProps, $$scope, slots];
}
var MenubarCheckboxIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance88, create_fragment88, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenubarCheckboxIndicator",
      options,
      id: create_fragment88.name
    });
  }
};
var MenubarCheckboxIndicator_default = MenubarCheckboxIndicator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/popover/index.js
var popover_exports = {};
__export(popover_exports, {
  Arrow: () => PopoverArrow_default,
  Close: () => PopoverClose_default,
  Content: () => PopoverContent_default,
  Popover: () => Popover_default,
  PopoverArrow: () => PopoverArrow_default,
  PopoverClose: () => PopoverClose_default,
  PopoverContent: () => PopoverContent_default,
  PopoverTrigger: () => PopoverTrigger_default,
  Root: () => Popover_default,
  Trigger: () => PopoverTrigger_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/popover/ctx.js
var NAME13 = "popover";
var PARTS12 = ["arrow", "close", "content", "trigger"];
var getAttrs13 = createBitAttrs(NAME13, PARTS12);
function setCtx11(props) {
  const popover = createPopover({
    ...removeUndefined2(props),
    forceVisible: true
  });
  setContext(NAME13, popover);
  return {
    ...popover,
    updateOption: getOptionUpdater(popover.options)
  };
}
function getCtx12() {
  return getContext(NAME13);
}
function setArrow5(size2 = 8) {
  const popover = getCtx12();
  popover.options.arrowSize.set(size2);
  return popover;
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/popover/components/Popover.svelte
var get_default_slot_changes83 = (dirty) => ({ ids: dirty & /*$idValues*/
1 });
var get_default_slot_context83 = (ctx) => ({ ids: (
  /*$idValues*/
  ctx[0]
) });
function create_fragment89(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context83
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $idValues*/
        8193)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes83
            ),
            get_default_slot_context83
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment89.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance89($$self, $$props, $$invalidate) {
  let $idValues;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popover", slots, ["default"]);
  let { positioning = void 0 } = $$props;
  let { arrowSize = void 0 } = $$props;
  let { disableFocusTrap = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { closeOnOutsideClick = void 0 } = $$props;
  let { preventScroll = void 0 } = $$props;
  let { portal = void 0 } = $$props;
  let { open = void 0 } = $$props;
  let { onOpenChange = void 0 } = $$props;
  let { openFocus = void 0 } = $$props;
  let { closeFocus = void 0 } = $$props;
  const { updateOption, states: { open: localOpen }, ids } = setCtx11({
    positioning,
    arrowSize,
    disableFocusTrap,
    closeOnEscape,
    closeOnOutsideClick,
    preventScroll,
    portal,
    defaultOpen: open,
    openFocus,
    closeFocus,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange == null ? void 0 : onOpenChange(next2);
        $$invalidate(2, open = next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.content, ids.trigger], ([$contentId, $triggerId]) => ({ content: $contentId, trigger: $triggerId }));
  validate_store(idValues, "idValues");
  component_subscribe($$self, idValues, (value) => $$invalidate(0, $idValues = value));
  const writable_props = [
    "positioning",
    "arrowSize",
    "disableFocusTrap",
    "closeOnEscape",
    "closeOnOutsideClick",
    "preventScroll",
    "portal",
    "open",
    "onOpenChange",
    "openFocus",
    "closeFocus"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Popover> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("positioning" in $$props2) $$invalidate(3, positioning = $$props2.positioning);
    if ("arrowSize" in $$props2) $$invalidate(4, arrowSize = $$props2.arrowSize);
    if ("disableFocusTrap" in $$props2) $$invalidate(5, disableFocusTrap = $$props2.disableFocusTrap);
    if ("closeOnEscape" in $$props2) $$invalidate(6, closeOnEscape = $$props2.closeOnEscape);
    if ("closeOnOutsideClick" in $$props2) $$invalidate(7, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("preventScroll" in $$props2) $$invalidate(8, preventScroll = $$props2.preventScroll);
    if ("portal" in $$props2) $$invalidate(9, portal = $$props2.portal);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(10, onOpenChange = $$props2.onOpenChange);
    if ("openFocus" in $$props2) $$invalidate(11, openFocus = $$props2.openFocus);
    if ("closeFocus" in $$props2) $$invalidate(12, closeFocus = $$props2.closeFocus);
    if ("$$scope" in $$props2) $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setCtx: setCtx11,
    derived,
    positioning,
    arrowSize,
    disableFocusTrap,
    closeOnEscape,
    closeOnOutsideClick,
    preventScroll,
    portal,
    open,
    onOpenChange,
    openFocus,
    closeFocus,
    updateOption,
    localOpen,
    ids,
    idValues,
    $idValues
  });
  $$self.$inject_state = ($$props2) => {
    if ("positioning" in $$props2) $$invalidate(3, positioning = $$props2.positioning);
    if ("arrowSize" in $$props2) $$invalidate(4, arrowSize = $$props2.arrowSize);
    if ("disableFocusTrap" in $$props2) $$invalidate(5, disableFocusTrap = $$props2.disableFocusTrap);
    if ("closeOnEscape" in $$props2) $$invalidate(6, closeOnEscape = $$props2.closeOnEscape);
    if ("closeOnOutsideClick" in $$props2) $$invalidate(7, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("preventScroll" in $$props2) $$invalidate(8, preventScroll = $$props2.preventScroll);
    if ("portal" in $$props2) $$invalidate(9, portal = $$props2.portal);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(10, onOpenChange = $$props2.onOpenChange);
    if ("openFocus" in $$props2) $$invalidate(11, openFocus = $$props2.openFocus);
    if ("closeFocus" in $$props2) $$invalidate(12, closeFocus = $$props2.closeFocus);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    4) {
      $: open !== void 0 && localOpen.set(open);
    }
    if ($$self.$$.dirty & /*positioning*/
    8) {
      $: updateOption("positioning", positioning);
    }
    if ($$self.$$.dirty & /*arrowSize*/
    16) {
      $: updateOption("arrowSize", arrowSize);
    }
    if ($$self.$$.dirty & /*disableFocusTrap*/
    32) {
      $: updateOption("disableFocusTrap", disableFocusTrap);
    }
    if ($$self.$$.dirty & /*closeOnEscape*/
    64) {
      $: updateOption("closeOnEscape", closeOnEscape);
    }
    if ($$self.$$.dirty & /*closeOnOutsideClick*/
    128) {
      $: updateOption("closeOnOutsideClick", closeOnOutsideClick);
    }
    if ($$self.$$.dirty & /*preventScroll*/
    256) {
      $: updateOption("preventScroll", preventScroll);
    }
    if ($$self.$$.dirty & /*portal*/
    512) {
      $: updateOption("portal", portal);
    }
    if ($$self.$$.dirty & /*openFocus*/
    2048) {
      $: updateOption("openFocus", openFocus);
    }
    if ($$self.$$.dirty & /*closeFocus*/
    4096) {
      $: updateOption("closeFocus", closeFocus);
    }
  };
  return [
    $idValues,
    idValues,
    open,
    positioning,
    arrowSize,
    disableFocusTrap,
    closeOnEscape,
    closeOnOutsideClick,
    preventScroll,
    portal,
    onOpenChange,
    openFocus,
    closeFocus,
    $$scope,
    slots
  ];
}
var Popover = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance89, create_fragment89, safe_not_equal, {
      positioning: 3,
      arrowSize: 4,
      disableFocusTrap: 5,
      closeOnEscape: 6,
      closeOnOutsideClick: 7,
      preventScroll: 8,
      portal: 9,
      open: 2,
      onOpenChange: 10,
      openFocus: 11,
      closeFocus: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popover",
      options,
      id: create_fragment89.name
    });
  }
  get positioning() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioning(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowSize() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowSize(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableFocusTrap() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableFocusTrap(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnOutsideClick() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnOutsideClick(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventScroll() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScroll(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get portal() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portal(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onOpenChange() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onOpenChange(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openFocus() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openFocus(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeFocus() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeFocus(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Popover_default = Popover;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/popover/components/PopoverArrow.svelte
var file77 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/popover/components/PopoverArrow.svelte";
var get_default_slot_changes84 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context84 = (ctx) => ({ builder: (
  /*builder*/
  ctx[1]
) });
function create_else_block58(ctx) {
  let div;
  let builder_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file77, 15, 1, 305);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block58.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block77(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context84
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes84
            ),
            get_default_slot_context84
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block77.name,
    type: "if",
    source: "(13:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment90(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block77, create_else_block58];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment90.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance90($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $arrow;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PopoverArrow", slots, ["default"]);
  let { asChild = false } = $$props;
  let { size: size2 = 8 } = $$props;
  const { elements: { arrow: arrow2 } } = setArrow5(size2);
  validate_store(arrow2, "arrow");
  component_subscribe($$self, arrow2, (value) => $$invalidate(6, $arrow = value));
  const attrs = getAttrs13("arrow");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("size" in $$new_props) $$invalidate(5, size2 = $$new_props.size);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setArrow: setArrow5,
    getAttrs: getAttrs13,
    melt,
    asChild,
    size: size2,
    arrow: arrow2,
    attrs,
    builder: builder2,
    $arrow
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("size" in $$props) $$invalidate(5, size2 = $$new_props.size);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$arrow*/
    64) {
      $: $$invalidate(1, builder2 = $arrow);
    }
  };
  return [asChild, builder2, arrow2, attrs, $$restProps, size2, $arrow, $$scope, slots];
}
var PopoverArrow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance90, create_fragment90, safe_not_equal, { asChild: 0, size: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PopoverArrow",
      options,
      id: create_fragment90.name
    });
  }
  get asChild() {
    throw new Error("<PopoverArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<PopoverArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<PopoverArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PopoverArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PopoverArrow_default = PopoverArrow;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/popover/components/PopoverContent.svelte
var file78 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/popover/components/PopoverContent.svelte";
var get_default_slot_changes_512 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_512 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_412 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_412 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_312 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_312 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_212 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_212 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes_160 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_160 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
var get_default_slot_changes85 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context85 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[11]
  )
});
function create_if_block_514(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_512
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file78, 49, 1, 1394);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes_512
            ),
            get_default_slot_context_512
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12],
        /*attrs*/
        ctx2[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_514.name,
    type: "if",
    source: "(49:16) ",
    ctx
  });
  return block;
}
function create_if_block_414(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_412
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file78, 45, 1, 1233);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_412
            ),
            get_default_slot_context_412
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_414.name,
    type: "if",
    source: "(45:33) ",
    ctx
  });
  return block;
}
function create_if_block_314(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_312
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file78, 41, 1, 1058);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_312
            ),
            get_default_slot_context_312
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_314.name,
    type: "if",
    source: "(41:32) ",
    ctx
  });
  return block;
}
function create_if_block_214(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_212
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file78, 31, 1, 832);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_212
            ),
            get_default_slot_context_212
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_214.name,
    type: "if",
    source: "(31:49) ",
    ctx
  });
  return block;
}
function create_if_block_114(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_160
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[12],
    /*attrs*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file78, 27, 1, 637);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[7].action(div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_default_slot_changes_160
            ),
            get_default_slot_context_160
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12],
        /*attrs*/
        ctx[11]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(27:30) ",
    ctx
  });
  return block;
}
function create_if_block78(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context85
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes85
            ),
            get_default_slot_context85
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block78.name,
    type: "if",
    source: "(25:0) {#if asChild && $open}",
    ctx
  });
  return block;
}
function create_fragment91(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block78,
    create_if_block_114,
    create_if_block_214,
    create_if_block_314,
    create_if_block_414,
    create_if_block_514
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$open*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$open*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$open*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 4;
    if (
      /*$open*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment91.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance91($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $content;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PopoverContent", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { content }, states: { open }, ids } = getCtx12();
  validate_store(content, "content");
  component_subscribe($$self, content, (value) => $$invalidate(14, $content = value));
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  const attrs = getAttrs13("content");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(13, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx12,
    getAttrs: getAttrs13,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    content,
    open,
    ids,
    attrs,
    builder: builder2,
    $content,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(13, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    8192) {
      $: if (id) {
        ids.content.set(id);
      }
    }
    if ($$self.$$.dirty & /*$content*/
    16384) {
      $: $$invalidate(7, builder2 = $content);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $open,
    content,
    open,
    attrs,
    $$restProps,
    id,
    $content,
    $$scope,
    slots
  ];
}
var PopoverContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance91, create_fragment91, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6,
      id: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PopoverContent",
      options,
      id: create_fragment91.name
    });
  }
  get transition() {
    throw new Error("<PopoverContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<PopoverContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<PopoverContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<PopoverContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<PopoverContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<PopoverContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<PopoverContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<PopoverContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<PopoverContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<PopoverContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<PopoverContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<PopoverContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<PopoverContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<PopoverContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<PopoverContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<PopoverContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PopoverContent_default = PopoverContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/popover/components/PopoverTrigger.svelte
var file79 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/popover/components/PopoverTrigger.svelte";
var get_default_slot_changes_161 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_161 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes86 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context86 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block59(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_161
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file79, 22, 1, 466);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_161
            ),
            get_default_slot_context_161
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block59.name,
    type: "else",
    source: "(22:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block79(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context86
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes86
            ),
            get_default_slot_context86
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block79.name,
    type: "if",
    source: "(20:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment92(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block79, create_else_block59];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment92.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance92($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $trigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PopoverTrigger", slots, ["default"]);
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { trigger }, ids } = getCtx12();
  validate_store(trigger, "trigger");
  component_subscribe($$self, trigger, (value) => $$invalidate(7, $trigger = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs13("trigger");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(6, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx12,
    getAttrs: getAttrs13,
    createDispatcher,
    asChild,
    id,
    trigger,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $trigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(6, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    64) {
      $: if (id) {
        ids.trigger.set(id);
      }
    }
    if ($$self.$$.dirty & /*$trigger*/
    128) {
      $: $$invalidate(1, builder2 = $trigger);
    }
  };
  return [
    asChild,
    builder2,
    trigger,
    dispatch,
    attrs,
    $$restProps,
    id,
    $trigger,
    $$scope,
    slots
  ];
}
var PopoverTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance92, create_fragment92, safe_not_equal, { asChild: 0, id: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PopoverTrigger",
      options,
      id: create_fragment92.name
    });
  }
  get asChild() {
    throw new Error("<PopoverTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<PopoverTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<PopoverTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<PopoverTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PopoverTrigger_default = PopoverTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/popover/components/PopoverClose.svelte
var file80 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/popover/components/PopoverClose.svelte";
var get_default_slot_changes_162 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_162 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes87 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context87 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block60(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_162
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file80, 16, 1, 385);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_162
            ),
            get_default_slot_context_162
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block60.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block80(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context87
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes87
            ),
            get_default_slot_context87
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block80.name,
    type: "if",
    source: "(14:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment93(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block80, create_else_block60];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment93.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance93($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $close;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PopoverClose", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { close } } = getCtx12();
  validate_store(close, "close");
  component_subscribe($$self, close, (value) => $$invalidate(6, $close = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs13("close");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx12,
    getAttrs: getAttrs13,
    createDispatcher,
    asChild,
    close,
    dispatch,
    attrs,
    builder: builder2,
    $close
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$close*/
    64) {
      $: $$invalidate(1, builder2 = $close);
    }
  };
  return [asChild, builder2, close, dispatch, attrs, $$restProps, $close, $$scope, slots];
}
var PopoverClose = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance93, create_fragment93, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PopoverClose",
      options,
      id: create_fragment93.name
    });
  }
  get asChild() {
    throw new Error("<PopoverClose>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<PopoverClose>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PopoverClose_default = PopoverClose;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/progress/index.js
var progress_exports = {};
__export(progress_exports, {
  Progress: () => Progress_default,
  Root: () => Progress_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/progress/ctx.js
var NAME14 = "progress";
var PARTS13 = ["root"];
var getAttrs14 = createBitAttrs(NAME14, PARTS13);
function setCtx12(props) {
  const progress = createProgress(removeUndefined2(props));
  return {
    ...progress,
    updateOption: getOptionUpdater(progress.options)
  };
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/progress/components/Progress.svelte
var file81 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/progress/components/Progress.svelte";
var get_default_slot_changes_163 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_163 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes88 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context88 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block61(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context_163
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file81, 31, 1, 628);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes_163
            ),
            get_default_slot_context_163
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block61.name,
    type: "else",
    source: "(31:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block81(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context88
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes88
            ),
            get_default_slot_context88
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block81.name,
    type: "if",
    source: "(29:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment94(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block81, create_else_block61];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment94.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance94($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["max", "value", "onValueChange", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $root;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Progress", slots, ["default"]);
  let { max = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { onValueChange = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { root }, states: { value: localValue }, updateOption } = setCtx12({
    max,
    defaultValue: value,
    onValueChange: ({ next: next2 }) => {
      onValueChange == null ? void 0 : onValueChange(next2);
      $$invalidate(5, value = next2);
      return next2;
    }
  });
  validate_store(root, "root");
  component_subscribe($$self, root, (value2) => $$invalidate(8, $root = value2));
  const attrs = getAttrs14("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("max" in $$new_props) $$invalidate(6, max = $$new_props.max);
    if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$new_props) $$invalidate(7, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCtx: setCtx12,
    getAttrs: getAttrs14,
    max,
    value,
    onValueChange,
    asChild,
    root,
    localValue,
    updateOption,
    attrs,
    builder: builder2,
    $root
  });
  $$self.$inject_state = ($$new_props) => {
    if ("max" in $$props) $$invalidate(6, max = $$new_props.max);
    if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$props) $$invalidate(7, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    32) {
      $: value !== void 0 && localValue.set(value);
    }
    if ($$self.$$.dirty & /*max*/
    64) {
      $: updateOption("max", max);
    }
    if ($$self.$$.dirty & /*$root*/
    256) {
      $: $$invalidate(1, builder2 = $root);
    }
  };
  return [
    asChild,
    builder2,
    root,
    attrs,
    $$restProps,
    value,
    max,
    onValueChange,
    $root,
    $$scope,
    slots
  ];
}
var Progress = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance94, create_fragment94, safe_not_equal, {
      max: 6,
      value: 5,
      onValueChange: 7,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Progress",
      options,
      id: create_fragment94.name
    });
  }
  get max() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValueChange() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValueChange(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Progress_default = Progress;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/radio-group/index.js
var radio_group_exports = {};
__export(radio_group_exports, {
  Input: () => RadioGroupInput_default,
  Item: () => RadioGroupItem_default,
  ItemIndicator: () => RadioGroupItemIndicator_default,
  RadioGroup: () => RadioGroup_default,
  RadioGroupInput: () => RadioGroupInput_default,
  RadioGroupItem: () => RadioGroupItem_default,
  RadioGroupItemIndicator: () => RadioGroupItemIndicator_default,
  Root: () => RadioGroup_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/radio-group/ctx.js
var NAME15 = "radio-group";
var ITEM_NAME2 = "radio-group-item";
var PARTS14 = ["root", "item", "input"];
var getAttrs15 = createBitAttrs(NAME15, PARTS14);
function setCtx13(props) {
  const radioGroup = createRadioGroup(removeUndefined2(props));
  setContext(NAME15, radioGroup);
  return {
    ...radioGroup,
    updateOption: getOptionUpdater(radioGroup.options)
  };
}
function getCtx13() {
  return getContext(NAME15);
}
function setItemCtx(value) {
  const radioGroup = getCtx13();
  setContext(ITEM_NAME2, { value, isChecked: radioGroup.helpers.isChecked });
  return radioGroup;
}
function getRadioIndicator4() {
  return getContext(ITEM_NAME2);
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/radio-group/components/RadioGroup.svelte
var file82 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/radio-group/components/RadioGroup.svelte";
var get_default_slot_changes_164 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_164 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes89 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context89 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block62(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context_164
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file82, 45, 1, 929);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        4098)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes_164
            ),
            get_default_slot_context_164
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block62.name,
    type: "else",
    source: "(45:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block82(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context89
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        4098)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes89
            ),
            get_default_slot_context89
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block82.name,
    type: "if",
    source: "(43:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment95(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block82, create_else_block62];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment95.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance95($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["required", "disabled", "value", "onValueChange", "loop", "orientation", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $root;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioGroup", slots, ["default"]);
  let { required = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { onValueChange = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { orientation = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { root }, states: { value: localValue }, updateOption } = setCtx13({
    required,
    disabled,
    defaultValue: value,
    loop,
    orientation,
    onValueChange: ({ next: next2 }) => {
      if (value !== next2) {
        onValueChange == null ? void 0 : onValueChange(next2);
        $$invalidate(5, value = next2);
      }
      return next2;
    }
  });
  validate_store(root, "root");
  component_subscribe($$self, root, (value2) => $$invalidate(11, $root = value2));
  const attrs = getAttrs15("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("required" in $$new_props) $$invalidate(6, required = $$new_props.required);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$new_props) $$invalidate(8, onValueChange = $$new_props.onValueChange);
    if ("loop" in $$new_props) $$invalidate(9, loop = $$new_props.loop);
    if ("orientation" in $$new_props) $$invalidate(10, orientation = $$new_props.orientation);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCtx: setCtx13,
    getAttrs: getAttrs15,
    required,
    disabled,
    value,
    onValueChange,
    loop,
    orientation,
    asChild,
    root,
    localValue,
    updateOption,
    attrs,
    builder: builder2,
    $root
  });
  $$self.$inject_state = ($$new_props) => {
    if ("required" in $$props) $$invalidate(6, required = $$new_props.required);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$props) $$invalidate(8, onValueChange = $$new_props.onValueChange);
    if ("loop" in $$props) $$invalidate(9, loop = $$new_props.loop);
    if ("orientation" in $$props) $$invalidate(10, orientation = $$new_props.orientation);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    32) {
      $: value !== void 0 && localValue.set(value);
    }
    if ($$self.$$.dirty & /*required*/
    64) {
      $: updateOption("required", required);
    }
    if ($$self.$$.dirty & /*disabled*/
    128) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*loop*/
    512) {
      $: updateOption("loop", loop);
    }
    if ($$self.$$.dirty & /*orientation*/
    1024) {
      $: updateOption("orientation", orientation);
    }
    if ($$self.$$.dirty & /*$root*/
    2048) {
      $: $$invalidate(1, builder2 = $root);
    }
  };
  return [
    asChild,
    builder2,
    root,
    attrs,
    $$restProps,
    value,
    required,
    disabled,
    onValueChange,
    loop,
    orientation,
    $root,
    $$scope,
    slots
  ];
}
var RadioGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance95, create_fragment95, safe_not_equal, {
      required: 6,
      disabled: 7,
      value: 5,
      onValueChange: 8,
      loop: 9,
      orientation: 10,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioGroup",
      options,
      id: create_fragment95.name
    });
  }
  get required() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValueChange() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValueChange(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioGroup_default = RadioGroup;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/radio-group/components/RadioGroupInput.svelte
var file83 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/radio-group/components/RadioGroupInput.svelte";
var get_default_slot_changes90 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context90 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block63(ctx) {
  let input;
  let builder_action_action;
  let mounted;
  let dispose;
  let input_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {});
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file83, 14, 1, 296);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus) input.focus();
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(input));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block63.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block83(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context90
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes90
            ),
            get_default_slot_context90
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block83.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment96(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block83, create_else_block63];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment96.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance96($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $hiddenInput;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioGroupInput", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { hiddenInput } } = getCtx13();
  validate_store(hiddenInput, "hiddenInput");
  component_subscribe($$self, hiddenInput, (value) => $$invalidate(5, $hiddenInput = value));
  const attrs = getAttrs15("input");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx13,
    getAttrs: getAttrs15,
    asChild,
    hiddenInput,
    attrs,
    builder: builder2,
    $hiddenInput
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$hiddenInput*/
    32) {
      $: $$invalidate(1, builder2 = $hiddenInput);
    }
  };
  return [
    asChild,
    builder2,
    hiddenInput,
    attrs,
    $$restProps,
    $hiddenInput,
    $$scope,
    slots
  ];
}
var RadioGroupInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance96, create_fragment96, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioGroupInput",
      options,
      id: create_fragment96.name
    });
  }
  get asChild() {
    throw new Error("<RadioGroupInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<RadioGroupInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioGroupInput_default = RadioGroupInput;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/radio-group/components/RadioGroupItem.svelte
var file84 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/radio-group/components/RadioGroupItem.svelte";
var get_default_slot_changes_165 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_165 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes91 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context91 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block64(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context_165
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file84, 18, 1, 463);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-focus",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes_165
            ),
            get_default_slot_context_165
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block64.name,
    type: "else",
    source: "(18:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block84(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context91
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes91
            ),
            get_default_slot_context91
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block84.name,
    type: "if",
    source: "(16:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment97(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block84, create_else_block64];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment97.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance97($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["value", "disabled", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $item;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioGroupItem", slots, ["default"]);
  let { value } = $$props;
  let { disabled = false } = $$props;
  let { asChild = false } = $$props;
  const { elements: { item } } = setItemCtx(value);
  validate_store(item, "item");
  component_subscribe($$self, item, (value2) => $$invalidate(8, $item = value2));
  const dispatch = createDispatcher();
  const attrs = getAttrs15("item");
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<RadioGroupItem> was created without expected prop 'value'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setItemCtx,
    getAttrs: getAttrs15,
    createDispatcher,
    value,
    disabled,
    asChild,
    item,
    dispatch,
    attrs,
    builder: builder2,
    $item
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$item, value, disabled*/
    448) {
      $: $$invalidate(1, builder2 = $item({ value, disabled }));
    }
  };
  return [
    asChild,
    builder2,
    item,
    dispatch,
    attrs,
    $$restProps,
    value,
    disabled,
    $item,
    $$scope,
    slots
  ];
}
var RadioGroupItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance97, create_fragment97, safe_not_equal, { value: 6, disabled: 7, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioGroupItem",
      options,
      id: create_fragment97.name
    });
  }
  get value() {
    throw new Error("<RadioGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<RadioGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<RadioGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioGroupItem_default = RadioGroupItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/radio-group/components/RadioGroupItemIndicator.svelte
function create_if_block85(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block85.name,
    type: "if",
    source: "(5:0) {#if $isChecked(value)}",
    ctx
  });
  return block;
}
function create_fragment98(ctx) {
  let show_if = (
    /*$isChecked*/
    ctx[0](
      /*value*/
      ctx[2]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block85(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$isChecked*/
      1) show_if = /*$isChecked*/
      ctx2[0](
        /*value*/
        ctx2[2]
      );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$isChecked*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block85(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment98.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance98($$self, $$props, $$invalidate) {
  let $isChecked;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioGroupItemIndicator", slots, ["default"]);
  const { isChecked, value } = getRadioIndicator4();
  validate_store(isChecked, "isChecked");
  component_subscribe($$self, isChecked, (value2) => $$invalidate(0, $isChecked = value2));
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<RadioGroupItemIndicator> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getRadioIndicator: getRadioIndicator4,
    isChecked,
    value,
    $isChecked
  });
  return [$isChecked, isChecked, value, $$scope, slots];
}
var RadioGroupItemIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance98, create_fragment98, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioGroupItemIndicator",
      options,
      id: create_fragment98.name
    });
  }
};
var RadioGroupItemIndicator_default = RadioGroupItemIndicator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/index.js
var select_exports = {};
__export(select_exports, {
  Arrow: () => SelectArrow_default,
  Content: () => SelectContent_default,
  Group: () => SelectGroup_default,
  Input: () => SelectInput_default,
  Item: () => SelectItem_default,
  ItemIndicator: () => SelectItemIndicator_default,
  Label: () => SelectLabel_default,
  Root: () => Select_default,
  Select: () => Select_default,
  SelectArrow: () => SelectArrow_default,
  SelectContent: () => SelectContent_default,
  SelectGroup: () => SelectGroup_default,
  SelectInput: () => SelectInput_default,
  SelectItem: () => SelectItem_default,
  SelectItemIndicator: () => SelectItemIndicator_default,
  SelectLabel: () => SelectLabel_default,
  SelectSeparator: () => Separator_default,
  SelectTrigger: () => SelectTrigger_default,
  SelectValue: () => SelectValue_default,
  Separator: () => Separator_default,
  Trigger: () => SelectTrigger_default,
  Value: () => SelectValue_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/ctx.js
var NAME16 = "select";
var GROUP_NAME5 = "select-group";
var ITEM_NAME3 = "select-item";
var PARTS15 = ["arrow", "content", "group", "item", "input", "label", "trigger", "value"];
var getAttrs16 = createBitAttrs(NAME16, PARTS15);
function getCtx14() {
  return getContext(NAME16);
}
function setCtx14(props) {
  const select = createSelect(removeUndefined2(props));
  setContext(NAME16, select);
  return {
    ...select,
    updateOption: getOptionUpdater(select.options)
  };
}
function setGroupCtx3() {
  const id = generateId3();
  setContext(GROUP_NAME5, id);
  const { elements: { group } } = getCtx14();
  return { group, id };
}
function setItemCtx2(value) {
  const select = getCtx14();
  setContext(ITEM_NAME3, value);
  return select;
}
function getGroupLabel4() {
  const id = getContext(GROUP_NAME5);
  const { elements: { groupLabel } } = getCtx14();
  return { groupLabel, id };
}
function getItemIndicator() {
  const { helpers: { isSelected } } = getCtx14();
  const value = getContext(ITEM_NAME3);
  return {
    value,
    isSelected
  };
}
function setArrow6(size2 = 8) {
  var _a;
  const select = getCtx14();
  (_a = select.options.arrowSize) == null ? void 0 : _a.set(size2);
  return select;
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/Select.svelte
var get_default_slot_changes92 = (dirty) => ({ ids: dirty & /*$idValues*/
1 });
var get_default_slot_context92 = (ctx) => ({ ids: (
  /*$idValues*/
  ctx[0]
) });
function create_fragment99(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context92
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $idValues*/
        262145)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes92
            ),
            get_default_slot_context92
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment99.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance99($$self, $$props, $$invalidate) {
  let $idValues;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, ["default"]);
  let { required = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { arrowSize = void 0 } = $$props;
  let { preventScroll = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { closeOnOutsideClick = void 0 } = $$props;
  let { portal = void 0 } = $$props;
  let { positioning = void 0 } = $$props;
  let { name: name27 = void 0 } = $$props;
  let { multiple = void 0 } = $$props;
  let { selected = void 0 } = $$props;
  let { onSelectedChange = void 0 } = $$props;
  let { open = void 0 } = $$props;
  let { onOpenChange = void 0 } = $$props;
  let { forceVisible = true } = $$props;
  const { states: { open: localOpen, selected: localSelected }, updateOption, ids } = setCtx14({
    required,
    disabled,
    arrowSize,
    preventScroll,
    loop,
    closeOnEscape,
    closeOnOutsideClick,
    portal,
    positioning,
    name: name27,
    multiple,
    forceVisible,
    defaultSelected: selected,
    defaultOpen: open,
    onSelectedChange: ({ next: next2 }) => {
      if (selected !== next2) {
        onSelectedChange == null ? void 0 : onSelectedChange(next2);
        $$invalidate(2, selected = next2);
      }
      return next2;
    },
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange == null ? void 0 : onOpenChange(next2);
        $$invalidate(3, open = next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.menu, ids.trigger, ids.label], ([$menuId, $triggerId, $labelId]) => ({
    menu: $menuId,
    trigger: $triggerId,
    label: $labelId
  }));
  validate_store(idValues, "idValues");
  component_subscribe($$self, idValues, (value) => $$invalidate(0, $idValues = value));
  const writable_props = [
    "required",
    "disabled",
    "arrowSize",
    "preventScroll",
    "loop",
    "closeOnEscape",
    "closeOnOutsideClick",
    "portal",
    "positioning",
    "name",
    "multiple",
    "selected",
    "onSelectedChange",
    "open",
    "onOpenChange",
    "forceVisible"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Select> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("required" in $$props2) $$invalidate(4, required = $$props2.required);
    if ("disabled" in $$props2) $$invalidate(5, disabled = $$props2.disabled);
    if ("arrowSize" in $$props2) $$invalidate(6, arrowSize = $$props2.arrowSize);
    if ("preventScroll" in $$props2) $$invalidate(7, preventScroll = $$props2.preventScroll);
    if ("loop" in $$props2) $$invalidate(8, loop = $$props2.loop);
    if ("closeOnEscape" in $$props2) $$invalidate(9, closeOnEscape = $$props2.closeOnEscape);
    if ("closeOnOutsideClick" in $$props2) $$invalidate(10, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("portal" in $$props2) $$invalidate(11, portal = $$props2.portal);
    if ("positioning" in $$props2) $$invalidate(12, positioning = $$props2.positioning);
    if ("name" in $$props2) $$invalidate(13, name27 = $$props2.name);
    if ("multiple" in $$props2) $$invalidate(14, multiple = $$props2.multiple);
    if ("selected" in $$props2) $$invalidate(2, selected = $$props2.selected);
    if ("onSelectedChange" in $$props2) $$invalidate(15, onSelectedChange = $$props2.onSelectedChange);
    if ("open" in $$props2) $$invalidate(3, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(16, onOpenChange = $$props2.onOpenChange);
    if ("forceVisible" in $$props2) $$invalidate(17, forceVisible = $$props2.forceVisible);
    if ("$$scope" in $$props2) $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    derived,
    setCtx: setCtx14,
    required,
    disabled,
    arrowSize,
    preventScroll,
    loop,
    closeOnEscape,
    closeOnOutsideClick,
    portal,
    positioning,
    name: name27,
    multiple,
    selected,
    onSelectedChange,
    open,
    onOpenChange,
    forceVisible,
    localOpen,
    localSelected,
    updateOption,
    ids,
    idValues,
    $idValues
  });
  $$self.$inject_state = ($$props2) => {
    if ("required" in $$props2) $$invalidate(4, required = $$props2.required);
    if ("disabled" in $$props2) $$invalidate(5, disabled = $$props2.disabled);
    if ("arrowSize" in $$props2) $$invalidate(6, arrowSize = $$props2.arrowSize);
    if ("preventScroll" in $$props2) $$invalidate(7, preventScroll = $$props2.preventScroll);
    if ("loop" in $$props2) $$invalidate(8, loop = $$props2.loop);
    if ("closeOnEscape" in $$props2) $$invalidate(9, closeOnEscape = $$props2.closeOnEscape);
    if ("closeOnOutsideClick" in $$props2) $$invalidate(10, closeOnOutsideClick = $$props2.closeOnOutsideClick);
    if ("portal" in $$props2) $$invalidate(11, portal = $$props2.portal);
    if ("positioning" in $$props2) $$invalidate(12, positioning = $$props2.positioning);
    if ("name" in $$props2) $$invalidate(13, name27 = $$props2.name);
    if ("multiple" in $$props2) $$invalidate(14, multiple = $$props2.multiple);
    if ("selected" in $$props2) $$invalidate(2, selected = $$props2.selected);
    if ("onSelectedChange" in $$props2) $$invalidate(15, onSelectedChange = $$props2.onSelectedChange);
    if ("open" in $$props2) $$invalidate(3, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(16, onOpenChange = $$props2.onOpenChange);
    if ("forceVisible" in $$props2) $$invalidate(17, forceVisible = $$props2.forceVisible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    8) {
      $: open !== void 0 && localOpen.set(open);
    }
    if ($$self.$$.dirty & /*selected*/
    4) {
      $: selected !== void 0 && localSelected.set(selected);
    }
    if ($$self.$$.dirty & /*required*/
    16) {
      $: updateOption("required", required);
    }
    if ($$self.$$.dirty & /*disabled*/
    32) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*arrowSize*/
    64) {
      $: updateOption("arrowSize", arrowSize);
    }
    if ($$self.$$.dirty & /*preventScroll*/
    128) {
      $: updateOption("preventScroll", preventScroll);
    }
    if ($$self.$$.dirty & /*loop*/
    256) {
      $: updateOption("loop", loop);
    }
    if ($$self.$$.dirty & /*closeOnEscape*/
    512) {
      $: updateOption("closeOnEscape", closeOnEscape);
    }
    if ($$self.$$.dirty & /*closeOnOutsideClick*/
    1024) {
      $: updateOption("closeOnOutsideClick", closeOnOutsideClick);
    }
    if ($$self.$$.dirty & /*portal*/
    2048) {
      $: updateOption("portal", portal);
    }
    if ($$self.$$.dirty & /*positioning*/
    4096) {
      $: updateOption("positioning", positioning);
    }
    if ($$self.$$.dirty & /*name*/
    8192) {
      $: updateOption("name", name27);
    }
    if ($$self.$$.dirty & /*multiple*/
    16384) {
      $: updateOption("multiple", multiple);
    }
    if ($$self.$$.dirty & /*forceVisible*/
    131072) {
      $: updateOption("forceVisible", forceVisible);
    }
  };
  return [
    $idValues,
    idValues,
    selected,
    open,
    required,
    disabled,
    arrowSize,
    preventScroll,
    loop,
    closeOnEscape,
    closeOnOutsideClick,
    portal,
    positioning,
    name27,
    multiple,
    onSelectedChange,
    onOpenChange,
    forceVisible,
    $$scope,
    slots
  ];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance99, create_fragment99, safe_not_equal, {
      required: 4,
      disabled: 5,
      arrowSize: 6,
      preventScroll: 7,
      loop: 8,
      closeOnEscape: 9,
      closeOnOutsideClick: 10,
      portal: 11,
      positioning: 12,
      name: 13,
      multiple: 14,
      selected: 2,
      onSelectedChange: 15,
      open: 3,
      onOpenChange: 16,
      forceVisible: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment99.name
    });
  }
  get required() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowSize() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowSize(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventScroll() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScroll(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnOutsideClick() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnOutsideClick(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get portal() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portal(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positioning() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioning(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelectedChange() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelectedChange(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onOpenChange() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onOpenChange(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forceVisible() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forceVisible(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectArrow.svelte
var file85 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectArrow.svelte";
var get_default_slot_changes93 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context93 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block65(ctx) {
  let div;
  let builder_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file85, 15, 1, 313);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block65.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block86(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context93
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes93
            ),
            get_default_slot_context93
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block86.name,
    type: "if",
    source: "(13:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment100(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block86, create_else_block65];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment100.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance100($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $arrow;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectArrow", slots, ["default"]);
  let { asChild = false } = $$props;
  let { size: size2 = 8 } = $$props;
  const { elements: { arrow: arrow2 } } = setArrow6(size2);
  validate_store(arrow2, "arrow");
  component_subscribe($$self, arrow2, (value) => $$invalidate(6, $arrow = value));
  const attrs = getAttrs16("arrow");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("size" in $$new_props) $$invalidate(5, size2 = $$new_props.size);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setArrow: setArrow6,
    getAttrs: getAttrs16,
    asChild,
    size: size2,
    arrow: arrow2,
    attrs,
    builder: builder2,
    $arrow
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("size" in $$props) $$invalidate(5, size2 = $$new_props.size);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$arrow*/
    64) {
      $: $$invalidate(1, builder2 = $arrow);
    }
  };
  return [asChild, builder2, arrow2, attrs, $$restProps, size2, $arrow, $$scope, slots];
}
var SelectArrow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance100, create_fragment100, safe_not_equal, { asChild: 0, size: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectArrow",
      options,
      id: create_fragment100.name
    });
  }
  get asChild() {
    throw new Error("<SelectArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<SelectArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<SelectArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SelectArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectArrow_default = SelectArrow;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectContent.svelte
var file86 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectContent.svelte";
var get_default_slot_changes_513 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_513 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_413 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_413 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_313 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_313 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_213 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_213 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_166 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_166 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes94 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context94 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
function create_if_block_515(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_513
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file86, 76, 1, 1779);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown_handler_4*/
            ctx[22],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes_513
            ),
            get_default_slot_context_513
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13],
        /*attrs*/
        ctx2[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_515.name,
    type: "if",
    source: "(76:16) ",
    ctx
  });
  return block;
}
function create_if_block_415(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_413
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file86, 65, 1, 1564);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown_handler_3*/
            ctx[21],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_413
            ),
            get_default_slot_context_413
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_415.name,
    type: "if",
    source: "(65:33) ",
    ctx
  });
  return block;
}
function create_if_block_315(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_313
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file86, 54, 1, 1335);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown_handler_2*/
            ctx[20],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_313
            ),
            get_default_slot_context_313
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_315.name,
    type: "if",
    source: "(54:32) ",
    ctx
  });
  return block;
}
function create_if_block_215(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_213
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file86, 42, 1, 1065);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown_handler_1*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_213
            ),
            get_default_slot_context_213
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_215.name,
    type: "if",
    source: "(42:49) ",
    ctx
  });
  return block;
}
function create_if_block_115(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context_166
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file86, 31, 1, 816);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-pointerleave",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              get_default_slot_changes_166
            ),
            get_default_slot_context_166
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(31:30) ",
    ctx
  });
  return block;
}
function create_if_block87(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context94
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        65664)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes94
            ),
            get_default_slot_context94
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block87.name,
    type: "if",
    source: "(29:0) {#if asChild && $open}",
    ctx
  });
  return block;
}
function create_fragment101(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block87,
    create_if_block_115,
    create_if_block_215,
    create_if_block_315,
    create_if_block_415,
    create_if_block_515
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$open*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$open*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$open*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 4;
    if (
      /*$open*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment101.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance101($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $menu;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectContent", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { menu }, states: { open }, ids } = getCtx14();
  validate_store(menu, "menu");
  component_subscribe($$self, menu, (value) => $$invalidate(15, $menu = value));
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs16("content");
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(14, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createDispatcher,
    melt,
    getCtx: getCtx14,
    getAttrs: getAttrs16,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    menu,
    open,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $menu,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(14, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$menu*/
    32768) {
      $: $$invalidate(7, builder2 = $menu);
    }
    if ($$self.$$.dirty & /*id*/
    16384) {
      $: if (id) {
        ids.menu.set(id);
      }
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $open,
    menu,
    open,
    dispatch,
    attrs,
    $$restProps,
    id,
    $menu,
    $$scope,
    slots,
    keydown_handler,
    keydown_handler_1,
    keydown_handler_2,
    keydown_handler_3,
    keydown_handler_4
  ];
}
var SelectContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance101, create_fragment101, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6,
      id: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectContent",
      options,
      id: create_fragment101.name
    });
  }
  get transition() {
    throw new Error("<SelectContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<SelectContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<SelectContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<SelectContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<SelectContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<SelectContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<SelectContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<SelectContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<SelectContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<SelectContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<SelectContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<SelectContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<SelectContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<SelectContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<SelectContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SelectContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectContent_default = SelectContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectGroup.svelte
var file87 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectGroup.svelte";
var get_default_slot_changes_167 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_167 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes95 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context95 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block66(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context_167
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file87, 12, 1, 286);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes_167
            ),
            get_default_slot_context_167
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block66.name,
    type: "else",
    source: "(12:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block88(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context95
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes95
            ),
            get_default_slot_context95
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block88.name,
    type: "if",
    source: "(10:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment102(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block88, create_else_block66];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment102.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance102($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $group;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectGroup", slots, ["default"]);
  let { asChild = false } = $$props;
  const { group, id } = setGroupCtx3();
  validate_store(group, "group");
  component_subscribe($$self, group, (value) => $$invalidate(5, $group = value));
  const attrs = getAttrs16("group");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setGroupCtx: setGroupCtx3,
    getAttrs: getAttrs16,
    asChild,
    group,
    id,
    attrs,
    builder: builder2,
    $group
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$group*/
    32) {
      $: $$invalidate(1, builder2 = $group(id));
    }
  };
  return [asChild, builder2, group, attrs, $$restProps, $group, $$scope, slots];
}
var SelectGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance102, create_fragment102, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectGroup",
      options,
      id: create_fragment102.name
    });
  }
  get asChild() {
    throw new Error("<SelectGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<SelectGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectGroup_default = SelectGroup;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectInput.svelte
var file88 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectInput.svelte";
var get_default_slot_changes96 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context96 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[5]
  )
});
function create_else_block67(ctx) {
  let input;
  let input_disabled_value;
  let builder_action_action;
  let mounted;
  let dispose;
  let input_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[6],
    /*attrs*/
    ctx[5],
    {
      disabled: input_disabled_value = /*$disabled*/
      ctx[2] ? true : void 0
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {});
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file88, 15, 1, 321);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus) input.focus();
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(input));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        /*attrs*/
        ctx2[5],
        dirty & /*$disabled*/
        4 && input_disabled_value !== (input_disabled_value = /*$disabled*/
        ctx2[2] ? true : void 0) && { disabled: input_disabled_value }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block67.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block89(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context96
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes96
            ),
            get_default_slot_context96
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block89.name,
    type: "if",
    source: "(13:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment103(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block89, create_else_block67];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment103.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance103($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $hiddenInput;
  let $disabled;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectInput", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { hiddenInput }, options: { disabled } } = getCtx14();
  validate_store(hiddenInput, "hiddenInput");
  component_subscribe($$self, hiddenInput, (value) => $$invalidate(7, $hiddenInput = value));
  validate_store(disabled, "disabled");
  component_subscribe($$self, disabled, (value) => $$invalidate(2, $disabled = value));
  const attrs = getAttrs16("input");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx14,
    getAttrs: getAttrs16,
    asChild,
    hiddenInput,
    disabled,
    attrs,
    builder: builder2,
    $hiddenInput,
    $disabled
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$hiddenInput*/
    128) {
      $: $$invalidate(1, builder2 = $hiddenInput);
    }
  };
  return [
    asChild,
    builder2,
    $disabled,
    hiddenInput,
    disabled,
    attrs,
    $$restProps,
    $hiddenInput,
    $$scope,
    slots
  ];
}
var SelectInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance103, create_fragment103, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectInput",
      options,
      id: create_fragment103.name
    });
  }
  get asChild() {
    throw new Error("<SelectInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<SelectInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectInput_default = SelectInput;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectItem.svelte
var file89 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectItem.svelte";
var get_default_slot_changes_168 = (dirty) => ({ builder: dirty & /*builder*/
8 });
var get_default_slot_context_168 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[3]
  ),
  attrs: (
    /*attrs*/
    ctx[6]
  )
});
var get_default_slot_changes97 = (dirty) => ({ builder: dirty & /*builder*/
8 });
var get_default_slot_context97 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[3]
  ),
  attrs: (
    /*attrs*/
    ctx[6]
  )
});
function create_else_block68(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context_168
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  let div_levels = [
    /*builder*/
    ctx[3],
    /*$$restProps*/
    ctx[7],
    /*attrs*/
    ctx[6]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot_or_fallback) default_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file89, 21, 1, 593);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[3].action(div)),
          listen_dev(
            div,
            "m-click",
            /*dispatch*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointermove",
            /*dispatch*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "focusin",
            /*focusin_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "focusout",
            /*focusout_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointerleave",
            /*pointerleave_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1032)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes_168
            ),
            get_default_slot_context_168
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*label, value*/
        3)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        8 && /*builder*/
        ctx2[3],
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7],
        /*attrs*/
        ctx2[6]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block68.name,
    type: "else",
    source: "(21:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block90(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context97
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1032)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes97
            ),
            get_default_slot_context97
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block90.name,
    type: "if",
    source: "(19:0) {#if asChild}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t_value = (
    /*label*/
    (ctx[1] ? (
      /*label*/
      ctx[1]
    ) : (
      /*value*/
      ctx[0]
    )) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label, value*/
      3 && t_value !== (t_value = /*label*/
      (ctx2[1] ? (
        /*label*/
        ctx2[1]
      ) : (
        /*value*/
        ctx2[0]
      )) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(33:26)     ",
    ctx
  });
  return block;
}
function create_fragment104(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block90, create_else_block68];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[2]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment104.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance104($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["value", "disabled", "label", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $item;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectItem", slots, ["default"]);
  let { value } = $$props;
  let { disabled = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { option: item } } = setItemCtx2(value);
  validate_store(item, "item");
  component_subscribe($$self, item, (value2) => $$invalidate(9, $item = value2));
  const dispatch = createDispatcher();
  const attrs = getAttrs16("item");
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<SelectItem> was created without expected prop 'value'");
    }
  });
  function focusin_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focusout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("disabled" in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("label" in $$new_props) $$invalidate(1, label = $$new_props.label);
    if ("asChild" in $$new_props) $$invalidate(2, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setItemCtx: setItemCtx2,
    getAttrs: getAttrs16,
    createDispatcher,
    value,
    disabled,
    label,
    asChild,
    item,
    dispatch,
    attrs,
    builder: builder2,
    $item
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    if ("disabled" in $$props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("label" in $$props) $$invalidate(1, label = $$new_props.label);
    if ("asChild" in $$props) $$invalidate(2, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(3, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$item, value, disabled, label*/
    771) {
      $: $$invalidate(3, builder2 = $item({ value, disabled, label }));
    }
  };
  return [
    value,
    label,
    asChild,
    builder2,
    item,
    dispatch,
    attrs,
    $$restProps,
    disabled,
    $item,
    $$scope,
    slots,
    focusin_handler,
    keydown_handler,
    focusout_handler,
    pointerleave_handler
  ];
}
var SelectItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance104, create_fragment104, safe_not_equal, {
      value: 0,
      disabled: 8,
      label: 1,
      asChild: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectItem",
      options,
      id: create_fragment104.name
    });
  }
  get value() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectItem_default = SelectItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectItemIndicator.svelte
function create_if_block91(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block91.name,
    type: "if",
    source: "(5:0) {#if $isSelected(value)}",
    ctx
  });
  return block;
}
function create_fragment105(ctx) {
  let show_if = (
    /*$isSelected*/
    ctx[0](
      /*value*/
      ctx[2]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block91(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$isSelected*/
      1) show_if = /*$isSelected*/
      ctx2[0](
        /*value*/
        ctx2[2]
      );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$isSelected*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block91(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment105.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance105($$self, $$props, $$invalidate) {
  let $isSelected;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectItemIndicator", slots, ["default"]);
  const { isSelected, value } = getItemIndicator();
  validate_store(isSelected, "isSelected");
  component_subscribe($$self, isSelected, (value2) => $$invalidate(0, $isSelected = value2));
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<SelectItemIndicator> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getItemIndicator,
    isSelected,
    value,
    $isSelected
  });
  return [$isSelected, isSelected, value, $$scope, slots];
}
var SelectItemIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance105, create_fragment105, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectItemIndicator",
      options,
      id: create_fragment105.name
    });
  }
};
var SelectItemIndicator_default = SelectItemIndicator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectLabel.svelte
var file90 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectLabel.svelte";
var get_default_slot_changes_169 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_169 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes98 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context98 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block69(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_169
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file90, 18, 1, 414);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_169
            ),
            get_default_slot_context_169
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block69.name,
    type: "else",
    source: "(18:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block92(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context98
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes98
            ),
            get_default_slot_context98
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block92.name,
    type: "if",
    source: "(16:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment106(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block92, create_else_block69];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment106.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance106($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $groupLabel;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectLabel", slots, ["default"]);
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { ids } = getCtx14();
  const { groupLabel, id: groupId } = getGroupLabel4();
  validate_store(groupLabel, "groupLabel");
  component_subscribe($$self, groupLabel, (value) => $$invalidate(6, $groupLabel = value));
  const attrs = getAttrs16("label");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getGroupLabel: getGroupLabel4,
    getAttrs: getAttrs16,
    getCtx: getCtx14,
    asChild,
    id,
    ids,
    groupLabel,
    groupId,
    attrs,
    builder: builder2,
    $groupLabel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    32) {
      $: if (id) {
        ids.label.set(id);
      }
    }
    if ($$self.$$.dirty & /*$groupLabel*/
    64) {
      $: $$invalidate(1, builder2 = $groupLabel(groupId));
    }
  };
  return [
    asChild,
    builder2,
    groupLabel,
    attrs,
    $$restProps,
    id,
    $groupLabel,
    $$scope,
    slots
  ];
}
var SelectLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance106, create_fragment106, safe_not_equal, { asChild: 0, id: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectLabel",
      options,
      id: create_fragment106.name
    });
  }
  get asChild() {
    throw new Error("<SelectLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<SelectLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<SelectLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SelectLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectLabel_default = SelectLabel;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/separator/ctx.js
var NAME17 = "separator";
var PARTS16 = ["root"];
var getAttrs17 = createBitAttrs(NAME17, PARTS16);
function setCtx15(props) {
  const separator = createSeparator(removeUndefined2(props));
  return {
    ...separator,
    updateOption: getOptionUpdater(separator.options)
  };
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/separator/components/Separator.svelte
var file91 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/separator/components/Separator.svelte";
var get_default_slot_changes99 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context99 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block70(ctx) {
  let div;
  let builder_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file91, 21, 1, 485);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block70.name,
    type: "else",
    source: "(21:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block93(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context99
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes99
            ),
            get_default_slot_context99
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block93.name,
    type: "if",
    source: "(19:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment107(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block93, create_else_block70];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment107.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance107($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["orientation", "decorative", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $root;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Separator", slots, ["default"]);
  let { orientation = "horizontal" } = $$props;
  let { decorative = true } = $$props;
  let { asChild = false } = $$props;
  const { elements: { root }, updateOption } = setCtx15({ orientation, decorative });
  validate_store(root, "root");
  component_subscribe($$self, root, (value) => $$invalidate(7, $root = value));
  const attrs = getAttrs17("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("orientation" in $$new_props) $$invalidate(5, orientation = $$new_props.orientation);
    if ("decorative" in $$new_props) $$invalidate(6, decorative = $$new_props.decorative);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCtx: setCtx15,
    getAttrs: getAttrs17,
    orientation,
    decorative,
    asChild,
    root,
    updateOption,
    attrs,
    builder: builder2,
    $root
  });
  $$self.$inject_state = ($$new_props) => {
    if ("orientation" in $$props) $$invalidate(5, orientation = $$new_props.orientation);
    if ("decorative" in $$props) $$invalidate(6, decorative = $$new_props.decorative);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*orientation*/
    32) {
      $: updateOption("orientation", orientation);
    }
    if ($$self.$$.dirty & /*decorative*/
    64) {
      $: updateOption("decorative", decorative);
    }
    if ($$self.$$.dirty & /*$root*/
    128) {
      $: $$invalidate(1, builder2 = $root);
    }
  };
  return [
    asChild,
    builder2,
    root,
    attrs,
    $$restProps,
    orientation,
    decorative,
    $root,
    $$scope,
    slots
  ];
}
var Separator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance107, create_fragment107, safe_not_equal, {
      orientation: 5,
      decorative: 6,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Separator",
      options,
      id: create_fragment107.name
    });
  }
  get orientation() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decorative() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorative(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Separator_default = Separator;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectTrigger.svelte
var file92 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectTrigger.svelte";
var get_default_slot_changes_170 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_170 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes100 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context100 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block71(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_170
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file92, 22, 1, 466);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_170
            ),
            get_default_slot_context_170
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block71.name,
    type: "else",
    source: "(22:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block94(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context100
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes100
            ),
            get_default_slot_context100
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block94.name,
    type: "if",
    source: "(20:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment108(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block94, create_else_block71];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment108.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance108($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $trigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectTrigger", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { trigger }, ids } = getCtx14();
  validate_store(trigger, "trigger");
  component_subscribe($$self, trigger, (value) => $$invalidate(7, $trigger = value));
  let { id = void 0 } = $$props;
  const dispatch = createDispatcher();
  const attrs = getAttrs16("trigger");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(6, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx14,
    getAttrs: getAttrs16,
    createDispatcher,
    asChild,
    trigger,
    ids,
    id,
    dispatch,
    attrs,
    builder: builder2,
    $trigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(6, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    64) {
      $: if (id) {
        ids.trigger.set(id);
      }
    }
    if ($$self.$$.dirty & /*$trigger*/
    128) {
      $: $$invalidate(1, builder2 = $trigger);
    }
  };
  return [
    asChild,
    builder2,
    trigger,
    dispatch,
    attrs,
    $$restProps,
    id,
    $trigger,
    $$scope,
    slots
  ];
}
var SelectTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance108, create_fragment108, safe_not_equal, { asChild: 0, id: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectTrigger",
      options,
      id: create_fragment108.name
    });
  }
  get asChild() {
    throw new Error("<SelectTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<SelectTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<SelectTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SelectTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectTrigger_default = SelectTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectValue.svelte
var file93 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/select/components/SelectValue.svelte";
var get_default_slot_changes101 = (dirty) => ({ label: dirty & /*label*/
4 });
var get_default_slot_context101 = (ctx) => ({
  label: (
    /*label*/
    ctx[2]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block72(ctx) {
  let span;
  let t_value = (
    /*label*/
    (ctx[2] ? (
      /*label*/
      ctx[2]
    ) : (
      /*placeholder*/
      ctx[0]
    )) + ""
  );
  let t;
  let span_levels = [
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file93, 14, 1, 283);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label, placeholder*/
      5 && t_value !== (t_value = /*label*/
      (ctx2[2] ? (
        /*label*/
        ctx2[2]
      ) : (
        /*placeholder*/
        ctx2[0]
      )) + "")) set_data_maybe_contenteditable_dev(t, t_value, span_data["contenteditable"]);
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block72.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block95(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context101
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, label*/
        132)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes101
            ),
            get_default_slot_context101
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block95.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment109(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block95, create_else_block72];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment109.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance109($$self, $$props, $$invalidate) {
  let label;
  const omit_props_names = ["placeholder", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedLabel;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectValue", slots, ["default"]);
  let { placeholder = "" } = $$props;
  let { asChild = false } = $$props;
  const { states: { selectedLabel } } = getCtx14();
  validate_store(selectedLabel, "selectedLabel");
  component_subscribe($$self, selectedLabel, (value) => $$invalidate(6, $selectedLabel = value));
  const attrs = getAttrs16("value");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("placeholder" in $$new_props) $$invalidate(0, placeholder = $$new_props.placeholder);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getCtx: getCtx14,
    getAttrs: getAttrs16,
    placeholder,
    asChild,
    selectedLabel,
    attrs,
    label,
    $selectedLabel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("placeholder" in $$props) $$invalidate(0, placeholder = $$new_props.placeholder);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("label" in $$props) $$invalidate(2, label = $$new_props.label);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectedLabel*/
    64) {
      $: $$invalidate(2, label = $selectedLabel);
    }
  };
  return [
    placeholder,
    asChild,
    label,
    selectedLabel,
    attrs,
    $$restProps,
    $selectedLabel,
    $$scope,
    slots
  ];
}
var SelectValue = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance109, create_fragment109, safe_not_equal, { placeholder: 0, asChild: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectValue",
      options,
      id: create_fragment109.name
    });
  }
  get placeholder() {
    throw new Error("<SelectValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<SelectValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<SelectValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<SelectValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectValue_default = SelectValue;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/separator/index.js
var separator_exports = {};
__export(separator_exports, {
  Root: () => Separator_default,
  Separator: () => Separator_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/slider/index.js
var slider_exports = {};
__export(slider_exports, {
  Input: () => SliderInput_default,
  Range: () => SliderRange_default,
  Root: () => Slider_default,
  Slider: () => Slider_default,
  SliderInput: () => SliderInput_default,
  SliderRange: () => SliderRange_default,
  SliderThumb: () => SliderThumb_default,
  SliderTick: () => SliderTick_default,
  Thumb: () => SliderThumb_default,
  Tick: () => SliderTick_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/slider/ctx.js
var NAME18 = "slider";
var PARTS17 = ["root", "input", "range", "thumb", "tick"];
var getAttrs18 = createBitAttrs(NAME18, PARTS17);
function setCtx16(props) {
  const slider = createSlider(removeUndefined2(props));
  setContext(NAME18, slider);
  return {
    ...slider,
    updateOption: getOptionUpdater(slider.options)
  };
}
function getCtx15() {
  return getContext(NAME18);
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/slider/components/Slider.svelte
var file94 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/slider/components/Slider.svelte";
var get_default_slot_changes_171 = (dirty) => ({
  builder: dirty & /*builder*/
  2,
  ticks: dirty & /*$ticks*/
  4
});
var get_default_slot_context_171 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[5]
  ),
  ticks: (
    /*$ticks*/
    ctx[2]
  )
});
var get_default_slot_changes102 = (dirty) => ({
  builder: dirty & /*builder*/
  2,
  ticks: dirty & /*$ticks*/
  4
});
var get_default_slot_context102 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[5]
  ),
  ticks: (
    /*$ticks*/
    ctx[2]
  )
});
function create_else_block73(ctx) {
  let span;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_171
  );
  let span_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[6],
    /*attrs*/
    ctx[5]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot) default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file94, 49, 1, 994);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(span));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, $ticks*/
        32774)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes_171
            ),
            get_default_slot_context_171
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        /*attrs*/
        ctx2[5]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block73.name,
    type: "else",
    source: "(49:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block96(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context102
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, $ticks*/
        32774)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes102
            ),
            get_default_slot_context102
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block96.name,
    type: "if",
    source: "(47:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment110(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block96, create_else_block73];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment110.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance110($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["disabled", "min", "max", "step", "orientation", "value", "onValueChange", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $root;
  let $ticks;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Slider", slots, ["default"]);
  let { disabled = void 0 } = $$props;
  let { min = void 0 } = $$props;
  let { max = void 0 } = $$props;
  let { step = void 0 } = $$props;
  let { orientation = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { onValueChange = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { root }, states: { value: localValue, ticks }, updateOption } = setCtx16({
    disabled,
    min,
    max,
    step,
    orientation,
    defaultValue: value,
    onValueChange: ({ next: next2 }) => {
      if (value !== next2) {
        onValueChange == null ? void 0 : onValueChange(next2);
        $$invalidate(7, value = next2);
      }
      return next2;
    }
  });
  validate_store(root, "root");
  component_subscribe($$self, root, (value2) => $$invalidate(14, $root = value2));
  validate_store(ticks, "ticks");
  component_subscribe($$self, ticks, (value2) => $$invalidate(2, $ticks = value2));
  const attrs = getAttrs18("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("disabled" in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("min" in $$new_props) $$invalidate(9, min = $$new_props.min);
    if ("max" in $$new_props) $$invalidate(10, max = $$new_props.max);
    if ("step" in $$new_props) $$invalidate(11, step = $$new_props.step);
    if ("orientation" in $$new_props) $$invalidate(12, orientation = $$new_props.orientation);
    if ("value" in $$new_props) $$invalidate(7, value = $$new_props.value);
    if ("onValueChange" in $$new_props) $$invalidate(13, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCtx: setCtx16,
    getAttrs: getAttrs18,
    disabled,
    min,
    max,
    step,
    orientation,
    value,
    onValueChange,
    asChild,
    root,
    localValue,
    ticks,
    updateOption,
    attrs,
    builder: builder2,
    $root,
    $ticks
  });
  $$self.$inject_state = ($$new_props) => {
    if ("disabled" in $$props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("min" in $$props) $$invalidate(9, min = $$new_props.min);
    if ("max" in $$props) $$invalidate(10, max = $$new_props.max);
    if ("step" in $$props) $$invalidate(11, step = $$new_props.step);
    if ("orientation" in $$props) $$invalidate(12, orientation = $$new_props.orientation);
    if ("value" in $$props) $$invalidate(7, value = $$new_props.value);
    if ("onValueChange" in $$props) $$invalidate(13, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    128) {
      $: value !== void 0 && localValue.set(value);
    }
    if ($$self.$$.dirty & /*disabled*/
    256) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*min*/
    512) {
      $: updateOption("min", min);
    }
    if ($$self.$$.dirty & /*max*/
    1024) {
      $: updateOption("max", max);
    }
    if ($$self.$$.dirty & /*step*/
    2048) {
      $: updateOption("step", step);
    }
    if ($$self.$$.dirty & /*orientation*/
    4096) {
      $: updateOption("orientation", orientation);
    }
    if ($$self.$$.dirty & /*$root*/
    16384) {
      $: $$invalidate(1, builder2 = $root);
    }
  };
  return [
    asChild,
    builder2,
    $ticks,
    root,
    ticks,
    attrs,
    $$restProps,
    value,
    disabled,
    min,
    max,
    step,
    orientation,
    onValueChange,
    $root,
    $$scope,
    slots
  ];
}
var Slider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance110, create_fragment110, safe_not_equal, {
      disabled: 8,
      min: 9,
      max: 10,
      step: 11,
      orientation: 12,
      value: 7,
      onValueChange: 13,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slider",
      options,
      id: create_fragment110.name
    });
  }
  get disabled() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValueChange() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValueChange(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Slider_default = Slider;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/slider/components/SliderRange.svelte
var file95 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/slider/components/SliderRange.svelte";
var get_default_slot_changes103 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context103 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block74(ctx) {
  let span;
  let builder_action_action;
  let mounted;
  let dispose;
  let span_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file95, 14, 1, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(span));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block74.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block97(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context103
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes103
            ),
            get_default_slot_context103
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block97.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment111(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block97, create_else_block74];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment111.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance111($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $range;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SliderRange", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { range } } = getCtx15();
  validate_store(range, "range");
  component_subscribe($$self, range, (value) => $$invalidate(5, $range = value));
  const attrs = getAttrs18("range");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx15,
    getAttrs: getAttrs18,
    asChild,
    range,
    attrs,
    builder: builder2,
    $range
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$range*/
    32) {
      $: $$invalidate(1, builder2 = $range);
    }
  };
  return [asChild, builder2, range, attrs, $$restProps, $range, $$scope, slots];
}
var SliderRange = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance111, create_fragment111, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SliderRange",
      options,
      id: create_fragment111.name
    });
  }
  get asChild() {
    throw new Error("<SliderRange>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<SliderRange>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SliderRange_default = SliderRange;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/slider/components/SliderThumb.svelte
var file96 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/slider/components/SliderThumb.svelte";
var get_default_slot_changes104 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context104 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block75(ctx) {
  let span;
  let builder_action_action;
  let mounted;
  let dispose;
  let span_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file96, 16, 1, 387);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(span)),
          listen_dev(
            span,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block75.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block98(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context104
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes104
            ),
            get_default_slot_context104
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block98.name,
    type: "if",
    source: "(14:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment112(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block98, create_else_block75];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment112.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance112($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $thumb;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SliderThumb", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { thumb } } = getCtx15();
  validate_store(thumb, "thumb");
  component_subscribe($$self, thumb, (value) => $$invalidate(6, $thumb = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs18("thumb");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx15,
    getAttrs: getAttrs18,
    createDispatcher,
    asChild,
    thumb,
    dispatch,
    attrs,
    builder: builder2,
    $thumb
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$thumb*/
    64) {
      $: $$invalidate(1, builder2 = $thumb());
    }
  };
  return [asChild, builder2, thumb, dispatch, attrs, $$restProps, $thumb, $$scope, slots];
}
var SliderThumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance112, create_fragment112, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SliderThumb",
      options,
      id: create_fragment112.name
    });
  }
  get asChild() {
    throw new Error("<SliderThumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<SliderThumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SliderThumb_default = SliderThumb;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/slider/components/SliderInput.svelte
var file97 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/slider/components/SliderInput.svelte";
function create_fragment113(ctx) {
  let input;
  let input_levels = [
    /*$$restProps*/
    ctx[3],
    { value: (
      /*inputValue*/
      ctx[0]
    ) },
    { hidden: true },
    /*attrs*/
    ctx[2]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {});
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file97, 16, 0, 306);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (input.autofocus) input.focus();
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        dirty & /*inputValue*/
        1 && input.value !== /*inputValue*/
        ctx2[0] && { value: (
          /*inputValue*/
          ctx2[0]
        ) },
        { hidden: true },
        /*attrs*/
        ctx2[2]
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment113.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getValue(value2) {
  if (value2.length === 1) {
    return value2[0];
  } else {
    return value2[1] - value2[0];
  }
}
function instance113($$self, $$props, $$invalidate) {
  let inputValue;
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $value;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SliderInput", slots, []);
  const { states: { value } } = getCtx15();
  validate_store(value, "value");
  component_subscribe($$self, value, (value2) => $$invalidate(4, $value = value2));
  const attrs = getAttrs18("input");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  $$self.$capture_state = () => ({
    getCtx: getCtx15,
    getAttrs: getAttrs18,
    value,
    getValue,
    attrs,
    inputValue,
    $value
  });
  $$self.$inject_state = ($$new_props) => {
    if ("inputValue" in $$props) $$invalidate(0, inputValue = $$new_props.inputValue);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$value*/
    16) {
      $: $$invalidate(0, inputValue = getValue($value));
    }
  };
  return [inputValue, value, attrs, $$restProps, $value];
}
var SliderInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance113, create_fragment113, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SliderInput",
      options,
      id: create_fragment113.name
    });
  }
};
var SliderInput_default = SliderInput;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/slider/components/SliderTick.svelte
var file98 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/slider/components/SliderTick.svelte";
var get_default_slot_changes105 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context105 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block76(ctx) {
  let span;
  let builder_action_action;
  let mounted;
  let dispose;
  let span_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file98, 14, 1, 283);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(span));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block76.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block99(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context105
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes105
            ),
            get_default_slot_context105
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block99.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment114(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block99, create_else_block76];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment114.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance114($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $tick;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SliderTick", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { tick: tick2 } } = getCtx15();
  validate_store(tick2, "tick");
  component_subscribe($$self, tick2, (value) => $$invalidate(5, $tick = value));
  const attrs = getAttrs18("tick");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx15,
    getAttrs: getAttrs18,
    asChild,
    tick: tick2,
    attrs,
    builder: builder2,
    $tick
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$tick*/
    32) {
      $: $$invalidate(1, builder2 = $tick());
    }
  };
  return [asChild, builder2, tick2, attrs, $$restProps, $tick, $$scope, slots];
}
var SliderTick = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance114, create_fragment114, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SliderTick",
      options,
      id: create_fragment114.name
    });
  }
  get asChild() {
    throw new Error("<SliderTick>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<SliderTick>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SliderTick_default = SliderTick;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/switch/index.js
var switch_exports = {};
__export(switch_exports, {
  Input: () => SwitchInput_default,
  Root: () => Switch_default,
  Switch: () => Switch_default,
  SwitchInput: () => SwitchInput_default,
  SwitchThumb: () => SwitchThumb_default,
  Thumb: () => SwitchThumb_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/switch/ctx.js
var NAME19 = "switch";
var PARTS18 = ["root", "input", "thumb"];
var getAttrs19 = createBitAttrs(NAME19, PARTS18);
function setCtx17(props) {
  const Switch2 = createSwitch(removeUndefined2(props));
  setContext(NAME19, Switch2);
  return {
    ...Switch2,
    updateOption: getOptionUpdater(Switch2.options)
  };
}
function getCtx16() {
  return getContext(NAME19);
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/switch/components/SwitchInput.svelte
var file99 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/switch/components/SwitchInput.svelte";
function create_fragment115(ctx) {
  let input_1;
  let $input_action_action;
  let mounted;
  let dispose;
  let input_1_levels = [
    /*$input*/
    ctx[1],
    { name: (
      /*$name*/
      ctx[2]
    ) },
    { disabled: (
      /*$disabled*/
      ctx[3]
    ) },
    { required: (
      /*$required*/
      ctx[4]
    ) },
    { value: (
      /*inputValue*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[10]
  ];
  let input_data = {};
  for (let i = 0; i < input_1_levels.length; i += 1) {
    input_data = assign(input_data, input_1_levels[i]);
  }
  const block = {
    c: function create() {
      input_1 = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input_1 = claim_element(nodes, "INPUT", { name: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input_1, input_data);
      add_location(input_1, file99, 10, 0, 257);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input_1, anchor);
      if ("value" in input_data) {
        input_1.value = input_data.value;
      }
      if (input_1.autofocus) input_1.focus();
      if (!mounted) {
        dispose = action_destroyer($input_action_action = /*$input*/
        ctx[1].action(input_1));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input_1, input_data = get_spread_update(input_1_levels, [
        dirty & /*$input*/
        2 && /*$input*/
        ctx2[1],
        dirty & /*$name*/
        4 && { name: (
          /*$name*/
          ctx2[2]
        ) },
        dirty & /*$disabled*/
        8 && { disabled: (
          /*$disabled*/
          ctx2[3]
        ) },
        dirty & /*$required*/
        16 && { required: (
          /*$required*/
          ctx2[4]
        ) },
        dirty & /*inputValue*/
        1 && input_1.value !== /*inputValue*/
        ctx2[0] && { value: (
          /*inputValue*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      if ("value" in input_data) {
        input_1.value = input_data.value;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input_1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment115.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance115($$self, $$props, $$invalidate) {
  let inputValue;
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $value;
  let $input;
  let $name;
  let $disabled;
  let $required;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SwitchInput", slots, []);
  const { elements: { input }, options: { value, name: name27, disabled, required } } = getCtx16();
  validate_store(input, "input");
  component_subscribe($$self, input, (value2) => $$invalidate(1, $input = value2));
  validate_store(value, "value");
  component_subscribe($$self, value, (value2) => $$invalidate(11, $value = value2));
  validate_store(name27, "name");
  component_subscribe($$self, name27, (value2) => $$invalidate(2, $name = value2));
  validate_store(disabled, "disabled");
  component_subscribe($$self, disabled, (value2) => $$invalidate(3, $disabled = value2));
  validate_store(required, "required");
  component_subscribe($$self, required, (value2) => $$invalidate(4, $required = value2));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx16,
    input,
    value,
    name: name27,
    disabled,
    required,
    inputValue,
    $value,
    $input,
    $name,
    $disabled,
    $required
  });
  $$self.$inject_state = ($$new_props) => {
    if ("inputValue" in $$props) $$invalidate(0, inputValue = $$new_props.inputValue);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$value*/
    2048) {
      $: $$invalidate(0, inputValue = $value === void 0 || $value === "" ? "on" : $value);
    }
  };
  return [
    inputValue,
    $input,
    $name,
    $disabled,
    $required,
    input,
    value,
    name27,
    disabled,
    required,
    $$restProps,
    $value
  ];
}
var SwitchInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance115, create_fragment115, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SwitchInput",
      options,
      id: create_fragment115.name
    });
  }
};
var SwitchInput_default = SwitchInput;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/switch/components/Switch.svelte
var file100 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/switch/components/Switch.svelte";
var get_default_slot_changes_172 = (dirty) => ({
  builder: dirty & /*builder*/
  16,
  attrs: dirty & /*attrs*/
  8
});
var get_default_slot_context_172 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[4]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes106 = (dirty) => ({
  builder: dirty & /*builder*/
  16,
  attrs: dirty & /*attrs*/
  8
});
var get_default_slot_context106 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[4]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block77(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context_172
  );
  let button_levels = [
    /*builder*/
    ctx[4],
    { type: "button" },
    /*$$restProps*/
    ctx[7],
    /*attrs*/
    ctx[3]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file100, 51, 1, 1189);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[4].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        32792)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes_172
            ),
            get_default_slot_context_172
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        16 && /*builder*/
        ctx2[4],
        { type: "button" },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7],
        dirty & /*attrs*/
        8 && /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block77.name,
    type: "else",
    source: "(51:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_116(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context106
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder, attrs*/
        32792)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes106
            ),
            get_default_slot_context106
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_116.name,
    type: "if",
    source: "(49:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_if_block100(ctx) {
  let switchinput;
  let current;
  const switchinput_spread_levels = [
    /*inputAttrs*/
    ctx[2]
  ];
  let switchinput_props = {};
  for (let i = 0; i < switchinput_spread_levels.length; i += 1) {
    switchinput_props = assign(switchinput_props, switchinput_spread_levels[i]);
  }
  switchinput = new SwitchInput_default({ props: switchinput_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(switchinput.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(switchinput.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(switchinput, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switchinput_changes = dirty & /*inputAttrs*/
      4 ? get_spread_update(switchinput_spread_levels, [get_spread_object(
        /*inputAttrs*/
        ctx2[2]
      )]) : {};
      switchinput.$set(switchinput_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(switchinput.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(switchinput.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(switchinput, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block100.name,
    type: "if",
    source: "(63:0) {#if includeInput}",
    ctx
  });
  return block;
}
function create_fragment116(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_116, create_else_block77];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*includeInput*/
    ctx[0] && create_if_block100(ctx)
  );
  const block = {
    c: function create() {
      if_block0.c();
      t = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t.parentNode, t);
      }
      if (
        /*includeInput*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*includeInput*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block100(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment116.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance116($$self, $$props, $$invalidate) {
  let builder2;
  let attrs;
  const omit_props_names = [
    "checked",
    "onCheckedChange",
    "disabled",
    "name",
    "value",
    "includeInput",
    "required",
    "asChild",
    "inputAttrs"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $root;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Switch", slots, ["default"]);
  let { checked = void 0 } = $$props;
  let { onCheckedChange = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { name: name27 = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { includeInput = true } = $$props;
  let { required = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { inputAttrs = void 0 } = $$props;
  const { elements: { root }, states: { checked: localChecked }, updateOption } = setCtx17({
    disabled,
    name: name27,
    value,
    required,
    defaultChecked: checked,
    onCheckedChange: ({ next: next2 }) => {
      if (checked !== next2) {
        onCheckedChange == null ? void 0 : onCheckedChange(next2);
        $$invalidate(8, checked = next2);
      }
      return next2;
    }
  });
  validate_store(root, "root");
  component_subscribe($$self, root, (value2) => $$invalidate(14, $root = value2));
  const dispatch = createDispatcher();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props) $$invalidate(8, checked = $$new_props.checked);
    if ("onCheckedChange" in $$new_props) $$invalidate(9, onCheckedChange = $$new_props.onCheckedChange);
    if ("disabled" in $$new_props) $$invalidate(10, disabled = $$new_props.disabled);
    if ("name" in $$new_props) $$invalidate(11, name27 = $$new_props.name);
    if ("value" in $$new_props) $$invalidate(12, value = $$new_props.value);
    if ("includeInput" in $$new_props) $$invalidate(0, includeInput = $$new_props.includeInput);
    if ("required" in $$new_props) $$invalidate(13, required = $$new_props.required);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("inputAttrs" in $$new_props) $$invalidate(2, inputAttrs = $$new_props.inputAttrs);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCtx: setCtx17,
    getAttrs: getAttrs19,
    createDispatcher,
    SwitchInput: SwitchInput_default,
    checked,
    onCheckedChange,
    disabled,
    name: name27,
    value,
    includeInput,
    required,
    asChild,
    inputAttrs,
    root,
    localChecked,
    updateOption,
    dispatch,
    attrs,
    builder: builder2,
    $root
  });
  $$self.$inject_state = ($$new_props) => {
    if ("checked" in $$props) $$invalidate(8, checked = $$new_props.checked);
    if ("onCheckedChange" in $$props) $$invalidate(9, onCheckedChange = $$new_props.onCheckedChange);
    if ("disabled" in $$props) $$invalidate(10, disabled = $$new_props.disabled);
    if ("name" in $$props) $$invalidate(11, name27 = $$new_props.name);
    if ("value" in $$props) $$invalidate(12, value = $$new_props.value);
    if ("includeInput" in $$props) $$invalidate(0, includeInput = $$new_props.includeInput);
    if ("required" in $$props) $$invalidate(13, required = $$new_props.required);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("inputAttrs" in $$props) $$invalidate(2, inputAttrs = $$new_props.inputAttrs);
    if ("attrs" in $$props) $$invalidate(3, attrs = $$new_props.attrs);
    if ("builder" in $$props) $$invalidate(4, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checked*/
    256) {
      $: checked !== void 0 && localChecked.set(checked);
    }
    if ($$self.$$.dirty & /*disabled*/
    1024) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*name*/
    2048) {
      $: updateOption("name", name27);
    }
    if ($$self.$$.dirty & /*value*/
    4096) {
      $: updateOption("value", value);
    }
    if ($$self.$$.dirty & /*required*/
    8192) {
      $: updateOption("required", required);
    }
    if ($$self.$$.dirty & /*$root*/
    16384) {
      $: $$invalidate(4, builder2 = $root);
    }
    if ($$self.$$.dirty & /*checked*/
    256) {
      $: $$invalidate(3, attrs = {
        ...getAttrs19("root"),
        "data-checked": checked ? "" : void 0
      });
    }
  };
  return [
    includeInput,
    asChild,
    inputAttrs,
    attrs,
    builder2,
    root,
    dispatch,
    $$restProps,
    checked,
    onCheckedChange,
    disabled,
    name27,
    value,
    required,
    $root,
    $$scope,
    slots
  ];
}
var Switch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance116, create_fragment116, safe_not_equal, {
      checked: 8,
      onCheckedChange: 9,
      disabled: 10,
      name: 11,
      value: 12,
      includeInput: 0,
      required: 13,
      asChild: 1,
      inputAttrs: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Switch",
      options,
      id: create_fragment116.name
    });
  }
  get checked() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCheckedChange() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCheckedChange(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get includeInput() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set includeInput(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputAttrs() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputAttrs(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Switch_default = Switch;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/switch/components/SwitchThumb.svelte
var file101 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/switch/components/SwitchThumb.svelte";
var get_default_slot_changes107 = (dirty) => ({
  checked: dirty & /*$checked*/
  2,
  attrs: dirty & /*attrs*/
  4
});
var get_default_slot_context107 = (ctx) => ({
  checked: (
    /*$checked*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[2]
  )
});
function create_else_block78(ctx) {
  let span;
  let span_levels = [
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[2]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file101, 16, 1, 340);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    p: function update(ctx2, dirty) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        dirty & /*attrs*/
        4 && /*attrs*/
        ctx2[2]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block78.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block101(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context107
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $checked, attrs*/
        38)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes107
            ),
            get_default_slot_context107
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block101.name,
    type: "if",
    source: "(14:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment117(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block101, create_else_block78];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment117.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance117($$self, $$props, $$invalidate) {
  let attrs;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $checked;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SwitchThumb", slots, ["default"]);
  let { asChild = false } = $$props;
  const { states: { checked } } = getCtx16();
  validate_store(checked, "checked");
  component_subscribe($$self, checked, (value) => $$invalidate(1, $checked = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getCtx: getCtx16,
    getAttrs: getAttrs19,
    asChild,
    checked,
    attrs,
    $checked
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("attrs" in $$props) $$invalidate(2, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$checked*/
    2) {
      $: $$invalidate(2, attrs = {
        ...getAttrs19("thumb"),
        "data-state": $checked ? "checked" : "unchecked",
        "data-checked": $checked ? "" : void 0
      });
    }
  };
  return [asChild, $checked, attrs, checked, $$restProps, $$scope, slots];
}
var SwitchThumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance117, create_fragment117, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SwitchThumb",
      options,
      id: create_fragment117.name
    });
  }
  get asChild() {
    throw new Error("<SwitchThumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<SwitchThumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SwitchThumb_default = SwitchThumb;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tabs/index.js
var tabs_exports = {};
__export(tabs_exports, {
  Content: () => TabsContent_default,
  List: () => TabsList_default,
  Root: () => Tabs_default,
  Tabs: () => Tabs_default,
  TabsContent: () => TabsContent_default,
  TabsList: () => TabsList_default,
  TabsTrigger: () => TabsTrigger_default,
  Trigger: () => TabsTrigger_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tabs/ctx.js
var NAME20 = "tabs";
var PARTS19 = ["root", "content", "list", "trigger"];
var getAttrs20 = createBitAttrs(NAME20, PARTS19);
function setCtx18(props) {
  const tabs = createTabs(removeUndefined2(props));
  setContext(NAME20, tabs);
  return {
    ...tabs,
    updateOption: getOptionUpdater(tabs.options)
  };
}
function getCtx17() {
  return getContext(NAME20);
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tabs/components/Tabs.svelte
var file102 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tabs/components/Tabs.svelte";
var get_default_slot_changes_173 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_173 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes108 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context108 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block79(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context_173
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file102, 45, 1, 953);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        4098)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes_173
            ),
            get_default_slot_context_173
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block79.name,
    type: "else",
    source: "(45:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block102(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context108
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        4098)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes108
            ),
            get_default_slot_context108
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block102.name,
    type: "if",
    source: "(43:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment118(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block102, create_else_block79];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment118.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance118($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "orientation",
    "activateOnFocus",
    "loop",
    "autoSet",
    "value",
    "onValueChange",
    "asChild"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $root;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tabs", slots, ["default"]);
  let { orientation = void 0 } = $$props;
  let { activateOnFocus = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { autoSet = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { onValueChange = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { root }, states: { value: localValue }, updateOption } = setCtx18({
    orientation,
    activateOnFocus,
    loop,
    autoSet,
    defaultValue: value,
    onValueChange: ({ next: next2 }) => {
      if (value !== next2) {
        onValueChange == null ? void 0 : onValueChange(next2);
        $$invalidate(5, value = next2);
      }
      return next2;
    }
  });
  validate_store(root, "root");
  component_subscribe($$self, root, (value2) => $$invalidate(11, $root = value2));
  const attrs = getAttrs20("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("orientation" in $$new_props) $$invalidate(6, orientation = $$new_props.orientation);
    if ("activateOnFocus" in $$new_props) $$invalidate(7, activateOnFocus = $$new_props.activateOnFocus);
    if ("loop" in $$new_props) $$invalidate(8, loop = $$new_props.loop);
    if ("autoSet" in $$new_props) $$invalidate(9, autoSet = $$new_props.autoSet);
    if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$new_props) $$invalidate(10, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCtx: setCtx18,
    getAttrs: getAttrs20,
    orientation,
    activateOnFocus,
    loop,
    autoSet,
    value,
    onValueChange,
    asChild,
    root,
    localValue,
    updateOption,
    attrs,
    builder: builder2,
    $root
  });
  $$self.$inject_state = ($$new_props) => {
    if ("orientation" in $$props) $$invalidate(6, orientation = $$new_props.orientation);
    if ("activateOnFocus" in $$props) $$invalidate(7, activateOnFocus = $$new_props.activateOnFocus);
    if ("loop" in $$props) $$invalidate(8, loop = $$new_props.loop);
    if ("autoSet" in $$props) $$invalidate(9, autoSet = $$new_props.autoSet);
    if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
    if ("onValueChange" in $$props) $$invalidate(10, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    32) {
      $: value !== void 0 && localValue.set(value);
    }
    if ($$self.$$.dirty & /*orientation*/
    64) {
      $: updateOption("orientation", orientation);
    }
    if ($$self.$$.dirty & /*activateOnFocus*/
    128) {
      $: updateOption("activateOnFocus", activateOnFocus);
    }
    if ($$self.$$.dirty & /*loop*/
    256) {
      $: updateOption("loop", loop);
    }
    if ($$self.$$.dirty & /*autoSet*/
    512) {
      $: updateOption("autoSet", autoSet);
    }
    if ($$self.$$.dirty & /*$root*/
    2048) {
      $: $$invalidate(1, builder2 = $root);
    }
  };
  return [
    asChild,
    builder2,
    root,
    attrs,
    $$restProps,
    value,
    orientation,
    activateOnFocus,
    loop,
    autoSet,
    onValueChange,
    $root,
    $$scope,
    slots
  ];
}
var Tabs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance118, create_fragment118, safe_not_equal, {
      orientation: 6,
      activateOnFocus: 7,
      loop: 8,
      autoSet: 9,
      value: 5,
      onValueChange: 10,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tabs",
      options,
      id: create_fragment118.name
    });
  }
  get orientation() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activateOnFocus() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activateOnFocus(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoSet() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoSet(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValueChange() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValueChange(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tabs_default = Tabs;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tabs/components/TabsContent.svelte
var file103 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tabs/components/TabsContent.svelte";
var get_default_slot_changes_174 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_174 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes109 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context109 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block80(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_174
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file103, 15, 1, 315);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_174
            ),
            get_default_slot_context_174
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block80.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block103(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context109
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes109
            ),
            get_default_slot_context109
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block103.name,
    type: "if",
    source: "(13:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment119(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block103, create_else_block80];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment119.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance119($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["value", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $content;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabsContent", slots, ["default"]);
  let { value } = $$props;
  let { asChild = false } = $$props;
  const { elements: { content } } = getCtx17();
  validate_store(content, "content");
  component_subscribe($$self, content, (value2) => $$invalidate(6, $content = value2));
  const attrs = getAttrs20("content");
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<TabsContent> was created without expected prop 'value'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx17,
    getAttrs: getAttrs20,
    value,
    asChild,
    content,
    attrs,
    builder: builder2,
    $content
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$content, value*/
    96) {
      $: $$invalidate(1, builder2 = $content(value));
    }
  };
  return [asChild, builder2, content, attrs, $$restProps, value, $content, $$scope, slots];
}
var TabsContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance119, create_fragment119, safe_not_equal, { value: 5, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabsContent",
      options,
      id: create_fragment119.name
    });
  }
  get value() {
    throw new Error("<TabsContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TabsContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<TabsContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<TabsContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabsContent_default = TabsContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tabs/components/TabsList.svelte
var file104 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tabs/components/TabsList.svelte";
var get_default_slot_changes_175 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_175 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes110 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context110 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block81(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context_175
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file104, 14, 1, 281);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes_175
            ),
            get_default_slot_context_175
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block81.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block104(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context110
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes110
            ),
            get_default_slot_context110
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block104.name,
    type: "if",
    source: "(12:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment120(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block104, create_else_block81];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment120.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance120($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $list;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabsList", slots, ["default"]);
  let { asChild = false } = $$props;
  const { elements: { list } } = getCtx17();
  validate_store(list, "list");
  component_subscribe($$self, list, (value) => $$invalidate(5, $list = value));
  const attrs = getAttrs20("list");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx17,
    getAttrs: getAttrs20,
    asChild,
    list,
    attrs,
    builder: builder2,
    $list
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$list*/
    32) {
      $: $$invalidate(1, builder2 = $list);
    }
  };
  return [asChild, builder2, list, attrs, $$restProps, $list, $$scope, slots];
}
var TabsList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance120, create_fragment120, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabsList",
      options,
      id: create_fragment120.name
    });
  }
  get asChild() {
    throw new Error("<TabsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<TabsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabsList_default = TabsList;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tabs/components/TabsTrigger.svelte
var file105 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tabs/components/TabsTrigger.svelte";
var get_default_slot_changes_176 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_176 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes111 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context111 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block82(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context_176
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file105, 18, 1, 460);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-focus",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes_176
            ),
            get_default_slot_context_176
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block82.name,
    type: "else",
    source: "(18:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block105(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context111
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes111
            ),
            get_default_slot_context111
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block105.name,
    type: "if",
    source: "(16:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment121(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block105, create_else_block82];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment121.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance121($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["value", "disabled", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $trigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabsTrigger", slots, ["default"]);
  let { value } = $$props;
  let { disabled = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { trigger } } = getCtx17();
  validate_store(trigger, "trigger");
  component_subscribe($$self, trigger, (value2) => $$invalidate(8, $trigger = value2));
  const dispatch = createDispatcher();
  const attrs = getAttrs20("trigger");
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<TabsTrigger> was created without expected prop 'value'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx17,
    getAttrs: getAttrs20,
    createDispatcher,
    value,
    disabled,
    asChild,
    trigger,
    dispatch,
    attrs,
    builder: builder2,
    $trigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$trigger, value, disabled*/
    448) {
      $: $$invalidate(1, builder2 = $trigger({ value, disabled }));
    }
  };
  return [
    asChild,
    builder2,
    trigger,
    dispatch,
    attrs,
    $$restProps,
    value,
    disabled,
    $trigger,
    $$scope,
    slots
  ];
}
var TabsTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance121, create_fragment121, safe_not_equal, { value: 6, disabled: 7, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabsTrigger",
      options,
      id: create_fragment121.name
    });
  }
  get value() {
    throw new Error("<TabsTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TabsTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TabsTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TabsTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<TabsTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<TabsTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabsTrigger_default = TabsTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/toggle/index.js
var toggle_exports = {};
__export(toggle_exports, {
  Root: () => Toggle_default,
  Toggle: () => Toggle_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/toggle/ctx.js
var NAME21 = "toggle";
var PARTS20 = ["root", "input"];
var getAttrs21 = createBitAttrs(NAME21, PARTS20);
function setCtx19(props) {
  const toggle2 = createToggle(removeUndefined2(props));
  setContext(NAME21, toggle2);
  return {
    ...toggle2,
    updateOption: getOptionUpdater(toggle2.options)
  };
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/toggle/components/Toggle.svelte
var file106 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/toggle/components/Toggle.svelte";
var get_default_slot_changes_177 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_177 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes112 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context112 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block83(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context_177
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file106, 35, 1, 811);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1026)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes_177
            ),
            get_default_slot_context_177
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block83.name,
    type: "else",
    source: "(35:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block106(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context112
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        1026)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes112
            ),
            get_default_slot_context112
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block106.name,
    type: "if",
    source: "(33:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment122(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block106, create_else_block83];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment122.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance122($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["disabled", "pressed", "onPressedChange", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $root;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toggle", slots, ["default"]);
  let { disabled = void 0 } = $$props;
  let { pressed = void 0 } = $$props;
  let { onPressedChange = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { root }, states: { pressed: localPressed }, updateOption } = setCtx19({
    disabled,
    defaultPressed: pressed,
    onPressedChange: ({ next: next2 }) => {
      if (pressed !== next2) {
        onPressedChange == null ? void 0 : onPressedChange(next2);
        $$invalidate(6, pressed = next2);
      }
      return next2;
    }
  });
  validate_store(root, "root");
  component_subscribe($$self, root, (value) => $$invalidate(9, $root = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs21("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("pressed" in $$new_props) $$invalidate(6, pressed = $$new_props.pressed);
    if ("onPressedChange" in $$new_props) $$invalidate(8, onPressedChange = $$new_props.onPressedChange);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCtx: setCtx19,
    getAttrs: getAttrs21,
    createDispatcher,
    disabled,
    pressed,
    onPressedChange,
    asChild,
    root,
    localPressed,
    updateOption,
    dispatch,
    attrs,
    builder: builder2,
    $root
  });
  $$self.$inject_state = ($$new_props) => {
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("pressed" in $$props) $$invalidate(6, pressed = $$new_props.pressed);
    if ("onPressedChange" in $$props) $$invalidate(8, onPressedChange = $$new_props.onPressedChange);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*pressed*/
    64) {
      $: pressed !== void 0 && localPressed.set(pressed);
    }
    if ($$self.$$.dirty & /*disabled*/
    128) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*$root*/
    512) {
      $: $$invalidate(1, builder2 = $root);
    }
  };
  return [
    asChild,
    builder2,
    root,
    dispatch,
    attrs,
    $$restProps,
    pressed,
    disabled,
    onPressedChange,
    $root,
    $$scope,
    slots
  ];
}
var Toggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance122, create_fragment122, safe_not_equal, {
      disabled: 7,
      pressed: 6,
      onPressedChange: 8,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toggle",
      options,
      id: create_fragment122.name
    });
  }
  get disabled() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pressed() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pressed(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPressedChange() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPressedChange(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toggle_default = Toggle;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/toggle-group/index.js
var toggle_group_exports = {};
__export(toggle_group_exports, {
  Item: () => ToggleGroupItem_default,
  Root: () => ToggleGroup_default,
  ToggleGroup: () => ToggleGroup_default,
  ToggleGroupItem: () => ToggleGroupItem_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/toggle-group/ctx.js
var NAME22 = "toggle-group";
var PARTS21 = ["root", "item"];
var getAttrs22 = createBitAttrs(NAME22, PARTS21);
function setCtx20(props) {
  const toggleGroup = createToggleGroup(removeUndefined2(props));
  setContext(NAME22, toggleGroup);
  return {
    ...toggleGroup,
    updateOption: getOptionUpdater(toggleGroup.options)
  };
}
function getCtx18() {
  return getContext(NAME22);
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/toggle-group/components/ToggleGroup.svelte
var file107 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/toggle-group/components/ToggleGroup.svelte";
var get_default_slot_changes_178 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_178 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
var get_default_slot_changes113 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context113 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block84(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context_178
  );
  let div_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[4],
    /*attrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file107, 50, 1, 1020);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        4098)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes_178
            ),
            get_default_slot_context_178
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        /*attrs*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block84.name,
    type: "else",
    source: "(50:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block107(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context113
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        4098)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes113
            ),
            get_default_slot_context113
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block107.name,
    type: "if",
    source: "(48:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment123(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block107, create_else_block84];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment123.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance123($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["type", "disabled", "loop", "value", "orientation", "onValueChange", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $root;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToggleGroup", slots, ["default"]);
  let { type = "single" } = $$props;
  let { disabled = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { orientation = void 0 } = $$props;
  let { onValueChange = void 0 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { root }, states: { value: localValue }, updateOption } = setCtx20({
    disabled,
    type,
    defaultValue: value,
    loop,
    orientation,
    onValueChange: ({ next: next2 }) => {
      if (Array.isArray(next2)) {
        onValueChange == null ? void 0 : onValueChange(next2);
        $$invalidate(5, value = next2);
        return next2;
      }
      if (value !== next2) {
        onValueChange == null ? void 0 : onValueChange(next2);
        $$invalidate(5, value = next2);
      }
      return next2;
    }
  });
  validate_store(root, "root");
  component_subscribe($$self, root, (value2) => $$invalidate(11, $root = value2));
  const attrs = getAttrs22("root");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props) $$invalidate(6, type = $$new_props.type);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("loop" in $$new_props) $$invalidate(8, loop = $$new_props.loop);
    if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
    if ("orientation" in $$new_props) $$invalidate(9, orientation = $$new_props.orientation);
    if ("onValueChange" in $$new_props) $$invalidate(10, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setCtx: setCtx20,
    getAttrs: getAttrs22,
    type,
    disabled,
    loop,
    value,
    orientation,
    onValueChange,
    asChild,
    root,
    localValue,
    updateOption,
    attrs,
    builder: builder2,
    $root
  });
  $$self.$inject_state = ($$new_props) => {
    if ("type" in $$props) $$invalidate(6, type = $$new_props.type);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("loop" in $$props) $$invalidate(8, loop = $$new_props.loop);
    if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
    if ("orientation" in $$props) $$invalidate(9, orientation = $$new_props.orientation);
    if ("onValueChange" in $$props) $$invalidate(10, onValueChange = $$new_props.onValueChange);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    32) {
      $: value !== void 0 && localValue.set(value);
    }
    if ($$self.$$.dirty & /*disabled*/
    128) {
      $: updateOption("disabled", disabled);
    }
    if ($$self.$$.dirty & /*loop*/
    256) {
      $: updateOption("loop", loop);
    }
    if ($$self.$$.dirty & /*type*/
    64) {
      $: updateOption("type", type);
    }
    if ($$self.$$.dirty & /*orientation*/
    512) {
      $: updateOption("orientation", orientation);
    }
    if ($$self.$$.dirty & /*$root*/
    2048) {
      $: $$invalidate(1, builder2 = $root);
    }
  };
  return [
    asChild,
    builder2,
    root,
    attrs,
    $$restProps,
    value,
    type,
    disabled,
    loop,
    orientation,
    onValueChange,
    $root,
    $$scope,
    slots
  ];
}
var ToggleGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance123, create_fragment123, safe_not_equal, {
      type: 6,
      disabled: 7,
      loop: 8,
      value: 5,
      orientation: 9,
      onValueChange: 10,
      asChild: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToggleGroup",
      options,
      id: create_fragment123.name
    });
  }
  get type() {
    throw new Error("<ToggleGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<ToggleGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ToggleGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ToggleGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<ToggleGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<ToggleGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ToggleGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ToggleGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<ToggleGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<ToggleGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValueChange() {
    throw new Error("<ToggleGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValueChange(value) {
    throw new Error("<ToggleGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<ToggleGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ToggleGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToggleGroup_default = ToggleGroup;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/toggle-group/components/ToggleGroupItem.svelte
var file108 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/toggle-group/components/ToggleGroupItem.svelte";
var get_default_slot_changes_179 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_179 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes114 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context114 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block85(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context_179
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {});
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file108, 18, 1, 440);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-click",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes_179
            ),
            get_default_slot_context_179
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block85.name,
    type: "else",
    source: "(18:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block108(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context114
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes114
            ),
            get_default_slot_context114
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block108.name,
    type: "if",
    source: "(16:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment124(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block108, create_else_block85];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment124.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance124($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["value", "disabled", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $item;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToggleGroupItem", slots, ["default"]);
  let { value } = $$props;
  let { disabled = false } = $$props;
  let { asChild = false } = $$props;
  const { elements: { item } } = getCtx18();
  validate_store(item, "item");
  component_subscribe($$self, item, (value2) => $$invalidate(8, $item = value2));
  const dispatch = createDispatcher();
  const attrs = getAttrs22("item");
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<ToggleGroupItem> was created without expected prop 'value'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    getCtx: getCtx18,
    getAttrs: getAttrs22,
    createDispatcher,
    value,
    disabled,
    asChild,
    item,
    dispatch,
    attrs,
    builder: builder2,
    $item
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$item, value, disabled*/
    448) {
      $: $$invalidate(1, builder2 = $item({ value, disabled }));
    }
  };
  return [
    asChild,
    builder2,
    item,
    dispatch,
    attrs,
    $$restProps,
    value,
    disabled,
    $item,
    $$scope,
    slots
  ];
}
var ToggleGroupItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance124, create_fragment124, safe_not_equal, { value: 6, disabled: 7, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToggleGroupItem",
      options,
      id: create_fragment124.name
    });
  }
  get value() {
    throw new Error("<ToggleGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ToggleGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ToggleGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ToggleGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<ToggleGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<ToggleGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToggleGroupItem_default = ToggleGroupItem;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tooltip/index.js
var tooltip_exports = {};
__export(tooltip_exports, {
  Arrow: () => TooltipArrow_default,
  Content: () => TooltipContent_default,
  Root: () => Tooltip_default,
  Tooltip: () => Tooltip_default,
  TooltipArrow: () => TooltipArrow_default,
  TooltipContent: () => TooltipContent_default,
  TooltipTrigger: () => TooltipTrigger_default,
  Trigger: () => TooltipTrigger_default
});

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tooltip/ctx.js
var NAME23 = "tooltip";
var PARTS22 = ["arrow", "content", "trigger"];
var getAttrs23 = createBitAttrs(NAME23, PARTS22);
function setCtx21(props) {
  const tooltip = createTooltip({
    positioning: {
      placement: "top"
    },
    openDelay: 700,
    ...removeUndefined2(props)
  });
  setContext(NAME23, tooltip);
  return {
    ...tooltip,
    updateOption: getOptionUpdater(tooltip.options)
  };
}
function getCtx19(sideOffset = 0) {
  const tooltip = getContext(NAME23);
  const { options: { positioning } } = tooltip;
  positioning.update((prev2) => ({ ...prev2, gutter: sideOffset }));
  return tooltip;
}
function setArrow7(size2 = 8) {
  const tooltip = getCtx19();
  tooltip.options.arrowSize.set(size2);
  return tooltip;
}

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tooltip/components/Tooltip.svelte
var get_default_slot_changes115 = (dirty) => ({ ids: dirty & /*$idValues*/
1 });
var get_default_slot_context115 = (ctx) => ({ ids: (
  /*$idValues*/
  ctx[0]
) });
function create_fragment125(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context115
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $idValues*/
        16385)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes115
            ),
            get_default_slot_context115
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment125.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance125($$self, $$props, $$invalidate) {
  let $idValues;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tooltip", slots, ["default"]);
  let { positioning = void 0 } = $$props;
  let { arrowSize = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { portal = void 0 } = $$props;
  let { closeOnPointerDown = void 0 } = $$props;
  let { openDelay = void 0 } = $$props;
  let { closeDelay = void 0 } = $$props;
  let { open = void 0 } = $$props;
  let { onOpenChange = void 0 } = $$props;
  let { forceVisible = true } = $$props;
  let { disableHoverableContent = void 0 } = $$props;
  let { group = void 0 } = $$props;
  const { states: { open: localOpen }, updateOption, ids } = setCtx21({
    positioning,
    arrowSize,
    closeOnEscape,
    portal,
    closeOnPointerDown,
    openDelay,
    closeDelay,
    forceVisible,
    defaultOpen: open,
    disableHoverableContent,
    group,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange == null ? void 0 : onOpenChange(next2);
        $$invalidate(2, open = next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.content, ids.trigger], ([$contentId, $triggerId]) => ({ content: $contentId, trigger: $triggerId }));
  validate_store(idValues, "idValues");
  component_subscribe($$self, idValues, (value) => $$invalidate(0, $idValues = value));
  const writable_props = [
    "positioning",
    "arrowSize",
    "closeOnEscape",
    "portal",
    "closeOnPointerDown",
    "openDelay",
    "closeDelay",
    "open",
    "onOpenChange",
    "forceVisible",
    "disableHoverableContent",
    "group"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Tooltip> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("positioning" in $$props2) $$invalidate(3, positioning = $$props2.positioning);
    if ("arrowSize" in $$props2) $$invalidate(4, arrowSize = $$props2.arrowSize);
    if ("closeOnEscape" in $$props2) $$invalidate(5, closeOnEscape = $$props2.closeOnEscape);
    if ("portal" in $$props2) $$invalidate(6, portal = $$props2.portal);
    if ("closeOnPointerDown" in $$props2) $$invalidate(7, closeOnPointerDown = $$props2.closeOnPointerDown);
    if ("openDelay" in $$props2) $$invalidate(8, openDelay = $$props2.openDelay);
    if ("closeDelay" in $$props2) $$invalidate(9, closeDelay = $$props2.closeDelay);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(10, onOpenChange = $$props2.onOpenChange);
    if ("forceVisible" in $$props2) $$invalidate(11, forceVisible = $$props2.forceVisible);
    if ("disableHoverableContent" in $$props2) $$invalidate(12, disableHoverableContent = $$props2.disableHoverableContent);
    if ("group" in $$props2) $$invalidate(13, group = $$props2.group);
    if ("$$scope" in $$props2) $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    derived,
    setCtx: setCtx21,
    positioning,
    arrowSize,
    closeOnEscape,
    portal,
    closeOnPointerDown,
    openDelay,
    closeDelay,
    open,
    onOpenChange,
    forceVisible,
    disableHoverableContent,
    group,
    localOpen,
    updateOption,
    ids,
    idValues,
    $idValues
  });
  $$self.$inject_state = ($$props2) => {
    if ("positioning" in $$props2) $$invalidate(3, positioning = $$props2.positioning);
    if ("arrowSize" in $$props2) $$invalidate(4, arrowSize = $$props2.arrowSize);
    if ("closeOnEscape" in $$props2) $$invalidate(5, closeOnEscape = $$props2.closeOnEscape);
    if ("portal" in $$props2) $$invalidate(6, portal = $$props2.portal);
    if ("closeOnPointerDown" in $$props2) $$invalidate(7, closeOnPointerDown = $$props2.closeOnPointerDown);
    if ("openDelay" in $$props2) $$invalidate(8, openDelay = $$props2.openDelay);
    if ("closeDelay" in $$props2) $$invalidate(9, closeDelay = $$props2.closeDelay);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
    if ("onOpenChange" in $$props2) $$invalidate(10, onOpenChange = $$props2.onOpenChange);
    if ("forceVisible" in $$props2) $$invalidate(11, forceVisible = $$props2.forceVisible);
    if ("disableHoverableContent" in $$props2) $$invalidate(12, disableHoverableContent = $$props2.disableHoverableContent);
    if ("group" in $$props2) $$invalidate(13, group = $$props2.group);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    4) {
      $: open !== void 0 && localOpen.set(open);
    }
    if ($$self.$$.dirty & /*positioning*/
    8) {
      $: updateOption("positioning", positioning);
    }
    if ($$self.$$.dirty & /*arrowSize*/
    16) {
      $: updateOption("arrowSize", arrowSize);
    }
    if ($$self.$$.dirty & /*closeOnEscape*/
    32) {
      $: updateOption("closeOnEscape", closeOnEscape);
    }
    if ($$self.$$.dirty & /*portal*/
    64) {
      $: updateOption("portal", portal);
    }
    if ($$self.$$.dirty & /*closeOnPointerDown*/
    128) {
      $: updateOption("closeOnPointerDown", closeOnPointerDown);
    }
    if ($$self.$$.dirty & /*openDelay*/
    256) {
      $: updateOption("openDelay", openDelay);
    }
    if ($$self.$$.dirty & /*closeDelay*/
    512) {
      $: updateOption("closeDelay", closeDelay);
    }
    if ($$self.$$.dirty & /*forceVisible*/
    2048) {
      $: updateOption("forceVisible", forceVisible);
    }
    if ($$self.$$.dirty & /*group*/
    8192) {
      $: updateOption("group", group);
    }
    if ($$self.$$.dirty & /*disableHoverableContent*/
    4096) {
      $: updateOption("disableHoverableContent", disableHoverableContent);
    }
  };
  return [
    $idValues,
    idValues,
    open,
    positioning,
    arrowSize,
    closeOnEscape,
    portal,
    closeOnPointerDown,
    openDelay,
    closeDelay,
    onOpenChange,
    forceVisible,
    disableHoverableContent,
    group,
    $$scope,
    slots
  ];
}
var Tooltip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance125, create_fragment125, safe_not_equal, {
      positioning: 3,
      arrowSize: 4,
      closeOnEscape: 5,
      portal: 6,
      closeOnPointerDown: 7,
      openDelay: 8,
      closeDelay: 9,
      open: 2,
      onOpenChange: 10,
      forceVisible: 11,
      disableHoverableContent: 12,
      group: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tooltip",
      options,
      id: create_fragment125.name
    });
  }
  get positioning() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioning(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowSize() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowSize(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get portal() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portal(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnPointerDown() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnPointerDown(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openDelay() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openDelay(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeDelay() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeDelay(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onOpenChange() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onOpenChange(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forceVisible() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forceVisible(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableHoverableContent() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableHoverableContent(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tooltip_default = Tooltip;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tooltip/components/TooltipContent.svelte
var file109 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tooltip/components/TooltipContent.svelte";
var get_default_slot_changes_514 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_514 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_414 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_414 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_314 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_314 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_214 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_214 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes_180 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context_180 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
var get_default_slot_changes116 = (dirty) => ({ builder: dirty & /*builder*/
128 });
var get_default_slot_context116 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[7]
  ),
  attrs: (
    /*attrs*/
    ctx[12]
  )
});
function create_if_block_516(ctx) {
  let div;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_514
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file109, 75, 1, 1805);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerenter",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes_514
            ),
            get_default_slot_context_514
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx2[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13],
        /*attrs*/
        ctx2[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_516.name,
    type: "if",
    source: "(75:16) ",
    ctx
  });
  return block;
}
function create_if_block_416(ctx) {
  let div;
  let builder_action_action;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_414
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file109, 64, 1, 1573);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerenter",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_414
            ),
            get_default_slot_context_414
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (div_outro) div_outro.end(1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_416.name,
    type: "if",
    source: "(64:33) ",
    ctx
  });
  return block;
}
function create_if_block_316(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_314
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file109, 53, 1, 1327);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerenter",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_314
            ),
            get_default_slot_context_314
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(
              div,
              /*inTransition*/
              ctx[2],
              /*inTransitionConfig*/
              ctx[3]
            );
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_316.name,
    type: "if",
    source: "(53:32) ",
    ctx
  });
  return block;
}
function create_if_block_216(ctx) {
  let div;
  let builder_action_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_214
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file109, 41, 1, 1040);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerenter",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_214
            ),
            get_default_slot_context_214
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*inTransition*/
            ctx[2],
            /*inTransitionConfig*/
            ctx[3]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*outTransition*/
          ctx[4],
          /*outTransitionConfig*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_216.name,
    type: "if",
    source: "(41:49) ",
    ctx
  });
  return block;
}
function create_if_block_117(ctx) {
  let div;
  let builder_action_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context_180
  );
  let div_levels = [
    /*builder*/
    ctx[7],
    /*$$restProps*/
    ctx[13],
    /*attrs*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file109, 30, 1, 774);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[7].action(div)),
          listen_dev(
            div,
            "m-pointerdown",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "m-pointerenter",
            /*dispatch*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[17],
              dirty,
              get_default_slot_changes_180
            ),
            get_default_slot_context_180
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        128 && /*builder*/
        ctx[7],
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx[13],
        /*attrs*/
        ctx[12]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            /*transition*/
            ctx[0],
            /*transitionConfig*/
            ctx[1],
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          /*transition*/
          ctx[0],
          /*transitionConfig*/
          ctx[1],
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_117.name,
    type: "if",
    source: "(30:30) ",
    ctx
  });
  return block;
}
function create_if_block109(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context116
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        131200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes116
            ),
            get_default_slot_context116
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block109.name,
    type: "if",
    source: "(28:0) {#if asChild && $open}",
    ctx
  });
  return block;
}
function create_fragment126(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block109,
    create_if_block_117,
    create_if_block_216,
    create_if_block_316,
    create_if_block_416,
    create_if_block_516
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[6] && /*$open*/
      ctx2[8]
    ) return 0;
    if (
      /*transition*/
      ctx2[0] && /*$open*/
      ctx2[8]
    ) return 1;
    if (
      /*inTransition*/
      ctx2[2] && /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 2;
    if (
      /*inTransition*/
      ctx2[2] && /*$open*/
      ctx2[8]
    ) return 3;
    if (
      /*outTransition*/
      ctx2[4] && /*$open*/
      ctx2[8]
    ) return 4;
    if (
      /*$open*/
      ctx2[8]
    ) return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment126.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance126($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "sideOffset",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $content;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TooltipContent", slots, ["default"]);
  let { transition = void 0 } = $$props;
  let { transitionConfig = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { inTransitionConfig = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { outTransitionConfig = void 0 } = $$props;
  let { asChild = false } = $$props;
  let { sideOffset = 4 } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { content }, states: { open }, ids } = getCtx19(sideOffset);
  validate_store(content, "content");
  component_subscribe($$self, content, (value) => $$invalidate(16, $content = value));
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs23("content");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$new_props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$new_props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$new_props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$new_props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$new_props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$new_props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("sideOffset" in $$new_props) $$invalidate(14, sideOffset = $$new_props.sideOffset);
    if ("id" in $$new_props) $$invalidate(15, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    createDispatcher,
    getCtx: getCtx19,
    getAttrs: getAttrs23,
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    sideOffset,
    id,
    content,
    open,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $content,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props) $$invalidate(0, transition = $$new_props.transition);
    if ("transitionConfig" in $$props) $$invalidate(1, transitionConfig = $$new_props.transitionConfig);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$new_props.inTransition);
    if ("inTransitionConfig" in $$props) $$invalidate(3, inTransitionConfig = $$new_props.inTransitionConfig);
    if ("outTransition" in $$props) $$invalidate(4, outTransition = $$new_props.outTransition);
    if ("outTransitionConfig" in $$props) $$invalidate(5, outTransitionConfig = $$new_props.outTransitionConfig);
    if ("asChild" in $$props) $$invalidate(6, asChild = $$new_props.asChild);
    if ("sideOffset" in $$props) $$invalidate(14, sideOffset = $$new_props.sideOffset);
    if ("id" in $$props) $$invalidate(15, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(7, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    32768) {
      $: if (id) {
        ids.content.set(id);
      }
    }
    if ($$self.$$.dirty & /*$content*/
    65536) {
      $: $$invalidate(7, builder2 = $content);
    }
  };
  return [
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    builder2,
    $open,
    content,
    open,
    dispatch,
    attrs,
    $$restProps,
    sideOffset,
    id,
    $content,
    $$scope,
    slots
  ];
}
var TooltipContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance126, create_fragment126, safe_not_equal, {
      transition: 0,
      transitionConfig: 1,
      inTransition: 2,
      inTransitionConfig: 3,
      outTransition: 4,
      outTransitionConfig: 5,
      asChild: 6,
      sideOffset: 14,
      id: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TooltipContent",
      options,
      id: create_fragment126.name
    });
  }
  get transition() {
    throw new Error("<TooltipContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<TooltipContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionConfig() {
    throw new Error("<TooltipContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionConfig(value) {
    throw new Error("<TooltipContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransition() {
    throw new Error("<TooltipContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransition(value) {
    throw new Error("<TooltipContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inTransitionConfig() {
    throw new Error("<TooltipContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inTransitionConfig(value) {
    throw new Error("<TooltipContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransition() {
    throw new Error("<TooltipContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransition(value) {
    throw new Error("<TooltipContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outTransitionConfig() {
    throw new Error("<TooltipContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outTransitionConfig(value) {
    throw new Error("<TooltipContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<TooltipContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<TooltipContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sideOffset() {
    throw new Error("<TooltipContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sideOffset(value) {
    throw new Error("<TooltipContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TooltipContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TooltipContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TooltipContent_default = TooltipContent;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tooltip/components/TooltipTrigger.svelte
var file110 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tooltip/components/TooltipTrigger.svelte";
var get_default_slot_changes_181 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context_181 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
var get_default_slot_changes117 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context117 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[4]
  )
});
function create_else_block86(ctx) {
  let button;
  let builder_action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_181
  );
  let button_levels = [
    /*builder*/
    ctx[1],
    { type: "button" },
    /*$$restProps*/
    ctx[5],
    /*attrs*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file110, 22, 1, 465);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(builder_action_action = /*builder*/
          ctx[1].action(button)),
          listen_dev(
            button,
            "m-blur",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-focus",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-keydown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-pointerdown",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-pointerenter",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "m-pointerleave",
            /*dispatch*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_181
            ),
            get_default_slot_context_181
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        { type: "button" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        /*attrs*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block86.name,
    type: "else",
    source: "(22:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block110(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context117
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes117
            ),
            get_default_slot_context117
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block110.name,
    type: "if",
    source: "(20:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment127(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block110, create_else_block86];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment127.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance127($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $trigger;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TooltipTrigger", slots, ["default"]);
  let { asChild = false } = $$props;
  let { id = void 0 } = $$props;
  const { elements: { trigger }, ids } = getCtx19();
  validate_store(trigger, "trigger");
  component_subscribe($$self, trigger, (value) => $$invalidate(7, $trigger = value));
  const dispatch = createDispatcher();
  const attrs = getAttrs23("trigger");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(6, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    createDispatcher,
    getCtx: getCtx19,
    getAttrs: getAttrs23,
    asChild,
    id,
    trigger,
    ids,
    dispatch,
    attrs,
    builder: builder2,
    $trigger
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(6, id = $$new_props.id);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    64) {
      $: if (id) {
        ids.trigger.set(id);
      }
    }
    if ($$self.$$.dirty & /*$trigger*/
    128) {
      $: $$invalidate(1, builder2 = $trigger);
    }
  };
  return [
    asChild,
    builder2,
    trigger,
    dispatch,
    attrs,
    $$restProps,
    id,
    $trigger,
    $$scope,
    slots
  ];
}
var TooltipTrigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance127, create_fragment127, safe_not_equal, { asChild: 0, id: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TooltipTrigger",
      options,
      id: create_fragment127.name
    });
  }
  get asChild() {
    throw new Error("<TooltipTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<TooltipTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TooltipTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TooltipTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TooltipTrigger_default = TooltipTrigger;

// ../../node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tooltip/components/TooltipArrow.svelte
var file111 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/bits-ui@0.9.9_svelte@4.2.19/node_modules/bits-ui/dist/bits/tooltip/components/TooltipArrow.svelte";
var get_default_slot_changes118 = (dirty) => ({ builder: dirty & /*builder*/
2 });
var get_default_slot_context118 = (ctx) => ({
  builder: (
    /*builder*/
    ctx[1]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block87(ctx) {
  let div;
  let builder_action_action;
  let mounted;
  let dispose;
  let div_levels = [
    /*builder*/
    ctx[1],
    /*attrs*/
    ctx[3],
    /*$$restProps*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file111, 15, 1, 313);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(builder_action_action = /*builder*/
        ctx[1].action(div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*builder*/
        2 && /*builder*/
        ctx2[1],
        /*attrs*/
        ctx2[3],
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block87.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block111(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context118
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, builder*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes118
            ),
            get_default_slot_context118
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block111.name,
    type: "if",
    source: "(13:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment128(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block111, create_else_block87];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment128.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance128($$self, $$props, $$invalidate) {
  let builder2;
  const omit_props_names = ["size", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $arrow;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TooltipArrow", slots, ["default"]);
  let { size: size2 = 8 } = $$props;
  let { asChild = false } = $$props;
  const { elements: { arrow: arrow2 } } = setArrow7(size2);
  validate_store(arrow2, "arrow");
  component_subscribe($$self, arrow2, (value) => $$invalidate(6, $arrow = value));
  const attrs = getAttrs23("arrow");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(5, size2 = $$new_props.size);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    melt,
    setArrow: setArrow7,
    getAttrs: getAttrs23,
    size: size2,
    asChild,
    arrow: arrow2,
    attrs,
    builder: builder2,
    $arrow
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props) $$invalidate(5, size2 = $$new_props.size);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("builder" in $$props) $$invalidate(1, builder2 = $$new_props.builder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$arrow*/
    64) {
      $: $$invalidate(1, builder2 = $arrow);
    }
  };
  return [asChild, builder2, arrow2, attrs, $$restProps, size2, $arrow, $$scope, slots];
}
var TooltipArrow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance128, create_fragment128, safe_not_equal, { size: 5, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TooltipArrow",
      options,
      id: create_fragment128.name
    });
  }
  get size() {
    throw new Error("<TooltipArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TooltipArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<TooltipArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<TooltipArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TooltipArrow_default = TooltipArrow;

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandDialog.svelte
function create_else_block88(ctx) {
  let dialogprimitive_portal;
  let current;
  dialogprimitive_portal = new dialog_exports.Portal({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dialogprimitive_portal.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialogprimitive_portal.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialogprimitive_portal, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dialogprimitive_portal_changes = {};
      if (dirty & /*$$scope, label, contentProps, $$restProps, value, overlayProps*/
      33554554) {
        dialogprimitive_portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dialogprimitive_portal.$set(dialogprimitive_portal_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(dialogprimitive_portal.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialogprimitive_portal.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dialogprimitive_portal, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block88.name,
    type: "else",
    source: "(55:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block112(ctx) {
  let dialogprimitive_overlay;
  let t;
  let dialogprimitive_content;
  let current;
  const dialogprimitive_overlay_spread_levels = [
    /*overlayProps*/
    ctx[5]
  ];
  let dialogprimitive_overlay_props = {};
  for (let i = 0; i < dialogprimitive_overlay_spread_levels.length; i += 1) {
    dialogprimitive_overlay_props = assign(dialogprimitive_overlay_props, dialogprimitive_overlay_spread_levels[i]);
  }
  dialogprimitive_overlay = new dialog_exports.Overlay({
    props: dialogprimitive_overlay_props,
    $$inline: true
  });
  const dialogprimitive_content_spread_levels = [
    { "aria-label": (
      /*label*/
      ctx[3]
    ) },
    /*contentProps*/
    ctx[4]
  ];
  let dialogprimitive_content_props = {
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dialogprimitive_content_spread_levels.length; i += 1) {
    dialogprimitive_content_props = assign(dialogprimitive_content_props, dialogprimitive_content_spread_levels[i]);
  }
  dialogprimitive_content = new dialog_exports.Content({
    props: dialogprimitive_content_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dialogprimitive_overlay.$$.fragment);
      t = space();
      create_component(dialogprimitive_content.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialogprimitive_overlay.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(dialogprimitive_content.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialogprimitive_overlay, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(dialogprimitive_content, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dialogprimitive_overlay_changes = dirty & /*overlayProps*/
      32 ? get_spread_update(dialogprimitive_overlay_spread_levels, [get_spread_object(
        /*overlayProps*/
        ctx2[5]
      )]) : {};
      dialogprimitive_overlay.$set(dialogprimitive_overlay_changes);
      const dialogprimitive_content_changes = dirty & /*label, contentProps*/
      24 ? get_spread_update(dialogprimitive_content_spread_levels, [
        dirty & /*label*/
        8 && { "aria-label": (
          /*label*/
          ctx2[3]
        ) },
        dirty & /*contentProps*/
        16 && get_spread_object(
          /*contentProps*/
          ctx2[4]
        )
      ]) : {};
      if (dirty & /*$$scope, $$restProps, value*/
      33554498) {
        dialogprimitive_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dialogprimitive_content.$set(dialogprimitive_content_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(dialogprimitive_overlay.$$.fragment, local);
      transition_in(dialogprimitive_content.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialogprimitive_overlay.$$.fragment, local);
      transition_out(dialogprimitive_content.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(dialogprimitive_overlay, detaching);
      destroy_component(dialogprimitive_content, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block112.name,
    type: "if",
    source: "(48:1) {#if portal === null}",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(59:4) <Command.Root {...$$restProps} bind:value>",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let command_root;
  let updating_value;
  let current;
  const command_root_spread_levels = [
    /*$$restProps*/
    ctx[6]
  ];
  function command_root_value_binding_1(value) {
    ctx[23](value);
  }
  let command_root_props = {
    $$slots: { default: [create_default_slot_5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < command_root_spread_levels.length; i += 1) {
    command_root_props = assign(command_root_props, command_root_spread_levels[i]);
  }
  if (
    /*value*/
    ctx[1] !== void 0
  ) {
    command_root_props.value = /*value*/
    ctx[1];
  }
  command_root = new cmdk_exports.Root({
    props: command_root_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(command_root, "value", command_root_value_binding_1));
  const block = {
    c: function create() {
      create_component(command_root.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(command_root.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(command_root, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const command_root_changes = dirty & /*$$restProps*/
      64 ? get_spread_update(command_root_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[6]
      )]) : {};
      if (dirty & /*$$scope*/
      33554432) {
        command_root_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty & /*value*/
      2) {
        updating_value = true;
        command_root_changes.value = /*value*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      command_root.$set(command_root_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(command_root.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(command_root.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(command_root, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(58:3) <DialogPrimitive.Content aria-label={label} {...contentProps}>",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let dialogprimitive_overlay;
  let t;
  let dialogprimitive_content;
  let current;
  const dialogprimitive_overlay_spread_levels = [
    /*overlayProps*/
    ctx[5]
  ];
  let dialogprimitive_overlay_props = {};
  for (let i = 0; i < dialogprimitive_overlay_spread_levels.length; i += 1) {
    dialogprimitive_overlay_props = assign(dialogprimitive_overlay_props, dialogprimitive_overlay_spread_levels[i]);
  }
  dialogprimitive_overlay = new dialog_exports.Overlay({
    props: dialogprimitive_overlay_props,
    $$inline: true
  });
  const dialogprimitive_content_spread_levels = [
    { "aria-label": (
      /*label*/
      ctx[3]
    ) },
    /*contentProps*/
    ctx[4]
  ];
  let dialogprimitive_content_props = {
    $$slots: { default: [create_default_slot_4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dialogprimitive_content_spread_levels.length; i += 1) {
    dialogprimitive_content_props = assign(dialogprimitive_content_props, dialogprimitive_content_spread_levels[i]);
  }
  dialogprimitive_content = new dialog_exports.Content({
    props: dialogprimitive_content_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dialogprimitive_overlay.$$.fragment);
      t = space();
      create_component(dialogprimitive_content.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialogprimitive_overlay.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(dialogprimitive_content.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialogprimitive_overlay, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(dialogprimitive_content, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dialogprimitive_overlay_changes = dirty & /*overlayProps*/
      32 ? get_spread_update(dialogprimitive_overlay_spread_levels, [get_spread_object(
        /*overlayProps*/
        ctx2[5]
      )]) : {};
      dialogprimitive_overlay.$set(dialogprimitive_overlay_changes);
      const dialogprimitive_content_changes = dirty & /*label, contentProps*/
      24 ? get_spread_update(dialogprimitive_content_spread_levels, [
        dirty & /*label*/
        8 && { "aria-label": (
          /*label*/
          ctx2[3]
        ) },
        dirty & /*contentProps*/
        16 && get_spread_object(
          /*contentProps*/
          ctx2[4]
        )
      ]) : {};
      if (dirty & /*$$scope, $$restProps, value*/
      33554498) {
        dialogprimitive_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dialogprimitive_content.$set(dialogprimitive_content_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(dialogprimitive_overlay.$$.fragment, local);
      transition_in(dialogprimitive_content.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialogprimitive_overlay.$$.fragment, local);
      transition_out(dialogprimitive_content.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(dialogprimitive_overlay, detaching);
      destroy_component(dialogprimitive_content, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(56:2) <DialogPrimitive.Portal>",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(51:3) <Command.Root {...$$restProps} bind:value>",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let command_root;
  let updating_value;
  let current;
  const command_root_spread_levels = [
    /*$$restProps*/
    ctx[6]
  ];
  function command_root_value_binding(value) {
    ctx[22](value);
  }
  let command_root_props = {
    $$slots: { default: [create_default_slot_2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < command_root_spread_levels.length; i += 1) {
    command_root_props = assign(command_root_props, command_root_spread_levels[i]);
  }
  if (
    /*value*/
    ctx[1] !== void 0
  ) {
    command_root_props.value = /*value*/
    ctx[1];
  }
  command_root = new cmdk_exports.Root({
    props: command_root_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(command_root, "value", command_root_value_binding));
  const block = {
    c: function create() {
      create_component(command_root.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(command_root.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(command_root, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const command_root_changes = dirty & /*$$restProps*/
      64 ? get_spread_update(command_root_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[6]
      )]) : {};
      if (dirty & /*$$scope*/
      33554432) {
        command_root_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty & /*value*/
      2) {
        updating_value = true;
        command_root_changes.value = /*value*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      command_root.$set(command_root_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(command_root.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(command_root.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(command_root, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(50:2) <DialogPrimitive.Content aria-label={label} {...contentProps}>",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block112, create_else_block88];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*portal*/
      ctx2[2] === null
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(47:0) <DialogPrimitive.Root bind:open {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment129(ctx) {
  let dialogprimitive_root;
  let updating_open;
  let current;
  const dialogprimitive_root_spread_levels = [
    /*$$restProps*/
    ctx[6]
  ];
  function dialogprimitive_root_open_binding(value) {
    ctx[24](value);
  }
  let dialogprimitive_root_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dialogprimitive_root_spread_levels.length; i += 1) {
    dialogprimitive_root_props = assign(dialogprimitive_root_props, dialogprimitive_root_spread_levels[i]);
  }
  if (
    /*open*/
    ctx[0] !== void 0
  ) {
    dialogprimitive_root_props.open = /*open*/
    ctx[0];
  }
  dialogprimitive_root = new dialog_exports.Root({
    props: dialogprimitive_root_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(dialogprimitive_root, "open", dialogprimitive_root_open_binding));
  const block = {
    c: function create() {
      create_component(dialogprimitive_root.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialogprimitive_root.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialogprimitive_root, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dialogprimitive_root_changes = dirty & /*$$restProps*/
      64 ? get_spread_update(dialogprimitive_root_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[6]
      )]) : {};
      if (dirty & /*$$scope, label, contentProps, $$restProps, value, overlayProps, portal*/
      33554558) {
        dialogprimitive_root_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty & /*open*/
      1) {
        updating_open = true;
        dialogprimitive_root_changes.open = /*open*/
        ctx2[0];
        add_flush_callback(() => updating_open = false);
      }
      dialogprimitive_root.$set(dialogprimitive_root_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(dialogprimitive_root.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialogprimitive_root.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dialogprimitive_root, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment129.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance129($$self, $$props, $$invalidate) {
  let overlayProps;
  let contentProps;
  const omit_props_names = [
    "open",
    "value",
    "portal",
    "overlayClasses",
    "contentClasses",
    "contentTransition",
    "contentTransitionConfig",
    "contentInTransition",
    "contentInTransitionConfig",
    "contentOutTransition",
    "contentOutTransitionConfig",
    "overlayTransition",
    "overlayTransitionConfig",
    "overlayInTransition",
    "overlayInTransitionConfig",
    "overlayOutTransition",
    "overlayOutTransitionConfig",
    "label"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CommandDialog", slots, ["default"]);
  let { open = false } = $$props;
  let { value = void 0 } = $$props;
  let { portal = void 0 } = $$props;
  let { overlayClasses = void 0 } = $$props;
  let { contentClasses = void 0 } = $$props;
  let { contentTransition = void 0 } = $$props;
  let { contentTransitionConfig = void 0 } = $$props;
  let { contentInTransition = void 0 } = $$props;
  let { contentInTransitionConfig = void 0 } = $$props;
  let { contentOutTransition = void 0 } = $$props;
  let { contentOutTransitionConfig = void 0 } = $$props;
  let { overlayTransition = void 0 } = $$props;
  let { overlayTransitionConfig = void 0 } = $$props;
  let { overlayInTransition = void 0 } = $$props;
  let { overlayInTransitionConfig = void 0 } = $$props;
  let { overlayOutTransition = void 0 } = $$props;
  let { overlayOutTransitionConfig = void 0 } = $$props;
  let { label = void 0 } = $$props;
  function command_root_value_binding(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }
  function command_root_value_binding_1(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }
  function dialogprimitive_root_open_binding(value2) {
    open = value2;
    $$invalidate(0, open);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
    if ("value" in $$new_props) $$invalidate(1, value = $$new_props.value);
    if ("portal" in $$new_props) $$invalidate(2, portal = $$new_props.portal);
    if ("overlayClasses" in $$new_props) $$invalidate(7, overlayClasses = $$new_props.overlayClasses);
    if ("contentClasses" in $$new_props) $$invalidate(8, contentClasses = $$new_props.contentClasses);
    if ("contentTransition" in $$new_props) $$invalidate(9, contentTransition = $$new_props.contentTransition);
    if ("contentTransitionConfig" in $$new_props) $$invalidate(10, contentTransitionConfig = $$new_props.contentTransitionConfig);
    if ("contentInTransition" in $$new_props) $$invalidate(11, contentInTransition = $$new_props.contentInTransition);
    if ("contentInTransitionConfig" in $$new_props) $$invalidate(12, contentInTransitionConfig = $$new_props.contentInTransitionConfig);
    if ("contentOutTransition" in $$new_props) $$invalidate(13, contentOutTransition = $$new_props.contentOutTransition);
    if ("contentOutTransitionConfig" in $$new_props) $$invalidate(14, contentOutTransitionConfig = $$new_props.contentOutTransitionConfig);
    if ("overlayTransition" in $$new_props) $$invalidate(15, overlayTransition = $$new_props.overlayTransition);
    if ("overlayTransitionConfig" in $$new_props) $$invalidate(16, overlayTransitionConfig = $$new_props.overlayTransitionConfig);
    if ("overlayInTransition" in $$new_props) $$invalidate(17, overlayInTransition = $$new_props.overlayInTransition);
    if ("overlayInTransitionConfig" in $$new_props) $$invalidate(18, overlayInTransitionConfig = $$new_props.overlayInTransitionConfig);
    if ("overlayOutTransition" in $$new_props) $$invalidate(19, overlayOutTransition = $$new_props.overlayOutTransition);
    if ("overlayOutTransitionConfig" in $$new_props) $$invalidate(20, overlayOutTransitionConfig = $$new_props.overlayOutTransitionConfig);
    if ("label" in $$new_props) $$invalidate(3, label = $$new_props.label);
    if ("$$scope" in $$new_props) $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    DialogPrimitive: dialog_exports,
    Command: cmdk_exports,
    open,
    value,
    portal,
    overlayClasses,
    contentClasses,
    contentTransition,
    contentTransitionConfig,
    contentInTransition,
    contentInTransitionConfig,
    contentOutTransition,
    contentOutTransitionConfig,
    overlayTransition,
    overlayTransitionConfig,
    overlayInTransition,
    overlayInTransitionConfig,
    overlayOutTransition,
    overlayOutTransitionConfig,
    label,
    contentProps,
    overlayProps
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
    if ("value" in $$props) $$invalidate(1, value = $$new_props.value);
    if ("portal" in $$props) $$invalidate(2, portal = $$new_props.portal);
    if ("overlayClasses" in $$props) $$invalidate(7, overlayClasses = $$new_props.overlayClasses);
    if ("contentClasses" in $$props) $$invalidate(8, contentClasses = $$new_props.contentClasses);
    if ("contentTransition" in $$props) $$invalidate(9, contentTransition = $$new_props.contentTransition);
    if ("contentTransitionConfig" in $$props) $$invalidate(10, contentTransitionConfig = $$new_props.contentTransitionConfig);
    if ("contentInTransition" in $$props) $$invalidate(11, contentInTransition = $$new_props.contentInTransition);
    if ("contentInTransitionConfig" in $$props) $$invalidate(12, contentInTransitionConfig = $$new_props.contentInTransitionConfig);
    if ("contentOutTransition" in $$props) $$invalidate(13, contentOutTransition = $$new_props.contentOutTransition);
    if ("contentOutTransitionConfig" in $$props) $$invalidate(14, contentOutTransitionConfig = $$new_props.contentOutTransitionConfig);
    if ("overlayTransition" in $$props) $$invalidate(15, overlayTransition = $$new_props.overlayTransition);
    if ("overlayTransitionConfig" in $$props) $$invalidate(16, overlayTransitionConfig = $$new_props.overlayTransitionConfig);
    if ("overlayInTransition" in $$props) $$invalidate(17, overlayInTransition = $$new_props.overlayInTransition);
    if ("overlayInTransitionConfig" in $$props) $$invalidate(18, overlayInTransitionConfig = $$new_props.overlayInTransitionConfig);
    if ("overlayOutTransition" in $$props) $$invalidate(19, overlayOutTransition = $$new_props.overlayOutTransition);
    if ("overlayOutTransitionConfig" in $$props) $$invalidate(20, overlayOutTransitionConfig = $$new_props.overlayOutTransitionConfig);
    if ("label" in $$props) $$invalidate(3, label = $$new_props.label);
    if ("contentProps" in $$props) $$invalidate(4, contentProps = $$new_props.contentProps);
    if ("overlayProps" in $$props) $$invalidate(5, overlayProps = $$new_props.overlayProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*overlayClasses, overlayTransition, overlayTransitionConfig, overlayInTransition, overlayInTransitionConfig, overlayOutTransition, overlayOutTransitionConfig*/
    2064512) {
      $: $$invalidate(5, overlayProps = {
        class: overlayClasses,
        transition: overlayTransition,
        transitionConfig: overlayTransitionConfig,
        inTransition: overlayInTransition,
        inTransitionConfig: overlayInTransitionConfig,
        outTransition: overlayOutTransition,
        outTransitionConfig: overlayOutTransitionConfig,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        "data-cmdk-overlay": ""
      });
    }
    if ($$self.$$.dirty & /*contentClasses, contentTransition, contentTransitionConfig, contentInTransition, contentInTransitionConfig, contentOutTransition, contentOutTransitionConfig*/
    32512) {
      $: $$invalidate(4, contentProps = {
        class: contentClasses,
        transition: contentTransition,
        transitionConfig: contentTransitionConfig,
        inTransition: contentInTransition,
        inTransitionConfig: contentInTransitionConfig,
        outTransition: contentOutTransition,
        outTransitionConfig: contentOutTransitionConfig,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        "data-cmdk-dialog": ""
      });
    }
  };
  return [
    open,
    value,
    portal,
    label,
    contentProps,
    overlayProps,
    $$restProps,
    overlayClasses,
    contentClasses,
    contentTransition,
    contentTransitionConfig,
    contentInTransition,
    contentInTransitionConfig,
    contentOutTransition,
    contentOutTransitionConfig,
    overlayTransition,
    overlayTransitionConfig,
    overlayInTransition,
    overlayInTransitionConfig,
    overlayOutTransition,
    overlayOutTransitionConfig,
    slots,
    command_root_value_binding,
    command_root_value_binding_1,
    dialogprimitive_root_open_binding,
    $$scope
  ];
}
var CommandDialog = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance129, create_fragment129, safe_not_equal, {
      open: 0,
      value: 1,
      portal: 2,
      overlayClasses: 7,
      contentClasses: 8,
      contentTransition: 9,
      contentTransitionConfig: 10,
      contentInTransition: 11,
      contentInTransitionConfig: 12,
      contentOutTransition: 13,
      contentOutTransitionConfig: 14,
      overlayTransition: 15,
      overlayTransitionConfig: 16,
      overlayInTransition: 17,
      overlayInTransitionConfig: 18,
      overlayOutTransition: 19,
      overlayOutTransitionConfig: 20,
      label: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CommandDialog",
      options,
      id: create_fragment129.name
    });
  }
  get open() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get portal() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portal(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overlayClasses() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlayClasses(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentClasses() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentClasses(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentTransition() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentTransition(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentTransitionConfig() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentTransitionConfig(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentInTransition() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentInTransition(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentInTransitionConfig() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentInTransitionConfig(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentOutTransition() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentOutTransition(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentOutTransitionConfig() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentOutTransitionConfig(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overlayTransition() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlayTransition(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overlayTransitionConfig() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlayTransitionConfig(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overlayInTransition() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlayInTransition(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overlayInTransitionConfig() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlayInTransitionConfig(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overlayOutTransition() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlayOutTransition(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overlayOutTransitionConfig() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlayOutTransitionConfig(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<CommandDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<CommandDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CommandDialog_default = CommandDialog;

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandEmpty.svelte
var file112 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandEmpty.svelte";
var get_default_slot_changes119 = (dirty) => ({});
var get_default_slot_context119 = (ctx) => ({ attrs: (
  /*attrs*/
  ctx[4]
) });
function create_if_block113(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_118, create_else_block89];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block113.name,
    type: "if",
    source: "(17:0) {#if !isFirstRender && render}",
    ctx
  });
  return block;
}
function create_else_block89(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    /*attrs*/
    ctx[4],
    /*$$restProps*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file112, 20, 2, 406);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        /*attrs*/
        ctx2[4],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block89.name,
    type: "else",
    source: "(20:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block_118(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context119
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes119
            ),
            get_default_slot_context119
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_118.name,
    type: "if",
    source: "(18:1) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment130(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*isFirstRender*/
  ctx[1] && /*render*/
  ctx[2] && create_if_block113(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!/*isFirstRender*/
      ctx2[1] && /*render*/
      ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isFirstRender, render*/
          6) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block113(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment130.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance130($$self, $$props, $$invalidate) {
  let render;
  const omit_props_names = ["asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $state;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CommandEmpty", slots, ["default"]);
  let { asChild = false } = $$props;
  let isFirstRender = true;
  onMount(() => {
    $$invalidate(1, isFirstRender = false);
  });
  const state = getState();
  validate_store(state, "state");
  component_subscribe($$self, state, (value) => $$invalidate(6, $state = value));
  const attrs = {
    "data-cmdk-empty": "",
    role: "presentation"
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    getState,
    asChild,
    isFirstRender,
    state,
    attrs,
    render,
    $state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("isFirstRender" in $$props) $$invalidate(1, isFirstRender = $$new_props.isFirstRender);
    if ("render" in $$props) $$invalidate(2, render = $$new_props.render);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$state*/
    64) {
      $: $$invalidate(2, render = $state.filtered.count === 0);
    }
  };
  return [
    asChild,
    isFirstRender,
    render,
    state,
    attrs,
    $$restProps,
    $state,
    $$scope,
    slots
  ];
}
var CommandEmpty = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance130, create_fragment130, safe_not_equal, { asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CommandEmpty",
      options,
      id: create_fragment130.name
    });
  }
  get asChild() {
    throw new Error("<CommandEmpty>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<CommandEmpty>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CommandEmpty_default = CommandEmpty;

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandGroup.svelte
var file113 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandGroup.svelte";
var get_default_slot_changes_182 = (dirty) => ({
  container: dirty & /*container*/
  32,
  group: dirty & /*group*/
  16
});
var get_default_slot_context_182 = (ctx) => ({
  container: (
    /*container*/
    ctx[5]
  ),
  group: (
    /*group*/
    ctx[4]
  ),
  heading: { attrs: (
    /*headingAttrs*/
    ctx[8]
  ) }
});
var get_default_slot_changes120 = (dirty) => ({
  container: dirty & /*container*/
  32,
  group: dirty & /*group*/
  16
});
var get_default_slot_context120 = (ctx) => ({
  container: (
    /*container*/
    ctx[5]
  ),
  group: (
    /*group*/
    ctx[4]
  ),
  heading: { attrs: (
    /*headingAttrs*/
    ctx[8]
  ) }
});
function create_else_block90(ctx) {
  let div1;
  let t;
  let div0;
  let containerAction_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*heading*/
    ctx[0] && create_if_block_119(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context_182
  );
  let div0_levels = [
    /*groupAttrs*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div_data = assign(div_data, div0_levels[i]);
  }
  let div1_levels = [
    /*containerAttrs*/
    ctx[3],
    /*$$restProps*/
    ctx[9]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block) if_block.c();
      t = space();
      div0 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (if_block) if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div0, div_data);
      add_location(div0, file113, 77, 2, 1829);
      set_attributes(div1, div_data_1);
      add_location(div1, file113, 71, 1, 1689);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block) if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(containerAction_action = /*containerAction*/
        ctx[7].call(null, div1));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*heading*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_119(ctx2);
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, container, group*/
        8240)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes_182
            ),
            get_default_slot_context_182
          );
        }
      }
      set_attributes(div0, div_data = get_spread_update(div0_levels, [dirty & /*groupAttrs*/
      4 && /*groupAttrs*/
      ctx2[2]]));
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        dirty & /*containerAttrs*/
        8 && /*containerAttrs*/
        ctx2[3],
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block90.name,
    type: "else",
    source: "(71:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block114(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context120
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, container, group*/
        8240)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes120
            ),
            get_default_slot_context120
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block114.name,
    type: "if",
    source: "(69:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_if_block_119(ctx) {
  let div;
  let t;
  let div_levels = [
    /*headingAttrs*/
    ctx[8]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*heading*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*heading*/
        ctx[0]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file113, 73, 3, 1771);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*heading*/
      1) set_data_maybe_contenteditable_dev(
        t,
        /*heading*/
        ctx2[0],
        div_data["contenteditable"]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_119.name,
    type: "if",
    source: "(73:2) {#if heading}",
    ctx
  });
  return block;
}
function create_fragment131(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block114, create_else_block90];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment131.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance131($$self, $$props, $$invalidate) {
  let containerAttrs;
  let groupAttrs;
  let container;
  let group;
  const omit_props_names = ["heading", "value", "alwaysRender", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $render;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CommandGroup", slots, ["default"]);
  let { heading = void 0 } = $$props;
  let { value = "" } = $$props;
  let { alwaysRender = false } = $$props;
  let { asChild = false } = $$props;
  const { id } = createGroup(alwaysRender);
  const context = getCtx();
  const state = getState();
  const headingId = generateId();
  const render = derived(state, ($state) => {
    if (alwaysRender) return true;
    if (context.filter() === false) return true;
    if (!$state.search) return true;
    return $state.filtered.groups.has(id);
  });
  validate_store(render, "render");
  component_subscribe($$self, render, (value2) => $$invalidate(12, $render = value2));
  onMount(() => {
    const unsubGroup = context.group(id);
    return unsubGroup;
  });
  function containerAction(node) {
    if (value) {
      context.value(id, value);
      node.setAttribute(VALUE_ATTR, value);
      return;
    }
    if (heading) {
      $$invalidate(10, value = heading.trim().toLowerCase());
    } else if (node.textContent) {
      $$invalidate(10, value = node.textContent.trim().toLowerCase());
    }
    context.value(id, value);
    node.setAttribute(VALUE_ATTR, value);
  }
  const headingAttrs = {
    "data-cmdk-group-heading": "",
    "aria-hidden": true,
    id: headingId
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("heading" in $$new_props) $$invalidate(0, heading = $$new_props.heading);
    if ("value" in $$new_props) $$invalidate(10, value = $$new_props.value);
    if ("alwaysRender" in $$new_props) $$invalidate(11, alwaysRender = $$new_props.alwaysRender);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    generateId,
    derived,
    VALUE_ATTR,
    getCtx,
    getState,
    createGroup,
    onMount,
    heading,
    value,
    alwaysRender,
    asChild,
    id,
    context,
    state,
    headingId,
    render,
    containerAction,
    headingAttrs,
    groupAttrs,
    group,
    containerAttrs,
    container,
    $render
  });
  $$self.$inject_state = ($$new_props) => {
    if ("heading" in $$props) $$invalidate(0, heading = $$new_props.heading);
    if ("value" in $$props) $$invalidate(10, value = $$new_props.value);
    if ("alwaysRender" in $$props) $$invalidate(11, alwaysRender = $$new_props.alwaysRender);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("groupAttrs" in $$props) $$invalidate(2, groupAttrs = $$new_props.groupAttrs);
    if ("group" in $$props) $$invalidate(4, group = $$new_props.group);
    if ("containerAttrs" in $$props) $$invalidate(3, containerAttrs = $$new_props.containerAttrs);
    if ("container" in $$props) $$invalidate(5, container = $$new_props.container);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$render, value*/
    5120) {
      $: $$invalidate(3, containerAttrs = {
        "data-cmdk-group": "",
        role: "presentation",
        hidden: $render ? void 0 : true,
        "data-value": value
      });
    }
    if ($$self.$$.dirty & /*heading*/
    1) {
      $: $$invalidate(2, groupAttrs = {
        "data-cmdk-group-items": "",
        role: "group",
        "aria-labelledby": heading ? headingId : void 0
      });
    }
    if ($$self.$$.dirty & /*containerAttrs*/
    8) {
      $: $$invalidate(5, container = {
        action: containerAction,
        attrs: containerAttrs
      });
    }
    if ($$self.$$.dirty & /*groupAttrs*/
    4) {
      $: $$invalidate(4, group = { attrs: groupAttrs });
    }
  };
  return [
    heading,
    asChild,
    groupAttrs,
    containerAttrs,
    group,
    container,
    render,
    containerAction,
    headingAttrs,
    $$restProps,
    value,
    alwaysRender,
    $render,
    $$scope,
    slots
  ];
}
var CommandGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance131, create_fragment131, safe_not_equal, {
      heading: 0,
      value: 10,
      alwaysRender: 11,
      asChild: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CommandGroup",
      options,
      id: create_fragment131.name
    });
  }
  get heading() {
    throw new Error("<CommandGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set heading(value) {
    throw new Error("<CommandGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<CommandGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<CommandGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alwaysRender() {
    throw new Error("<CommandGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alwaysRender(value) {
    throw new Error("<CommandGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<CommandGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<CommandGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CommandGroup_default = CommandGroup;

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/internal/helpers/sleep.js
function sleep2(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandInput.svelte
var file114 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandInput.svelte";
var get_default_slot_changes121 = (dirty) => ({ attrs: dirty & /*attrs*/
8 });
var get_default_slot_context121 = (ctx) => ({
  action: (
    /*action*/
    ctx[6]
  ),
  attrs: (
    /*attrs*/
    ctx[3]
  )
});
function create_else_block91(ctx) {
  let input;
  let action_action;
  let mounted;
  let dispose;
  let input_levels = [
    /*attrs*/
    ctx[3],
    /*$$restProps*/
    ctx[7]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {});
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file114, 57, 1, 1646);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus) input.focus();
      ctx[17](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[18]
          ),
          action_destroyer(action_action = /*action*/
          ctx[6].call(null, input)),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty & /*attrs*/
        8 && /*attrs*/
        ctx2[3],
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block91.name,
    type: "else",
    source: "(57:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block115(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context121
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, attrs*/
        1032)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes121
            ),
            get_default_slot_context121
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block115.name,
    type: "if",
    source: "(55:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment132(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block115, create_else_block91];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[2]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment132.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance132($$self, $$props, $$invalidate) {
  const omit_props_names = ["autofocus", "value", "asChild", "el"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedItemId;
  let $search;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CommandInput", slots, ["default"]);
  const { ids, commandEl } = getCtx();
  const state = getState();
  const search = derived(state, ($state) => $state.search);
  validate_store(search, "search");
  component_subscribe($$self, search, (value2) => $$invalidate(19, $search = value2));
  const valueStore = derived(state, ($state) => $state.value);
  let { autofocus = void 0 } = $$props;
  let { value = $search } = $$props;
  let { asChild = false } = $$props;
  let { el = void 0 } = $$props;
  const selectedItemId = derived([valueStore, commandEl], ([$value, $commandEl]) => {
    if (!isBrowser) return void 0;
    const item = $commandEl == null ? void 0 : $commandEl.querySelector(`${ITEM_SELECTOR}[${VALUE_ATTR}="${$value}"]`);
    return item == null ? void 0 : item.getAttribute("id");
  });
  validate_store(selectedItemId, "selectedItemId");
  component_subscribe($$self, selectedItemId, (value2) => $$invalidate(9, $selectedItemId = value2));
  function handleValueUpdate(v) {
    state.updateState("search", v);
  }
  function action(node) {
    if (autofocus) {
      sleep2(10).then(() => node.focus());
    }
    const unsubEvents = addEventListener(node, "change", (e) => {
      if (!isHTMLInputElement(e.target)) return;
      state.updateState("search", e.target.value);
    });
    return { destroy: unsubEvents };
  }
  let attrs;
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("autofocus" in $$new_props) $$invalidate(8, autofocus = $$new_props.autofocus);
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("asChild" in $$new_props) $$invalidate(2, asChild = $$new_props.asChild);
    if ("el" in $$new_props) $$invalidate(1, el = $$new_props.el);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    derived,
    ITEM_SELECTOR,
    VALUE_ATTR,
    getCtx,
    getState,
    addEventListener,
    isBrowser,
    isHTMLInputElement,
    sleep: sleep2,
    ids,
    commandEl,
    state,
    search,
    valueStore,
    autofocus,
    value,
    asChild,
    el,
    selectedItemId,
    handleValueUpdate,
    action,
    attrs,
    $selectedItemId,
    $search
  });
  $$self.$inject_state = ($$new_props) => {
    if ("autofocus" in $$props) $$invalidate(8, autofocus = $$new_props.autofocus);
    if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    if ("asChild" in $$props) $$invalidate(2, asChild = $$new_props.asChild);
    if ("el" in $$props) $$invalidate(1, el = $$new_props.el);
    if ("attrs" in $$props) $$invalidate(3, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    1) {
      $: handleValueUpdate(value);
    }
    if ($$self.$$.dirty & /*$selectedItemId*/
    512) {
      $: $$invalidate(3, attrs = {
        type: "text",
        "data-cmdk-input": "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: false,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": true,
        "aria-controls": ids.list,
        "aria-labelledby": ids.label,
        "aria-activedescendant": $selectedItemId ?? void 0,
        id: ids.input
      });
    }
  };
  return [
    value,
    el,
    asChild,
    attrs,
    search,
    selectedItemId,
    action,
    $$restProps,
    autofocus,
    $selectedItemId,
    $$scope,
    slots,
    keydown_handler,
    input_handler,
    focus_handler,
    blur_handler,
    change_handler,
    input_binding,
    input_input_handler
  ];
}
var CommandInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance132, create_fragment132, safe_not_equal, {
      autofocus: 8,
      value: 0,
      asChild: 2,
      el: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CommandInput",
      options,
      id: create_fragment132.name
    });
  }
  get autofocus() {
    throw new Error("<CommandInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autofocus(value) {
    throw new Error("<CommandInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<CommandInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<CommandInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<CommandInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<CommandInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get el() {
    throw new Error("<CommandInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error("<CommandInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CommandInput_default = CommandInput;

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandItem.svelte
var file115 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandItem.svelte";
var get_default_slot_changes_183 = (dirty) => ({ attrs: dirty & /*attrs*/
4 });
var get_default_slot_context_183 = (ctx) => ({
  action: (
    /*action*/
    ctx[6]
  ),
  attrs: (
    /*attrs*/
    ctx[2]
  )
});
var get_default_slot_changes122 = (dirty) => ({ attrs: dirty & /*attrs*/
4 });
var get_default_slot_context122 = (ctx) => ({
  action: (
    /*action*/
    ctx[6]
  ),
  attrs: (
    /*attrs*/
    ctx[2]
  )
});
function create_if_block116(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_120, create_else_block92];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block116.name,
    type: "if",
    source: "(79:0) {#if $render || isFirstRender}",
    ctx
  });
  return block;
}
function create_else_block92(ctx) {
  let div;
  let action_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context_183
  );
  let div_levels = [
    /*attrs*/
    ctx[2],
    /*$$restProps*/
    ctx[7]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file115, 82, 2, 2093);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(action_action = /*action*/
        ctx[6].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, attrs*/
        16388)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes_183
            ),
            get_default_slot_context_183
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*attrs*/
        4 && /*attrs*/
        ctx2[2],
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block92.name,
    type: "else",
    source: "(82:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block_120(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context122
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, attrs*/
        16388)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes122
            ),
            get_default_slot_context122
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_120.name,
    type: "if",
    source: "(80:1) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment133(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$render*/
    (ctx[3] || /*isFirstRender*/
    ctx[1]) && create_if_block116(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$render*/
        ctx2[3] || /*isFirstRender*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$render, isFirstRender*/
          10) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block116(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment133.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance133($$self, $$props, $$invalidate) {
  let attrs;
  const omit_props_names = ["disabled", "value", "onSelect", "alwaysRender", "asChild", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selected;
  let $render;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CommandItem", slots, ["default"]);
  let { disabled = false } = $$props;
  let { value = "" } = $$props;
  let { onSelect = void 0 } = $$props;
  let { alwaysRender = false } = $$props;
  let { asChild = false } = $$props;
  let { id = generateId() } = $$props;
  const groupContext = getGroup();
  const context = getCtx();
  const state = getState();
  const trueAlwaysRender = alwaysRender ?? (groupContext == null ? void 0 : groupContext.alwaysRender);
  const render = derived(state, ($state) => {
    if (trueAlwaysRender || context.filter() === false || !$state.search) return true;
    const currentScore = $state.filtered.items.get(id);
    if (isUndefined(currentScore)) return false;
    return currentScore > 0;
  });
  validate_store(render, "render");
  component_subscribe($$self, render, (value2) => $$invalidate(3, $render = value2));
  let isFirstRender = true;
  onMount(() => {
    $$invalidate(1, isFirstRender = false);
    const unsub = context.item(id, groupContext == null ? void 0 : groupContext.id);
    return unsub;
  });
  const selected = derived(state, ($state) => $state.value === value);
  validate_store(selected, "selected");
  component_subscribe($$self, selected, (value2) => $$invalidate(13, $selected = value2));
  function action(node) {
    if (!value && node.textContent) {
      $$invalidate(8, value = node.textContent.trim().toLowerCase());
    }
    context.value(id, value);
    node.setAttribute(VALUE_ATTR, value);
    const unsubEvents = executeCallbacks(
      addEventListener(node, "pointermove", () => {
        if (disabled) return;
        select();
      }),
      addEventListener(node, "click", () => {
        if (disabled) return;
        handleItemClick();
      })
    );
    return {
      destroy() {
        unsubEvents();
      }
    };
  }
  function handleItemClick() {
    select();
    onSelect == null ? void 0 : onSelect(value);
  }
  function select() {
    state.updateState("value", value, true);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("disabled" in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
    if ("value" in $$new_props) $$invalidate(8, value = $$new_props.value);
    if ("onSelect" in $$new_props) $$invalidate(10, onSelect = $$new_props.onSelect);
    if ("alwaysRender" in $$new_props) $$invalidate(11, alwaysRender = $$new_props.alwaysRender);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$new_props) $$invalidate(12, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    addEventListener,
    executeCallbacks,
    generateId,
    isUndefined,
    onMount,
    VALUE_ATTR,
    getCtx,
    getGroup,
    getState,
    derived,
    disabled,
    value,
    onSelect,
    alwaysRender,
    asChild,
    id,
    groupContext,
    context,
    state,
    trueAlwaysRender,
    render,
    isFirstRender,
    selected,
    action,
    handleItemClick,
    select,
    attrs,
    $selected,
    $render
  });
  $$self.$inject_state = ($$new_props) => {
    if ("disabled" in $$props) $$invalidate(9, disabled = $$new_props.disabled);
    if ("value" in $$props) $$invalidate(8, value = $$new_props.value);
    if ("onSelect" in $$props) $$invalidate(10, onSelect = $$new_props.onSelect);
    if ("alwaysRender" in $$props) $$invalidate(11, alwaysRender = $$new_props.alwaysRender);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("id" in $$props) $$invalidate(12, id = $$new_props.id);
    if ("isFirstRender" in $$props) $$invalidate(1, isFirstRender = $$new_props.isFirstRender);
    if ("attrs" in $$props) $$invalidate(2, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*disabled, $selected, value, id*/
    13056) {
      $: $$invalidate(2, attrs = {
        "aria-disabled": disabled ? true : void 0,
        "aria-selected": $selected ? true : void 0,
        "data-disabled": disabled ? true : void 0,
        "data-selected": $selected ? true : void 0,
        "data-cmdk-item": "",
        "data-value": value,
        role: "option",
        id
      });
    }
  };
  return [
    asChild,
    isFirstRender,
    attrs,
    $render,
    render,
    selected,
    action,
    $$restProps,
    value,
    disabled,
    onSelect,
    alwaysRender,
    id,
    $selected,
    $$scope,
    slots
  ];
}
var CommandItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance133, create_fragment133, safe_not_equal, {
      disabled: 9,
      value: 8,
      onSelect: 10,
      alwaysRender: 11,
      asChild: 0,
      id: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CommandItem",
      options,
      id: create_fragment133.name
    });
  }
  get disabled() {
    throw new Error("<CommandItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<CommandItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<CommandItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<CommandItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<CommandItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<CommandItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alwaysRender() {
    throw new Error("<CommandItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alwaysRender(value) {
    throw new Error("<CommandItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<CommandItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<CommandItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<CommandItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<CommandItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CommandItem_default = CommandItem;

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandList.svelte
var file116 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandList.svelte";
var get_default_slot_changes123 = (dirty) => ({});
var get_default_slot_context123 = (ctx) => ({
  list: (
    /*list*/
    ctx[7]
  ),
  sizer: (
    /*sizer*/
    ctx[8]
  )
});
function create_else_block93(ctx) {
  let div1;
  let div0;
  let previous_key = (
    /*$state*/
    ctx[2].search === ""
  );
  let sizerAction_action;
  let current;
  let mounted;
  let dispose;
  let key_block = create_key_block_1(ctx);
  let div0_levels = [
    /*sizerAttrs*/
    ctx[6]
  ];
  let div_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div_data = assign(div_data, div0_levels[i]);
  }
  let div1_levels = [
    /*listAttrs*/
    ctx[5],
    /*$$restProps*/
    ctx[9]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      key_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      key_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div0, div_data);
      add_location(div0, file116, 51, 2, 1190);
      set_attributes(div1, div_data_1);
      add_location(div1, file116, 50, 1, 1135);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      key_block.m(div0, null);
      ctx[12](div1);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(sizerAction_action = /*sizerAction*/
        ctx[4].call(null, div0));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$state*/
      4 && safe_not_equal(previous_key, previous_key = /*$state*/
      ctx2[2].search === "")) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block_1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div0, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        /*listAttrs*/
        ctx2[5],
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(key_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      key_block.d(detaching);
      ctx[12](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block93.name,
    type: "else",
    source: "(50:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block117(ctx) {
  let previous_key = (
    /*$state*/
    ctx[2].search === ""
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  const block = {
    c: function create() {
      key_block.c();
      key_block_anchor = empty();
    },
    l: function claim(nodes) {
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration_dev(target, key_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$state*/
      4 && safe_not_equal(previous_key, previous_key = /*$state*/
      ctx2[2].search === "")) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(key_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(key_block_anchor);
      }
      key_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block117.name,
    type: "if",
    source: "(46:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_key_block_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block_1.name,
    type: "key",
    source: "(53:3) {#key $state.search === ''}",
    ctx
  });
  return block;
}
function create_key_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context123
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes123
            ),
            get_default_slot_context123
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block.name,
    type: "key",
    source: "(47:1) {#key $state.search === ''}",
    ctx
  });
  return block;
}
function create_fragment134(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block117, create_else_block93];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment134.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance134($$self, $$props, $$invalidate) {
  const omit_props_names = ["el", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $state;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CommandList", slots, ["default"]);
  const { ids } = getCtx();
  const state = getState();
  validate_store(state, "state");
  component_subscribe($$self, state, (value) => $$invalidate(2, $state = value));
  let { el = void 0 } = $$props;
  let { asChild = false } = $$props;
  function sizerAction(node) {
    let animationFrame;
    const listEl = node.closest("[data-cmdk-list]");
    if (!isHTMLElement(listEl)) {
      return;
    }
    const observer = new ResizeObserver(() => {
      animationFrame = requestAnimationFrame(() => {
        const height = node.offsetHeight;
        listEl.style.setProperty("--cmdk-list-height", height.toFixed(1) + "px");
      });
    });
    observer.observe(node);
    return {
      destroy() {
        cancelAnimationFrame(animationFrame);
        observer.unobserve(node);
      }
    };
  }
  const listAttrs = {
    "data-cmdk-list": "",
    role: "listbox",
    "aria-label": "Suggestions",
    id: ids.list,
    "aria-labelledby": ids.input
  };
  const sizerAttrs = { "data-cmdk-list-sizer": "" };
  const list = { attrs: listAttrs };
  const sizer = { attrs: sizerAttrs, action: sizerAction };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("el" in $$new_props) $$invalidate(0, el = $$new_props.el);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    isHTMLElement,
    getCtx,
    getState,
    ids,
    state,
    el,
    asChild,
    sizerAction,
    listAttrs,
    sizerAttrs,
    list,
    sizer,
    $state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    el,
    asChild,
    $state,
    state,
    sizerAction,
    listAttrs,
    sizerAttrs,
    list,
    sizer,
    $$restProps,
    $$scope,
    slots,
    div1_binding
  ];
}
var CommandList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance134, create_fragment134, safe_not_equal, { el: 0, asChild: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CommandList",
      options,
      id: create_fragment134.name
    });
  }
  get el() {
    throw new Error("<CommandList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error("<CommandList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<CommandList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<CommandList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CommandList_default = CommandList;

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandLoading.svelte
var file117 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandLoading.svelte";
var get_default_slot_changes_184 = (dirty) => ({ attrs: dirty & /*attrs*/
2 });
var get_default_slot_context_184 = (ctx) => ({ attrs: (
  /*attrs*/
  ctx[1]
) });
var get_default_slot_changes124 = (dirty) => ({ attrs: dirty & /*attrs*/
2 });
var get_default_slot_context124 = (ctx) => ({ attrs: (
  /*attrs*/
  ctx[1]
) });
function create_else_block94(ctx) {
  let div1;
  let div0;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_default_slot_context_184
  );
  let div1_levels = [
    /*attrs*/
    ctx[1],
    /*$$restProps*/
    ctx[2]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { "aria-hidden": true });
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "aria-hidden", "");
      add_location(div0, file117, 17, 2, 335);
      set_attributes(div1, div_data_1);
      add_location(div1, file117, 16, 1, 299);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, attrs*/
        18)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_default_slot_changes_184
            ),
            get_default_slot_context_184
          );
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        dirty & /*attrs*/
        2 && /*attrs*/
        ctx2[1],
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block94.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block118(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_default_slot_context124
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, attrs*/
        18)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_default_slot_changes124
            ),
            get_default_slot_context124
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block118.name,
    type: "if",
    source: "(14:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment135(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block118, create_else_block94];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment135.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance135($$self, $$props, $$invalidate) {
  let attrs;
  const omit_props_names = ["progress", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CommandLoading", slots, ["default"]);
  let { progress = 0 } = $$props;
  let { asChild = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("progress" in $$new_props) $$invalidate(3, progress = $$new_props.progress);
    if ("asChild" in $$new_props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ progress, asChild, attrs });
  $$self.$inject_state = ($$new_props) => {
    if ("progress" in $$props) $$invalidate(3, progress = $$new_props.progress);
    if ("asChild" in $$props) $$invalidate(0, asChild = $$new_props.asChild);
    if ("attrs" in $$props) $$invalidate(1, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*progress*/
    8) {
      $: $$invalidate(1, attrs = {
        "data-cmdk-loading": "",
        role: "progressbar",
        "aria-valuenow": progress,
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-label": "Loading..."
      });
    }
  };
  return [asChild, attrs, $$restProps, progress, $$scope, slots];
}
var CommandLoading = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance135, create_fragment135, safe_not_equal, { progress: 3, asChild: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CommandLoading",
      options,
      id: create_fragment135.name
    });
  }
  get progress() {
    throw new Error("<CommandLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set progress(value) {
    throw new Error("<CommandLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<CommandLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<CommandLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CommandLoading_default = CommandLoading;

// ../../node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandSeparator.svelte
var file118 = "Users/santi/Downloads/TESTDASH/shadcn-svelte/node_modules/.pnpm/cmdk-sv@0.0.15_svelte@4.2.19/node_modules/cmdk-sv/dist/cmdk/components/CommandSeparator.svelte";
var get_default_slot_changes125 = (dirty) => ({});
var get_default_slot_context125 = (ctx) => ({ attrs: (
  /*attrs*/
  ctx[4]
) });
function create_if_block119(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_121, create_else_block95];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block119.name,
    type: "if",
    source: "(13:0) {#if $render || alwaysRender}",
    ctx
  });
  return block;
}
function create_else_block95(ctx) {
  let div;
  let div_levels = [
    /*attrs*/
    ctx[4],
    /*$$restProps*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file118, 16, 2, 390);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        /*attrs*/
        ctx2[4],
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block95.name,
    type: "else",
    source: "(16:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block_121(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context125
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes125
            ),
            get_default_slot_context125
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_121.name,
    type: "if",
    source: "(14:1) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment136(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$render*/
    (ctx[2] || /*alwaysRender*/
    ctx[0]) && create_if_block119(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$render*/
        ctx2[2] || /*alwaysRender*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$render, alwaysRender*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block119(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment136.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance136($$self, $$props, $$invalidate) {
  const omit_props_names = ["alwaysRender", "asChild"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $render;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CommandSeparator", slots, ["default"]);
  let { alwaysRender = false } = $$props;
  let { asChild = false } = $$props;
  const state = getState();
  const render = derived(state, ($state) => !$state.search);
  validate_store(render, "render");
  component_subscribe($$self, render, (value) => $$invalidate(2, $render = value));
  const attrs = {
    "data-cmdk-separator": "",
    role: "separator"
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("alwaysRender" in $$new_props) $$invalidate(0, alwaysRender = $$new_props.alwaysRender);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    derived,
    getState,
    alwaysRender,
    asChild,
    state,
    render,
    attrs,
    $render
  });
  $$self.$inject_state = ($$new_props) => {
    if ("alwaysRender" in $$props) $$invalidate(0, alwaysRender = $$new_props.alwaysRender);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [alwaysRender, asChild, $render, render, attrs, $$restProps, $$scope, slots];
}
var CommandSeparator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance136, create_fragment136, safe_not_equal, { alwaysRender: 0, asChild: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CommandSeparator",
      options,
      id: create_fragment136.name
    });
  }
  get alwaysRender() {
    throw new Error("<CommandSeparator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alwaysRender(value) {
    throw new Error("<CommandSeparator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<CommandSeparator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<CommandSeparator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CommandSeparator_default = CommandSeparator;
export {
  cmdk_exports as Command,
  CommandDialog_default as CommandDialog,
  CommandEmpty_default as CommandEmpty,
  CommandGroup_default as CommandGroup,
  CommandInput_default as CommandInput,
  CommandItem_default as CommandItem,
  CommandList_default as CommandList,
  CommandLoading_default as CommandLoading,
  Command_default as CommandRoot,
  CommandSeparator_default as CommandSeparator,
  createState,
  defaultFilter
};
//# sourceMappingURL=cmdk-sv.js.map
